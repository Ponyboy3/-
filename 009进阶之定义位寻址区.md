## 定义位寻址区：bdata的用法

> 若程序需要8个或者更多的bit变量，如果你想一次性给8个变量赋值的话就不方便了，(举个例子说说它的方便之处，想更深入的了解请在应用中自己琢磨)又不可以定义bit数组，<u>**只有一个方法**</u>：
>
> ```
> unsigned char bdata U6 = 0xff;
> sbit led_8 = U6^7;
> sbit led_7 = U6^6;
> sbit led_6 = U6^5;
> sbit led_5 = U6^4;
> sbit led_4 = U6^3;
> sbit led_3 = U6^2;
> sbit led_2 = U6^1;
> sbit led_1 = U6^0;
> ```
>
> 8个bit变量`led_n`就定义好了，这是定义语句，Keilc 的特殊数据类型。记住**一定要<u>是</u>`sbit`**<u>不能</u> `bit led_1= U6^0`;赋值语句要是这么些C语言就视为异或运算
>
> `unsigned char bdata U6;` 定义一个无符号的字符型变量`U6`, `bdata`用于将变量定义在可位寻址片内数据存储区
> `sbit led1=U6^6;` `sbit` 位定义，定义后对`led1`的操作就是对端口`U6^6`的操作。
> 例如：
> `led1＝ 1;//给端口U0^6送高电平`
> `led1＝ 0;//给端口U0^6送低电平`
>
> 特殊功能寄存器中不是所有字节都可进行位寻址，支持位寻址字节地址的是：	0x80，0x88，0x90, 0x98, 0xA0, 0xA0, 0xA8, 0xB0, 0xB8, 0xC0, 0xC8, 0xD0, 0xD8, 0xE0, 0xE8, 0xF0, 0xF8共16个，这些地址不连是续，**能被8整除**， 即字节地址是***以8或0为尾数***的。
>
> ![img](https://img-blog.csdnimg.cn/img_convert/6f3126567358b7653b17eba52bc7d642.png)



## 补充**data,idata,xdata,pdata**的区别:

> **data:** 固定指前面0x00-0x7f的128个RAM,可以用[acc](https://so.csdn.net/so/search?q=acc&spm=1001.2101.3001.7020)直接读写的,速度最快,生成的代码也最小。
>
> **idata:** 固定指前面0x00-0xff的256个RAM,其中前128和data的128完全相同,只是因为访问的方式不同。idata是用类似C中的指针方式 访问的。[汇编](https://so.csdn.net/so/search?q=汇编&spm=1001.2101.3001.7020)中的语句为：mox ACC,@Rx.(不重要的补充：c中idata做指针式的访问效果很好)
>
> **xdata:** 外部扩展RAM,一般指外部0x0000-0xffff空间,用DPTR访问。
>
> **pdata:** 外部扩展RAM的低256个字节,地址出现在A0-A7的上时读写,用movx ACC,@Rx读写。这个比较特殊,而且C51好象有对此BUG, 建议少用。但也有他的优点,具体用法属于中级问题,这里不提。

## 单片机C语言unsigned char code table[] 中code 作用

> code的作用是告诉单片机，我定义的数据要放在ROM（程序存储区）里面，**写入后就不能再更改**，其实是相当与汇编里面的寻址MOVX(好像是这样)，因为C语言中没办法详细描述存入的是ROM还是RAM（寄存器），所以在软件中添加了这一个语句起到代替汇编指令的作用，对应的还有data(默认什么也不写：`unsigned char t_2ms`)是存入RAM的意思。
>
> 程序可以简单的分为code（程序）区，和data （数据）区，code区在运行的时候是不可以更改的，data区放全局变量和临时变量，是要不断的改变的，CPU从code区读取指令，对data区的数据进行运算处理，因此code区存储在什么介质上并不重要，像以前的计算机程序存储在卡片上，code区也可以放在ROM里面，也可以放在RAM里面，也可以放在flash里面（但是运行速度要慢很多，主要读flash比读RAM要费时间），因此一般的做法是要将程序放到flash里面，然后load到 RAM里面运行的;DATA区就没有什么选择了，肯定要放在RAM里面，放到ROM里面改动不了。

## 注意事项

> 1、 data 区空间小,所以只有频繁用到或对运算速度要求很高的变量才放到 data 区内,比如 for 循环中的计数值。
>
> 2、 data 区内最好放局部变量。
>
> 因为局部变量的空间是可以覆盖的（某个函数的局部变量空间在退出该函数是就释放,由别的函数的局部变量覆盖）,可以提高内存利用率 。当然静态局部变量除外,其内存使用方式与全局变量相同;
>
> 3、 确保你的程序中没有未调用的函数。
>
> 在 Keil C 里遇到未调用函数,编译器就将其认为可能是中断函数。函数里用的局部变量的空间是不释放,也就是同全局变量一样处理。这一点 Keil C 做得很愚蠢,但也没办法。
>
> 4、 程序中遇到的逻辑标志变量可以定义到 bdata 中,可以大大降低内存占用空间。
>
> 在 51 系列芯片中有 16 个字节位寻址区 bdata ,其中可以定义 8*16=128 个逻辑变量。定义方法是： bdata bit LedState;但位类型不能用在数组和结构体中。
>
> 5、 其他不频繁用到和对运算速度要求不高的变量都放到 xdata 区。
>
> 6、 如果想节省 data 空间就必须用 large 模式,将未定义内存位置的变量全放到 xdata 区。当然最好对所有变量都要指定内存类型。
>
> 7、 当使用到指针时,要指定指针指向的内存类型。
> （转自：https://blog.csdn.net/fanscky/article/details/6250192）
>
> | **空间名称**      | **地址范围**                                        | **说明**                                       |
> | ----------------- | --------------------------------------------------- | ---------------------------------------------- |
> | **DATA**          | D:00H~7FH                                           | 片内RAM直接寻址区                              |
> | **BDATA**         | D:20H~2FH                                           | 片内RAM位寻址区                                |
> | **IDATA**         | I:00H~FFH                                           | 片内RAM间接寻址区                              |
> | **XDATA**         | X:0000H~FFFFH                                       | 64KB常规片外RAM数据区                          |
> | **HDATA**         | X:0000H~FFFFFFH                                     | 16MB扩展片外RAM数据区                          |
> | **CODE**          | C:0000H~FFFFH                                       | 64K常规片内外ROM代码区                         |
> | **HCONST(ECODE)** | C:0000H~FFFFFFH                                     | 16MB扩展片外ROM常数区(对Dallas390可用作代码区) |
> | **BANK0~BANK31**  | B0:0000H~FFFFH<br/>:<br/>:<br/>B31:0000H~FFFFH<br/> | 分组代码区，最大可扩展32X64KB ROM              |
>
> 

