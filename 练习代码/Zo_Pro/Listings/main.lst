C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "onewire.h"
   3          #include "iic.h"
   4          #include "ds1302.h"
   5          #include "intrins.h"
   6          
   7          #define uchar unsigned char 
   8          #define uint unsigned int
   9          
  10          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
  11          unsigned char code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,
  12                                                                    0xff,0xbf,0x8e,0xc8,0xc1};
  13          // 数码管位
  14          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  15          
  16          unsigned char num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2
             -）
  17          unsigned char GN;  // 按键标志位
  18          bit f_2ms, f_50ms, f_500ms_smg, f_200ms_temperature;  // 2ms, 50ms, 500ms标志位
  19          unsigned int num_2ms_smg;  // 多少个2ms
  20          unsigned char temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  21          unsigned int temperature;  // 温度
  22          unsigned int num_2ms_temperature;  // 多少个2ms
  23          unsigned char ds1302_h, ds1302_m, ds1302_s;  // 
  24          unsigned char dat1 = 0x16,dat2 = 0x55,dat3 = 0x50;  // （16进制）ds1302写数据
  25          unsigned char dat[8];
  26          int set_ds1302_h = 23,set_ds1302_m = 59,set_ds1302_s = 45;  // 默认（24c02写数据）时间设置
  27          uchar set_ds1302_key_modele;  // 时间设置的按键模式
  28          bit f_set_time, f_key_long, is_key_set_time;
  29          uchar t_key;  // 按键按住时间
  30          uchar stat_led[8];
  31          
  32          unsigned char dis_model = 0;  // 0:显示温度（DS18B20）， 1:显示时钟
  33          // 超声波测距
  34          uint distance;
  35          // PCF8951
  36          unsigned char dat_rd1, dat_rd2;  // ADC读取数据
  37          float rd1_v;
  38          unsigned int smg_rd1_v;
  39          // 按键
  40          unsigned char stat_key;  // 按键按下次数
  41          unsigned int count_key_t;  // 10ms单位累计
  42          
  43          
  44          sbit S7 = P3^0;
  45          sbit S6 = P3^1;
  46          sbit S5 = P3^2;
  47          sbit S4 = P3^3;
  48          
  49          sbit L0 = P0^0;
  50          sbit L1 = P0^1;
  51          sbit L2 = P0^2;
  52          sbit L3 = P0^3;
  53          sbit L4 = P0^4;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 2   

  54          sbit L5 = P0^5;
  55          sbit L6 = P0^6;
  56          sbit L7 = P0^7;
  57          
  58          // =========================================== 代码开始 ======================================
  59          bit f_1s;  // 1s标志位
  60          
  61          unsigned int num_2ms = 0, num_s = 0, num_s_key = 0;  // 多少个2ms, 1s, 按键按下时间
  62          
  63          bit f_time = 1;  // 定时器0秒钟是否暂停
  64          unsigned char urdat;  // 串口接收数据
  65          
  66          unsigned int num_On_Off;  // 开关次数
  67          
  68          // =========================================== 代码结束 ======================================
  69          
  70          
  71          //=========================================普通延时函数(模板函数)=================================
  72          void Delay(uint t) {
  73   1              while( t -- );
  74   1              while( t -- );
  75   1      }
  76          //=======================================单个LED控制函数(模板函数)================================
  77          // 根据项目需要删减
  78          
  79          // ======================LED0====================
  80          void LED0_On() {
  81   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  82   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  83   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  84   1              temp_Led_P0 = P0;
  85   1              P2 &= 0x1f;
  86   1              
  87   1              stat_led[0] = 1;
  88   1      }
  89          void LED0_Off() {
  90   1              P0 = 0xff & temp_Led_P0;
  91   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  92   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  93   1              temp_Led_P0 = P0;
  94   1              P2 &= 0x1f;
  95   1              
  96   1              stat_led[0] = 0;
  97   1      }
  98          // ======================LED1====================
  99          void LED1_On() {
 100   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
 101   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 102   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
 103   1              temp_Led_P0 = P0;
 104   1              P2 &= 0x1f;
 105   1              
 106   1              stat_led[1] = 1;
 107   1      }
 108          void LED1_Off() {
 109   1              P0 = 0xff & temp_Led_P0;
 110   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 111   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
 112   1              temp_Led_P0 = P0;
 113   1              P2 &= 0x1f;
 114   1              
 115   1              stat_led[1] = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 3   

 116   1      }
 117          // ======================LED2====================
 118          void LED2_On() {
 119   1              P0 = 0xff & temp_Led_P0;
 120   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 121   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
 122   1              temp_Led_P0 = P0;
 123   1              P2 &= 0x1f;
 124   1      }
 125          void LED2_Off() {
 126   1              P0 = 0xff & temp_Led_P0;
 127   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 128   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
 129   1              temp_Led_P0 = P0;
 130   1              P2 &= 0x1f;
 131   1      }
 132          // ======================LED3====================
 133          void LED3_On() {
 134   1              P0 = 0xff & temp_Led_P0;
 135   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 136   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 137   1              temp_Led_P0 = P0;
 138   1              P2 &= 0x1f;
 139   1      }
 140          void LED3_Off() {
 141   1              P0 = 0xff & temp_Led_P0;
 142   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 143   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 144   1              temp_Led_P0 = P0;
 145   1              P2 &= 0x1f;
 146   1      }
 147          // ======================LED4====================
 148          void LED4_On() {
 149   1              P0 = 0xff & temp_Led_P0;
 150   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 151   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 152   1              temp_Led_P0 = P0;
 153   1              P2 &= 0x1f;
 154   1      }
 155          void LED4_Off() {
 156   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 157   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 158   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 159   1              temp_Led_P0 = P0;
 160   1              P2 &= 0x1f;
 161   1      }
 162          // ======================LED5====================
 163          void LED5_On() {
 164   1              P0 = 0xff & temp_Led_P0;
 165   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 166   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 167   1              temp_Led_P0 = P0;
 168   1              P2 &= 0x1f;
 169   1      }
 170          void LED5_Off() {
 171   1              P0 = 0xff & temp_Led_P0;
 172   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 173   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 174   1              temp_Led_P0 = P0;
 175   1              P2 &= 0x1f;
 176   1      }
 177          // ======================LED6====================
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 4   

 178          void LED6_On() {
 179   1              P0 = 0xff & temp_Led_P0;
 180   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 181   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 182   1              temp_Led_P0 = P0;
 183   1              P2 &= 0x1f;
 184   1              
 185   1              stat_led[6] = 1;
 186   1      }
 187          void LED6_Off() {
 188   1              P0 = 0xff & temp_Led_P0;
 189   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 190   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 191   1              temp_Led_P0 = P0;
 192   1              P2 &= 0x1f;
 193   1              
 194   1              stat_led[6] = 0;
 195   1      }
 196          // ======================LED7====================
 197          void LED7_On() {
 198   1              P0 = 0xff & temp_Led_P0;
 199   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 200   1              L7 = 0;  // 要将P0放在这两句代码之间，避免错乱
 201   1              temp_Led_P0 = P0;
 202   1              P2 &= 0x1f;
 203   1              
 204   1              stat_led[7] = 1;
 205   1      }
 206          void LED7_Off() {
 207   1              P0 = 0xff & temp_Led_P0;
 208   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 209   1              L7 = 1;  // 要将P0放在这两句代码之间，避免错乱
 210   1              temp_Led_P0 = P0;
 211   1              P2 &= 0x1f;
 212   1              
 213   1              stat_led[7] = 0;
 214   1      }
 215          //=========================================数码管显示==============================================
 216          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 217          {
 218   1              char i;
 219   1              P0 = 0xff;
 220   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 221   1              P0 = type2[i];
 222   1              P2 &= 0x1f;
 223   1              switch(i)//数码管位选
 224   1              {
 225   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 226   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 227   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 228   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 229   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 230   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 231   2                                                                              if(dis_model == 1 || dis_model == 4)  // 根据需要的条件
 232   2                                                                              {
 233   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 234   3                                                                              }
 235   2                                                                              else
 236   2                                                                                      P0 = type1[n6];
 237   2                                                                                                        P2 &= 0x1f;break;
 238   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 239   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 5   

 240   2              }
 241   1              if(++i==8)
 242   1                      i = 0;
 243   1      }
 244          //============================================独立按键============================================
 245          /***************************************************
 246          写法一：
 247          有按键被按下，GN标记，后面根据需要功能进行操作
 248          ***************************************************/
 249          void Delay_Keys(uint t)
 250          {
 251   1              while(t--);
 252   1      }
 253          uchar Scan_Keys_Alone()
 254          {
 255   1              char d;
 256   1              d = (~P3) & 0x0f;
 257   1              if(d == 0) return 0;
 258   1              Delay_Keys(100);
 259   1              if(d == 0) return 0;
 260   1              Delay_Keys(100);
 261   1              return d;
 262   1      }
 263          void Change_Keys_Alone()
 264          {
 265   1              switch(Scan_Keys_Alone())
 266   1              {
 267   2                      case 8:GN = 1;break;//S4
 268   2                      case 4:GN = 2;break;//S5
 269   2                      case 2:GN = 3;break;//S6
 270   2                      case 1:GN = 4;break;//S7
 271   2                      case 0:GN = 0;break;
 272   2              }
 273   1      }
 274          
 275          /***************************************************
 276          写法二：
 277          有按键被按下，按下是一种状态，松开是另一种状态
 278          （如：按下时某个灯亮，松开时灯灭）
 279          ***************************************************/
 280          //void ScanKeys_Alone() 
 281          //{
 282          //      if (S7 == 0) {
 283          //              Delay_Keys(100);
 284          //              if (S7 == 0) {
 285          //                      // =========================================== 代码开始 ======================================
 286          //                      
 287          //                      // =========================================== 代码结束 ======================================
 288          //                      while(S7 == 0);
 289          //                      // =========================================== 代码开始 ======================================
 290          
 291          //                      // =========================================== 代码结束 ======================================
 292          //              }
 293          //      }
 294          //      
 295          //      if (S6 == 0) {
 296          //              Delay_Keys(100);
 297          //              if (S6 == 0) {
 298          //                      // =========================================== 代码开始 ======================================
 299          //                      
 300          //                      // =========================================== 代码结束 ======================================
 301          //                      while(S6 == 0);
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 6   

 302          //                      // =========================================== 代码开始 ======================================
 303          
 304          //                      // =========================================== 代码结束 ======================================
 305          //              }
 306          //      }
 307          //      
 308          //      if (S5 == 0) {
 309          //              Delay_Keys(100);
 310          //              if (S5 == 0) {
 311          //                      // =========================================== 代码开始 ======================================
 312          
 313          //                      // =========================================== 代码结束 ======================================
 314          //                      while(S5 == 0);
 315          //                      // =========================================== 代码开始 ======================================
 316          
 317          //                      // =========================================== 代码结束 ======================================
 318          //              }
 319          //      }
 320          
 321          //      if (S4 == 0) {
 322          //              Delay_Keys(100);
 323          //              if (S4 == 0) {
 324          //                      // =========================================== 代码开始 ======================================
 325          
 326          //                      // =========================================== 代码结束 ======================================
 327          //                      while(S4 == 0);
 328          //                      // =========================================== 代码开始 ======================================
 329          
 330          //                      // =========================================== 代码结束 ======================================
 331          //              }
 332          //      }
 333          //}
 334          
 335          // ================= 代码结束 =============
 336          
 337          //============================================矩阵按键============================================
 338          sfr P4 = 0xc0;
 339          sbit P44 = P4^4;
 340          sbit P42 = P4^2;
 341          
 342          uchar Scan_Keys()
 343          {
 344   1              char H,L;
 345   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 346   1              if(H == 0) return 0;
 347   1              Delay_Keys(100);
 348   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 349   1              if(H == 0) return 0;
 350   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 351   1              if(P44 == 0) L |= 0x80;
 352   1              if(P42 == 0) L |= 0x40;
 353   1              return (H+L);
 354   1      }
 355          
 356          void Change_Keys()
 357          {
 358   1              switch(Scan_Keys())
 359   1              {
 360   2                      case 0x88:GN = 4;break;  // S4
 361   2                      case 0x84:GN = 5;break;  // S5
 362   2                      case 0x82:GN = 6;break;  // S6
 363   2                      case 0x81:GN = 7;break;  // S7
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 7   

 364   2                      case 0x48:GN = 8;break;  // S8
 365   2                      case 0x44:GN = 9;break;  // S9
 366   2                      case 0x42:GN = 10;break;  // S10
 367   2                      case 0x41:GN = 11;break;  // S11
 368   2                      case 0x28:GN = 12;break;  // S12
 369   2                      case 0x24:GN = 13;break;  // S13
 370   2                      case 0x22:GN = 14;break;  // S14
 371   2                      case 0x21:GN = 15;break;  // S15
 372   2                      case 0x18:GN = 16;break;  // S16
 373   2                      case 0x14:GN = 17;break;  // S17
 374   2                      case 0x12:GN = 18;break;  // S18
 375   2                      case 0x11:GN = 19;break;  // S19
 376   2                      case 0:GN = 0;break;
 377   2              }
 378   1      }
 379          //============================================24C02初始化============================================
 380          void Write_24C02_Byte(unsigned char addr,unsigned char dat)
 381          {
 382   1              IIC_Start();
 383   1              IIC_SendByte(0xa0);
 384   1              IIC_WaitAck();
 385   1              IIC_SendByte(addr);
 386   1              IIC_WaitAck();
 387   1              IIC_SendByte(dat);
 388   1              IIC_WaitAck();
 389   1              IIC_Stop(); 
 390   1      }
 391          
 392          unsigned char Read_24C02_Byte(unsigned char addr)
 393          {
 394   1              unsigned char tmp;
 395   1              IIC_Start();
 396   1              IIC_SendByte(0xa0);
 397   1              IIC_WaitAck();
 398   1              IIC_SendByte(addr);
 399   1              IIC_WaitAck();
 400   1              
 401   1              IIC_Start();
 402   1              IIC_SendByte(0xa1);
 403   1              IIC_WaitAck();
 404   1              tmp = IIC_RecByte(); 
 405   1              IIC_SendAck(1);
 406   1              IIC_Stop();
 407   1              
 408   1              return tmp;
 409   1      }
 410          
 411          void Write_24C02_Page(unsigned char addr, unsigned char *dat, unsigned char len)
 412          {
 413   1              unsigned char i;
 414   1              IIC_Start();
 415   1              IIC_SendByte(0xa0);
 416   1              IIC_WaitAck();
 417   1              IIC_SendByte(addr);
 418   1              IIC_WaitAck();
 419   1              
 420   1              for (i = 0; i < len; i ++ ) {
 421   2                      IIC_SendByte(dat[i]);
 422   2                      IIC_WaitAck();
 423   2              }
 424   1              IIC_Stop(); 
 425   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 8   

 426          
 427          void Read_24C02_Page(unsigned char addr, unsigned char *dat, unsigned char len)
 428          {
 429   1              unsigned char i;
 430   1              IIC_Start();
 431   1              IIC_SendByte(0xa0);
 432   1              IIC_WaitAck();
 433   1              IIC_SendByte(addr);
 434   1              IIC_WaitAck();
 435   1              
 436   1              IIC_Start();
 437   1              IIC_SendByte(0xa1);
 438   1              IIC_WaitAck();
 439   1              for (i = 0; i < len - 1; i ++ ) {
 440   2                      dat[i] = IIC_RecByte();
 441   2                      IIC_SendAck(0);
 442   2              }
 443   1              dat[len - 1] = IIC_RecByte();
 444   1              IIC_SendAck(1);
 445   1              IIC_Stop();
 446   1      }
 447          //============================================DS18B20初始化============================================
 448          void Init_18b20()
 449          {
 450   1              init_ds18b20();
 451   1              Write_DS18B20(0xcc);
 452   1              Write_DS18B20(0x4e);
 453   1              Write_DS18B20(0x00);
 454   1              Write_DS18B20(0x00);
 455   1              Write_DS18B20(0x7f);
 456   1      }
 457          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 458                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 459                                                                           // 和一位小数可用unsigned char.
 460          {
 461   1              unsigned char H,L;
 462   1              init_ds18b20();
 463   1              Write_DS18B20(0xcc);
 464   1              Write_DS18B20(0xbe);
 465   1              L = Read_DS18B20();
 466   1              H = Read_DS18B20();
 467   1              
 468   1              init_ds18b20();
 469   1              Write_DS18B20(0xcc);
 470   1              Write_DS18B20(0x44);
 471   1              
 472   1              //1.保留整数--23
 473   1              //temp = (H<<4) + (L>>4);
 474   1              
 475   1              //2.保留1位小数--23.4
 476   1              //temp = ((H<<8) + L)*5/8;
 477   1              
 478   1              //3.保留2位小数--23.45
 479   1              return ((H<<8)+L)*25/4;  // (50/8)
 480   1      }
 481          //============================================Ds1302初始化============================================
 482          void My_Write_Ds1302()
 483          {
 484   1              Write_Ds1302_Byte(0x8e,0x00);
 485   1              Write_Ds1302_Byte(0x84,dat1);//时
 486   1              Write_Ds1302_Byte(0x82,dat2);//分
 487   1              Write_Ds1302_Byte(0x80,dat3);//秒
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 9   

 488   1      }
 489          void My_Read_Ds1302()
 490          {
 491   1              ds1302_h = Read_Ds1302_Byte(0x85);//时
 492   1              ds1302_h = (ds1302_h >> 4) * 10 + (ds1302_h & 0x0f);
 493   1              ds1302_m = Read_Ds1302_Byte(0x83);//分
 494   1              ds1302_m = (ds1302_m >> 4) * 10 + (ds1302_m & 0x0f);
 495   1              ds1302_s = Read_Ds1302_Byte(0x81);//秒
 496   1              ds1302_s = (ds1302_s >> 4) * 10 + (ds1302_s & 0x0f);
 497   1      }
 498          //============================================PCF8951部分=======================================
 499          // A/D读取光敏电阻(RD1)或电压采集(RB2)数值
 500          unsigned char Read_ADC(unsigned char n)
 501          {
 502   1              unsigned char temp;
 503   1              IIC_Start();
 504   1              IIC_SendByte(0x90);
 505   1              IIC_WaitAck();
 506   1              if (n == 1)
 507   1              {
 508   2                      IIC_SendByte(0x01);//读取光敏电阻RB1
 509   2              }
 510   1              else if (n == 2)
 511   1              {
 512   2                      IIC_SendByte(0x03);//读取滑动变阻器RB2
 513   2              }
 514   1              IIC_WaitAck();
 515   1              IIC_Stop();
 516   1              
 517   1              Delay_Keys(500);//while(500--);延时等待
 518   1              
 519   1              IIC_Start();
 520   1              IIC_SendByte(0x91);
 521   1              IIC_WaitAck();
 522   1              temp = IIC_RecByte();//读取
 523   1              IIC_SendAck(1); 
 524   1              IIC_Stop();
 525   1              return temp;
 526   1      }
 527          
 528          //Read_ADC(1) -> (0~255) -> *2 -> (0~500)V
 529          
 530          // D/A写电压
 531          void Xie_ADC(unsigned char dat)
 532          {
 533   1              IIC_Start();
 534   1              IIC_SendByte(0x90);
 535   1          IIC_WaitAck();
 536   1          IIC_SendByte(0x40);
 537   1          IIC_WaitAck();
 538   1          IIC_SendByte(dat);
 539   1          IIC_WaitAck();
 540   1          IIC_Stop();
 541   1      }
 542          //============================================定时器T0初始化=======================================
 543          uchar count = 0;
 544          uchar pwm_dut = 0;//占空比
 545          void Init_T0()
 546          {
 547   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 548   1              TH0 = (65536 - 2000) / 256;
 549   1              TL0 = (65536 - 2000) % 256;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 10  

 550   1              
 551   1              EA = 1;
 552   1              ET0 = 1;
 553   1              TR0 = 1;
 554   1      }
 555          //============================================定时器T1初始化=======================================
 556          void Init_T1()
 557          {
 558   1              TMOD = (TMOD & 0x0f) | 0x00;//定时
 559   1      //      TH1 = (65536 - 12) / 256;
 560   1      //      TL1 = (65536 - 12) % 256;
 561   1              
 562   1      //      EA = 1;
 563   1      //      ET1 = 1;
 564   1      //      TR1 = 1;
 565   1      }
 566          //============================================超声波测距=======================================
 567          sbit TX = P1 ^ 0;
 568          sbit RX = P1 ^ 1;
 569          
 570          //======发射超声波信号====
 571          void send_Wave()
 572          {
 573   1              unsigned char i = 8;
 574   1              // 12MHZ的12分频，间隔定时12us;
 575   1              TR1 = 0;
 576   1              TH1 = 0xff;
 577   1              TL1 = 0xf4;
 578   1              TF1 = 0;
 579   1              TR1 = 1;
 580   1              // 发射8个40khz的超声波信号
 581   1              while (i -- ) {
 582   2                      TX = 0;
 583   2                      while (!TF1);
 584   2                      TF1 = 0;
 585   2                      TX = 1;
 586   2                      while (!TF1);
 587   2                      TF1 = 0;
 588   2              }
 589   1      }
 590          
 591          void Get_Distance() {
 592   1              // 先发射8个40khz的超声波信号
 593   1              send_Wave();
 594   1              
 595   1              TR1 = 0;
 596   1              TL1 = 0x00;
 597   1              TH1 = 0xe0;
 598   1              TF1 = 0;
 599   1              TR1 = 1;
 600   1              while (RX && !TF1);
 601   1              TR1 = 0;
 602   1              
 603   1              if (TF1 == 1)
 604   1              {
 605   2                      TF1 = 0;
 606   2                      distance = 999;
 607   2              }
 608   1              // 超声波速度约344m/s
 609   1              // 距离 L = （344m/s*t）/2=172m/s*t
 610   1              // t取微秒，即：L = 0.0172cm/us*t
 611   1              else
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 11  

 612   1                      distance = (((TH1 & 0x1f) << 8) | TL1) * 0.0172;
 613   1      }
 614          
 615          uchar Get_Distance_2()
 616          {
 617   1              uchar temp = 16;
 618   1              TX = 0;
 619   1              TR1 = 1;
 620   1              // 引脚发送40Khz方波信号
 621   1              while (temp--) // 每隔12us发8个方波
 622   1              {
 623   2                      while (!TF1)
 624   2                              ;
 625   2                      TX ^= 1; // if(TX==1) { Delay20us();}//可以不用
 626   2                      TH1 = (65536 - 12) / 256;
 627   2                      TL1 = (65536 - 12) % 256;
 628   2                      TF1 = 0;
 629   2              }
 630   1              //      while(temp--)
 631   1              //      {
 632   1              //              while(!TF0);
 633   1              //              TX ^= 1;//TX = ~TX;
 634   1              //              TH0=(65536-12)/256;
 635   1              //              TL0=(65536-12)%256;
 636   1              //              TF0 = 0;//TF0必须要先赋值(益处中断，自动置1)在清零
 637   1              //      }
 638   1              TR1 = 0;
 639   1              TL1 = 0;
 640   1              TH1 = 0;
 641   1              TR1 = 1;
 642   1              while (RX && !TF1)
 643   1                      ;
 644   1              TR1 = 0;
 645   1      
 646   1              if (TF1 == 1)
 647   1              {
 648   2                      TF1 = 0;
 649   2                      return 999;
 650   2              }
 651   1              else
 652   1                      return ((TH1 << 8) + TL1) * 0.017;
 653   1      }
 654          //============================================串口初始化============================================
 655          #include "intrins.h"
 656          #include "string.h"
 657          
 658          sfr AUXR = 0x8e;  // 辅助寄存器
 659          sfr T2H=0xd6;  // 定时器2高8位
 660          sfr T2L=0xd7;  // 定时器2低8位
 661          #define BAUD         9600
 662          //#define SYSTEMCLOCK  11059200L
 663          #define SYSTEMCLOCK  12000000L
 664          uchar command = 0x00;
 665          void Init_Uart()
 666          {
 667   1              // ===================T1实现===================
 668   1      //      TMOD = (TMOD & 0x0f) | 0x00;
 669   1      //      
 670   1      //      TL1 = (65535-(SYSTEMCLOCK / 4 / BAUD));
 671   1      //      TH1 = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 672   1      //      
 673   1      ////    ET1 = 0;                    //禁止定时器1中断
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 12  

 674   1      //      TR1 = 1;                    //启动定时器1
 675   1      //      
 676   1      //      SCON = 0x50;
 677   1      //      AUXR = 0x40;
 678   1              // ===================T1实现===================
 679   1              
 680   1              // ===================T2实现===================
 681   1              SCON = 0x50;  // 8位数据,可变波特率
 682   1          AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
 683   1          AUXR |= 0x04; // 定时器时钟1T模式
 684   1              
 685   1              T2L = (65535-(SYSTEMCLOCK / 4 / BAUD));
 686   1              T2H = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 687   1              
 688   1      //      ET1 = 0;                    //禁止定时器1中断
 689   1      //      TR1 = 1;                    //启动定时器1
 690   1      //      SCON = 0x50;
 691   1      //      AUXR = 0x40;
 692   1              
 693   1              AUXR |= 0x10; // 定时器2开始计时
 694   1              // ===================T2实现===================
 695   1              
 696   1              ES = 1;
 697   1              EA = 1;
 698   1              
 699   1      //      SCON = 0x50;            //8位数据,可变波特率
 700   1      //      AUXR &= 0xBF;           //定时器1时钟为Fosc/12,即12T
 701   1      //      AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 702   1      //      TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 703   1      //      TL1 = 0xE8;             //设定定时初值
 704   1      //      TH1 = 0xFF;             //设定定时初值
 705   1      //      ET1 = 0;                //禁止定时器1中断
 706   1      
 707   1      //      ES = 1;
 708   1      //      EA = 1;  
 709   1      //      TR1 = 1;                //启动定时器1
 710   1      }
 711          // 发送一个字节数据
 712          void Send_Byte(unsigned char dat)
 713          {
 714   1              SBUF = dat;
 715   1              while(TI == 0);
 716   1              TI = 0;
 717   1      }
 718          //发送一串字符串
 719          void Send_String(unsigned char* str)
 720          {
 721   1        
 722   1        while(*str != '\0')
 723   1        {
 724   2          Send_Byte(*(str++));
 725   2        }
 726   1      }
 727          //==========================================系统初始化=============================================
 728          void Init_Sys()
 729          {
 730   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 731   1              P0 = 0xff;
 732   1              P2 &= 0x1f;
 733   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 734   1              P0 = 0x00;
 735   1              P2 &= 0x1f;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 13  

 736   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 737   1              P0 = 0xff;
 738   1              P2 &= 0x1f;
 739   1              P2 = (P2 & 0x1f) | 0xe0;
 740   1              P0 = 0xff;
 741   1              
 742   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 743   1      }
 744          
 745          void LED_control() {
 746   1              // ================= 测试开始 =============
 747   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 748   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 749   1      //      P2 &= 0x1f;
 750   1              // ================= 测试结束 =============
 751   1              
 752   1              // =========================================== 代码开始 ======================================
 753   1              
 754   1              // =========================================== 代码结束 ======================================
 755   1      }
 756          
 757          void main()
 758          {
 759   1              Init_Sys();
 760   1              
 761   1              num_On_Off = Read_24C02_Byte(0x00);
 762   1              
 763   1              Init_T1();
 764   1      //      TMOD = (TMOD & 0x0f) | 0x00;//定时
 765   1              Init_T0();
 766   1              Init_18b20();
 767   1      //      My_Write_Ds1302();
 768   1      
 769   1      //      num_On_Off = Read_24C02_Byte(0x00);
 770   1      //      num_On_Off ++ ;
 771   1      //      Write_24C02_Byte(0x00, num_On_Off);
 772   1      
 773   1              Read_24C02_Page(0x01, dat, 3);
 774   1              
 775   1              
 776   1      //      dat2 = (dat[2] / 10) << 4 | (dat[2] % 10);
 777   1              dat1 = dat[0] /10*16 + dat[0] % 10;
 778   1              dat2 = dat[1] /10*16 + dat[1] % 10;
 779   1              dat3 = dat[2] /10*16 + dat[2] % 10;
 780   1              
 781   1              My_Write_Ds1302();
 782   1              
 783   1              Init_Uart();
 784   1      //      Send_Byte(dat[2] /10*16 + dat[2] % 10);
 785   1      //      Send_Byte(0xA0);
 786   1              Send_String("I am OK\r\n");
 787   1              
 788   1              while(1)
 789   1              {
 790   2      //              LED_control();
 791   2              if(f_2ms == 1)
 792   2              {
 793   3                  f_2ms = 0;                  
 794   3                              LED_control();  // xxx
 795   3      //                      Write_24C02_Byte(0x02,ds1302_s);        
 796   3      
 797   3                              distance = Get_Distance_2();  // 超声波测距             
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 14  

 798   3                              // =======================按键开始========================
 799   3                              /*根据需要选择对应的按键类型*/
 800   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 801   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 802   3                              Change_Keys();        // 3.矩阵按键扫描
 803   3                              if (GN == 13) {  // S13
 804   4                                      // =========================================== 代码开始 ======================================
 805   4                                      LED1_On();
 806   4                                      // =========================================== 代码结束 ======================================
 807   4                                      while(Scan_Keys());
 808   4                                      // =========================================== 代码开始 ======================================
 809   4                                      LED1_Off();
 810   4                                      dis_model ++ ;
 811   4                                      if (dis_model > 5) dis_model = 0;
 812   4                                      // =========================================== 代码结束 ======================================
 813   4                              }
 814   3                              
 815   3                              if (GN == 12) {  // S12 num_s 暂停
 816   4                                      // =========================================== 代码开始 ======================================
 817   4                                      LED2_On();
 818   4                                      // =========================================== 代码结束 ======================================
 819   4                                      while(Scan_Keys());
 820   4                                      // =========================================== 代码开始 ======================================
 821   4                                      LED2_Off();
 822   4                                      f_time = ~f_time;
 823   4                                      // =========================================== 代码结束 ======================================
 824   4                              }
 825   3                              
 826   3                              if (GN == 5) {  // S12 num_s 暂停
 827   4                                      // =========================================== 代码开始 ======================================
 828   4                                      LED0_On();
 829   4                                      
 830   4      //                              count_key_t =0 ;  // 时间计数清0
 831   4                                      
 832   4                                      // =========================================== 代码结束 ======================================
 833   4                                      while(Scan_Keys());
 834   4                                      // =========================================== 代码开始 ======================================
 835   4                                      LED0_Off();
 836   4                                      stat_key ++ ;  // 按键按下次数
 837   4                                      // =========================================== 代码结束 ======================================
 838   4                              }
 839   3                              if (count_key_t > 500) {
 840   4                                      // 单击
 841   4                                      if (stat_key == 1) {
 842   5                                              if (stat_led[6] == 0) LED6_On();
 843   5                                              else LED6_Off();
 844   5                                      }
 845   4                                      // 双击
 846   4                                      if (stat_key == 2) {
 847   5                                              if (stat_led[7] == 0) LED7_On();
 848   5                                              else LED7_Off();
 849   5                                      }
 850   4                                      count_key_t = 0;
 851   4                                      stat_key = 0;
 852   4                              }
 853   3                              
 854   3                              if (GN == 8) {  // S8
 855   4                                      // =========================================== 代码开始 ======================================
 856   4                                      LED5_On();
 857   4                                      // =========================================== 代码结束 ======================================
 858   4                                      while(Scan_Keys());
 859   4                                      // =========================================== 代码开始 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 15  

 860   4                                      LED5_Off();
 861   4                                      
 862   4                                      // 时间加
 863   4                                      if (set_ds1302_key_modele == 1) {  // 小时设置
 864   5                                              set_ds1302_h ++ ;
 865   5                                              if (set_ds1302_h > 23) set_ds1302_h = 0;
 866   5                                      }
 867   4                                      else if (set_ds1302_key_modele == 2) {  // 分钟设置
 868   5                                              set_ds1302_m ++ ;
 869   5                                              if (set_ds1302_m > 59) set_ds1302_m = 0;
 870   5                                      }
 871   4                                      else if (set_ds1302_key_modele == 3) {  // 秒设置
 872   5                                              set_ds1302_s ++ ;
 873   5                                              if (set_ds1302_s > 59) set_ds1302_s = 0;
 874   5                                      }
 875   4                                      
 876   4                                      // =========================================== 代码结束 ======================================
 877   4                              }
 878   3                              
 879   3                              if (GN == 9) {  // S9
 880   4                                      // =========================================== 代码开始 ======================================
 881   4                                      LED5_On();
 882   4                                      // =========================================== 代码结束 ======================================
 883   4                                      while(Scan_Keys());
 884   4                                      // =========================================== 代码开始 ======================================
 885   4                                      LED5_Off();
 886   4                                      
 887   4                                      // 时间减
 888   4                                      if (set_ds1302_key_modele == 1) {  // 小时设置
 889   5                                              set_ds1302_h -- ;
 890   5                                              if (set_ds1302_h < 0) set_ds1302_h = 23;
 891   5                                      }
 892   4                                      else if (set_ds1302_key_modele == 2) {  // 分钟设置
 893   5                                              set_ds1302_m -- ;
 894   5                                              if (set_ds1302_m < 0) set_ds1302_m = 59;
 895   5                                      }
 896   4                                      else if (set_ds1302_key_modele == 3) {  // 秒设置
 897   5                                              set_ds1302_s -- ;
 898   5                                              if (set_ds1302_s < 0) set_ds1302_s = 59;
 899   5                                      }
 900   4                                      // =========================================== 代码结束 ======================================
 901   4                              }
 902   3      
 903   3                              if (GN == 4) {  // S4
 904   4                                      // =========================================== 代码开始 ======================================
 905   4                                      LED3_On();
 906   4                                      is_key_set_time = 1;  // 按键按下未松开
 907   4                                      
 908   4                                      
 909   4                                      // =========================================== 代码结束 ======================================
 910   4                                      while(Scan_Keys());
 911   4                                      // =========================================== 代码开始 ======================================
 912   4                                      LED3_Off();
 913   4                                      LED4_Off();
 914   4                                      is_key_set_time = 0;  // 按键按下松开
 915   4                                      num_s_key = 0;
 916   4                                      
 917   4                                      if (f_key_long) {  // 长按转换模式
 918   5                                              set_ds1302_key_modele ++ ;
 919   5                                              f_key_long = 0;
 920   5                                      }
 921   4                                      
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 16  

 922   4                                      
 923   4      //                              if (set_ds1302_key_modele == 1) {  // 小时设置
 924   4      //                                      set_ds1302_h = 23;
 925   4      //                              }
 926   4      //                              else if (set_ds1302_key_modele == 2) {  // 分钟设置
 927   4      //                                      set_ds1302_m = 29;
 928   4      //                              }
 929   4      //                              else if (set_ds1302_key_modele == 3) {  // 秒设置
 930   4      //                                      set_ds1302_s = 45;
 931   4      //                              }
 932   4                                      if (set_ds1302_key_modele == 4) {  // 确认
 933   5                                              if (dis_model == 2) {
 934   6                                                      dat[0] = set_ds1302_h;
 935   6                                                      dat[1] = set_ds1302_m;
 936   6                                                      dat[2] = set_ds1302_s;
 937   6                                                      Write_24C02_Page(0x01, dat, 3);
 938   6                                                      
 939   6                                                      dat1 = dat[0] /10*16 + dat[0] % 10;
 940   6                                                      dat2 = dat[1] /10*16 + dat[1] % 10;
 941   6                                                      dat3 = dat[2] /10*16 + dat[2] % 10;
 942   6      
 943   6                                                      My_Write_Ds1302();
 944   6                                              }
 945   5                                              set_ds1302_key_modele = 0;
 946   5                                      }
 947   4                                      // =========================================== 代码结束 ======================================
 948   4                              }
 949   3                              /*根据需要添加对应按键*/
 950   3                              // =======================按键结束========================
 951   3                              
 952   3                              // =======================串口调试开始====================
 953   3                              if(command != 0x00)
 954   3                              {
 955   4                                      switch(command & 0xf0)
 956   4                                      {
 957   5                                              case 0xa0:
 958   5                                                      P0 = temp_Led_P0;
 959   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 960   5                                                      P0 = (P0 | 0x0f) & ((~command) | 0xf0);
 961   5                                                      temp_Led_P0 = P0;
 962   5                                                      P2 &= 0x1f;
 963   5                                                      command = 0x00;
 964   5                                              break;
 965   5                                              case 0xb0:
 966   5                                                      P0 = temp_Led_P0;
 967   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 968   5                                                      P0 = (P0 | 0xf0) & (((~command) << 4) | 0x0f);
 969   5                                                      temp_Led_P0 = P0;
 970   5                                                      P2 &= 0x1f;
 971   5                                                      command = 0x00;
 972   5                                              break;
 973   5                                              case 0xc0:
 974   5                                                      Send_String("system is running...!\r\n");
 975   5                                                      command = 0x00;
 976   5                                              break;
 977   5                                      }
 978   4                              }
 979   3                              // =======================串口调试结束====================              
 980   3                              
 981   3                              // =========================================== 代码开始 ======================================                  
 982   3                              // =======================1.温度读取开始========================
 983   3                              if (f_200ms_temperature) {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 17  

 984   4                                      f_200ms_temperature = 0;
 985   4                                      
 986   4                                      My_Read_Ds1302();
 987   4                              }
 988   3                              temperature = Read_Temperature();
 989   3      //                      num1=10;num2=10;num3=10;num4=10;
 990   3      //                      num5=temperature/1000;num6=temperature/100%10;
 991   3      //                      num7=temperature/10%10;num8=temperature%10;
 992   3                              // =======================1.温度读取结束========================
 993   3                              
 994   3                              dat[0] = ds1302_h;
 995   3                              dat[1] = ds1302_m;
 996   3                              dat[2] = ds1302_s;
 997   3                              Write_24C02_Page(0x01, dat, 3);
 998   3                              
 999   3                              if (dis_model == 0) {  // 时间显示
1000   4                                      num1=ds1302_h/10;num2=ds1302_h%10;num3=11;
1001   4                                      num4=ds1302_m/10;num5=ds1302_m%10;num6=11;
1002   4                                      num7=ds1302_s/10;num8=ds1302_s%10;
1003   4                              }
1004   3                              else if (dis_model == 1) {  // 温度显示
1005   4                                      num1=dis_model;num2=10;num3=10;num4=10;
1006   4                                      num5=temperature/1000;num6=temperature/100%10;
1007   4                                      num7=temperature/10%10;num8=temperature%10;
1008   4                              }
1009   3                              else if (dis_model == 2) {  // 时间设置
1010   4      //                              num_On_Off = Read_24C02_Byte(0x00);
1011   4      //                              num_On_Off ++ ;
1012   4      //                              Write_24C02_Byte(0x00, num_On_Off);
1013   4                                      f_set_time = 1;  // 时间设置标志
1014   4                                      
1015   4                                      if (set_ds1302_key_modele == 1) {
1016   5                                              if (f_500ms_smg) num1 = 10, num2 = 10;
1017   5                                              else num1 = set_ds1302_h / 10, num2 = set_ds1302_h % 10;
1018   5                                      }
1019   4                                      else num1 = set_ds1302_h / 10, num2 = set_ds1302_h % 10;
1020   4                                      
1021   4                                      if (set_ds1302_key_modele == 2) {
1022   5                                              if (f_500ms_smg) num4 = 10, num5 = 10;
1023   5                                              else num4 = set_ds1302_m / 10, num5 = set_ds1302_m % 10;
1024   5                                      }
1025   4                                      else num4 = set_ds1302_m / 10, num5 = set_ds1302_m % 10;
1026   4                                      
1027   4                                      if (set_ds1302_key_modele == 3) {
1028   5                                              if (f_500ms_smg) num7 = 10, num8 = 10;
1029   5                                              else num7 = set_ds1302_s / 10, num8 = set_ds1302_s % 10;
1030   5                                      }
1031   4                                      else num7 = set_ds1302_s / 10, num8 = set_ds1302_s % 10;
1032   4                                      
1033   4                                      num3 = 11; 
1034   4                                      num6 = 11;
1035   4                                      
1036   4                              }
1037   3                              else if (dis_model == 3) {
1038   4                                      num1 = dis_model;num2 = 10; num3 = 10; num4 = 10;
1039   4                                      num5= 10;
1040   4                                      num6=distance / 100; num7=distance % 100 / 10; num8=distance % 10;
1041   4                              }
1042   3                              else if (dis_model ==4) {
1043   4                                      dat_rd1 = Read_ADC(1);
1044   4                                      rd1_v = dat_rd1*5/255;
1045   4                                      smg_rd1_v = rd1_v * 100;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 18  

1046   4                                      num1=dis_model;
1047   4                                      num2=dat_rd1 / 100;num3=(dat_rd1 % 100) / 10;num4 = dat_rd1 % 10;
1048   4                                      num5=11;
1049   4                                      num6=smg_rd1_v / 100;num7=(smg_rd1_v % 100) / 10;num8=smg_rd1_v % 10;
1050   4                              }
1051   3                              else if (dis_model == 5) {
1052   4                                      num1 = dis_model;num2 = 10; num3 = 10; num4 = 10;
1053   4                                      num5= 10;
1054   4                                      num6=11; num7=stat_key / 10; num8=stat_key%10;
1055   4                              }
1056   3                              // =========================================== 代码结束 ======================================
1057   3              }
1058   2          }
1059   1      }
1060          
1061          void Service_T0() interrupt 1
1062          {
1063   1              TH0 = (65536 - 2000) / 256;
1064   1              TL0 = (65536 - 2000) % 256;
1065   1              
1066   1              f_2ms = 1;
1067   1              
1068   1              /***************************************************
1069   1              与时间相关的变量的更新放在里面
1070   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
1071   1              ***************************************************/
1072   1              // =========================================== 代码开始 ======================================
1073   1              num_2ms ++ ;
1074   1              num_2ms_temperature ++ ;
1075   1              if (num_2ms_temperature == 100) {
1076   2                      f_200ms_temperature = 1;
1077   2                      num_2ms_temperature = 0;
1078   2              }
1079   1              
1080   1              if (num_2ms == 500) {
1081   2                      f_1s = 1;
1082   2                      num_2ms = 0;
1083   2              }
1084   1              
1085   1              if (f_1s == 1) {
1086   2                      f_1s = 0;
1087   2                      
1088   2                      if (f_time) num_s ++ ;
1089   2                      
1090   2                      // 按键长按
1091   2                      if (is_key_set_time && dis_model == 2) {
1092   3                              num_s_key ++ ;
1093   3      //                      t_key = 0;
1094   3                              if (num_s_key == 2) {
1095   4                                      LED4_On();
1096   4                                      f_key_long = 1;
1097   4                              }
1098   3                      }                       
1099   2                              
1100   2                      
1101   2                      if (num_s == 9) 
1102   2                              num_s = 0;
1103   2                      
1104   2              }
1105   1              
1106   1              // 数码管闪烁
1107   1              num_2ms_smg ++ ;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 18:40:40 PAGE 19  

1108   1              if (num_2ms_smg == 250) {
1109   2                      num_2ms_smg = 0;
1110   2                      f_500ms_smg = ~f_500ms_smg;
1111   2              }
1112   1              
1113   1              // 按键双击
1114   1              if (stat_key != 0) {
1115   2                      count_key_t ++ ;
1116   2              }
1117   1              // =========================================== 代码结束 ======================================
1118   1              
1119   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
1120   1      }
1121          
1122          void ServiceUart() interrupt 4
1123          {
1124   1              if(RI == 1)
1125   1              {
1126   2                      RI = 0;//人工清零
1127   2                      urdat = SBUF;
1128   2                      command = SBUF;
1129   2      //              Send_Byte(urdat + 1);
1130   2      //              send_byte(0x5a);
1131   2      //              send_byte(0xa5);
1132   2              }
1133   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3245    ----
   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     72      33
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
