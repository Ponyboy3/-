C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "onewire.h"
   3          #include "iic.h"
   4          #include "ds1302.h"
   5          #include "intrins.h"
   6          
   7          #define uchar unsigned char 
   8          #define uint unsigned int
   9          
  10          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
  11          unsigned char code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,
  12                                                                    0xff,0xbf,0x8e,0xc8,0xc1};
  13          // 数码管位
  14          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  15          
  16          unsigned char num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2
             -）
  17          unsigned char GN;  // 按键标志位
  18          bit f_2ms, f_50ms, f_500ms_smg;  // 2ms, 50ms, 500ms标志位
  19          unsigned int num_2ms_smg;  // 多少个2ms
  20          unsigned char temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  21          unsigned char ds1302_h, ds1302_m, ds1302_s;  // ds1302数据
  22          bit f_200ms_ds1302;
  23          unsigned int num_2ms_ds1302;  // // 多少个2ms
  24          bit f_key_long, is_key_set_time;
  25          unsigned char t_key;  // 按键按住时间
  26          // 超声波测距
  27          unsigned int distance;
  28          // PCF8951
  29          unsigned char dat_rd1, dat_rd2;  // ADC读取数据
  30          float rd1_v;
  31          unsigned int smg_rd1_v;
  32          // 按键
  33          unsigned char stat_key;  // 按键按下次数
  34          unsigned int count_key_t;  // 10ms单位累计
  35          
  36          bit f_1s;  // 1s标志位
  37          
  38          unsigned int num_2ms = 0, num_s = 0, num_s_key = 0;  // 多少个2ms, 1s, 按键按下时间
  39          
  40          bit f_time = 1;  // 定时器0秒钟是否暂停
  41          
  42          sbit S7 = P3^0;
  43          sbit S6 = P3^1;
  44          sbit S5 = P3^2;
  45          sbit S4 = P3^3;
  46          
  47          sbit L0 = P0^0;
  48          sbit L1 = P0^1;
  49          sbit L2 = P0^2;
  50          sbit L3 = P0^3;
  51          sbit L4 = P0^4;
  52          sbit L5 = P0^5;
  53          sbit L6 = P0^6;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 2   

  54          sbit L7 = P0^7;
  55          
  56          unsigned char stat_led[8];  // LED状态
  57          
  58          // =========================================== 代码开始 ======================================
  59          unsigned char dis_model_s4 = 0;  // 0:显示温度（DS18B20）， 1:显示时钟 2:回显， 3：参数
  60          unsigned char dis_model_s5 = 0;  // 0：温度， 1：湿度，2：时间
  61          unsigned int temperature;  // 温度
  62          unsigned char dat1 = 0x13,dat2 = 0x03,dat3 = 0x05;  // （16进制）ds1302写数据
  63          
  64          // =========================================== 代码结束 ======================================
  65          
  66          
  67          //=========================================普通延时函数(模板函数)=================================
  68          void Delay(uint t) {
  69   1              while( t -- );
  70   1              while( t -- );
  71   1      }
  72          //=======================================单个LED控制函数(模板函数)================================
  73          // 根据项目需要删减
  74          
  75          // ======================LED0====================
  76          void LED0_On() {
  77   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  78   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  79   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  80   1              temp_Led_P0 = P0;
  81   1              P2 &= 0x1f;
  82   1              
  83   1              stat_led[0] = 1;
  84   1      }
  85          void LED0_Off() {
  86   1              P0 = 0xff & temp_Led_P0;
  87   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  88   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  89   1              temp_Led_P0 = P0;
  90   1              P2 &= 0x1f;
  91   1              
  92   1              stat_led[0] = 0;
  93   1      }
  94          // ======================LED1====================
  95          void LED1_On() {
  96   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  97   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  98   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  99   1              temp_Led_P0 = P0;
 100   1              P2 &= 0x1f;
 101   1              
 102   1              stat_led[1] = 1;
 103   1      }
 104          void LED1_Off() {
 105   1              P0 = 0xff & temp_Led_P0;
 106   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 107   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
 108   1              temp_Led_P0 = P0;
 109   1              P2 &= 0x1f;
 110   1              
 111   1              stat_led[1] = 1;
 112   1      }
 113          // ======================LED2====================
 114          void LED2_On() {
 115   1              P0 = 0xff & temp_Led_P0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 3   

 116   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 117   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
 118   1              temp_Led_P0 = P0;
 119   1              P2 &= 0x1f;
 120   1      }
 121          void LED2_Off() {
 122   1              P0 = 0xff & temp_Led_P0;
 123   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 124   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
 125   1              temp_Led_P0 = P0;
 126   1              P2 &= 0x1f;
 127   1      }
 128          // ======================LED3====================
 129          void LED3_On() {
 130   1              P0 = 0xff & temp_Led_P0;
 131   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 132   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 133   1              temp_Led_P0 = P0;
 134   1              P2 &= 0x1f;
 135   1      }
 136          void LED3_Off() {
 137   1              P0 = 0xff & temp_Led_P0;
 138   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 139   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 140   1              temp_Led_P0 = P0;
 141   1              P2 &= 0x1f;
 142   1      }
 143          // ======================LED4====================
 144          void LED4_On() {
 145   1              P0 = 0xff & temp_Led_P0;
 146   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 147   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 148   1              temp_Led_P0 = P0;
 149   1              P2 &= 0x1f;
 150   1      }
 151          void LED4_Off() {
 152   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 153   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 154   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 155   1              temp_Led_P0 = P0;
 156   1              P2 &= 0x1f;
 157   1      }
 158          // ======================LED5====================
 159          void LED5_On() {
 160   1              P0 = 0xff & temp_Led_P0;
 161   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 162   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 163   1              temp_Led_P0 = P0;
 164   1              P2 &= 0x1f;
 165   1      }
 166          void LED5_Off() {
 167   1              P0 = 0xff & temp_Led_P0;
 168   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 169   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 170   1              temp_Led_P0 = P0;
 171   1              P2 &= 0x1f;
 172   1      }
 173          // ======================LED6====================
 174          void LED6_On() {
 175   1              P0 = 0xff & temp_Led_P0;
 176   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 177   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 4   

 178   1              temp_Led_P0 = P0;
 179   1              P2 &= 0x1f;
 180   1              
 181   1              stat_led[6] = 1;
 182   1      }
 183          void LED6_Off() {
 184   1              P0 = 0xff & temp_Led_P0;
 185   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 186   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 187   1              temp_Led_P0 = P0;
 188   1              P2 &= 0x1f;
 189   1              
 190   1              stat_led[6] = 0;
 191   1      }
 192          // ======================LED7====================
 193          void LED7_On() {
 194   1              P0 = 0xff & temp_Led_P0;
 195   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 196   1              L7 = 0;  // 要将P0放在这两句代码之间，避免错乱
 197   1              temp_Led_P0 = P0;
 198   1              P2 &= 0x1f;
 199   1              
 200   1              stat_led[7] = 1;
 201   1      }
 202          void LED7_Off() {
 203   1              P0 = 0xff & temp_Led_P0;
 204   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 205   1              L7 = 1;  // 要将P0放在这两句代码之间，避免错乱
 206   1              temp_Led_P0 = P0;
 207   1              P2 &= 0x1f;
 208   1              
 209   1              stat_led[7] = 0;
 210   1      }
 211          //=========================================数码管显示==============================================
 212          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 213          {
 214   1              char i;
 215   1              P0 = 0xff;
 216   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 217   1              P0 = type2[i];
 218   1              P2 &= 0x1f;
 219   1              switch(i)//数码管位选
 220   1              {
 221   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 222   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 223   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 224   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 225   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 226   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 227   2                                                                              if(0)  // 根据需要的条件
 228   2                                                                              {
 229   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 230   3                                                                              }
 231   2                                                                              else
 232   2                                                                                      P0 = type1[n6];
 233   2                                                                                                        P2 &= 0x1f;break;
 234   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 235   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 236   2              }
 237   1              if(++i==8)
 238   1                      i = 0;
 239   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 5   

 240          
 241          //============================================按键==============================================
 242          void Delay_Keys(uint t)
 243          {
 244   1              while(t--);
 245   1      }
 246          //============================================矩阵按键============================================
 247          sfr P4 = 0xc0;
 248          sbit P44 = P4^4;
 249          sbit P42 = P4^2;
 250          
 251          uchar Scan_Keys()
 252          {
 253   1              char H,L;
 254   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 255   1              if(H == 0) return 0;
 256   1              Delay_Keys(100);
 257   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 258   1              if(H == 0) return 0;
 259   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 260   1              if(P44 == 0) L |= 0x80;
 261   1              if(P42 == 0) L |= 0x40;
 262   1              return (H+L);
 263   1      }
 264          
 265          void Change_Keys()
 266          {
 267   1              switch(Scan_Keys())
 268   1              {
 269   2                      case 0x88:GN = 4;break;  // S4
 270   2                      case 0x84:GN = 5;break;  // S5
 271   2                      case 0x82:GN = 6;break;  // S6
 272   2                      case 0x81:GN = 7;break;  // S7
 273   2                      case 0x48:GN = 8;break;  // S8
 274   2                      case 0x44:GN = 9;break;  // S9
 275   2                      case 0x42:GN = 10;break;  // S10
 276   2                      case 0x41:GN = 11;break;  // S11
 277   2                      case 0x28:GN = 12;break;  // S12
 278   2                      case 0x24:GN = 13;break;  // S13
 279   2                      case 0x22:GN = 14;break;  // S14
 280   2                      case 0x21:GN = 15;break;  // S15
 281   2                      case 0x18:GN = 16;break;  // S16
 282   2                      case 0x14:GN = 17;break;  // S17
 283   2                      case 0x12:GN = 18;break;  // S18
 284   2                      case 0x11:GN = 19;break;  // S19
 285   2                      case 0:GN = 0;break;
 286   2              }
 287   1      }
 288          //============================================DS18B20初始化============================================
 289          void Init_18b20()
 290          {
 291   1              init_ds18b20();
 292   1              Write_DS18B20(0xcc);
 293   1              Write_DS18B20(0x4e);
 294   1              Write_DS18B20(0x00);
 295   1              Write_DS18B20(0x00);
 296   1              Write_DS18B20(0x7f);
 297   1      }
 298          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 299                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 300                                                                           // 和一位小数可用unsigned char.
 301          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 6   

 302   1              unsigned char H,L;
 303   1              init_ds18b20();
 304   1              Write_DS18B20(0xcc);
 305   1              Write_DS18B20(0xbe);
 306   1              L = Read_DS18B20();
 307   1              H = Read_DS18B20();
 308   1              
 309   1              init_ds18b20();
 310   1              Write_DS18B20(0xcc);
 311   1              Write_DS18B20(0x44);
 312   1              
 313   1              //1.保留整数--23
 314   1              //temp = (H<<4) + (L>>4);
 315   1              
 316   1              //2.保留1位小数--23.4
 317   1              //temp = ((H<<8) + L)*5/8;
 318   1              
 319   1              //3.保留2位小数--23.45
 320   1              return ((H<<8)+L)*25/4;  // (50/8)
 321   1      }
 322          //============================================Ds1302初始化============================================
 323          void My_Write_Ds1302()
 324          {
 325   1              Write_Ds1302_Byte(0x8e,0x00);
 326   1              Write_Ds1302_Byte(0x84,dat1);//时
 327   1              Write_Ds1302_Byte(0x82,dat2);//分
 328   1              Write_Ds1302_Byte(0x80,dat3);//秒
 329   1      }
 330          void My_Read_Ds1302()
 331          {
 332   1              ds1302_h = Read_Ds1302_Byte(0x85);//时
 333   1              ds1302_h = (ds1302_h >> 4) * 10 + (ds1302_h & 0x0f);
 334   1              ds1302_m = Read_Ds1302_Byte(0x83);//分
 335   1              ds1302_m = (ds1302_m >> 4) * 10 + (ds1302_m & 0x0f);
 336   1              ds1302_s = Read_Ds1302_Byte(0x81);//秒
 337   1              ds1302_s = (ds1302_s >> 4) * 10 + (ds1302_s & 0x0f);
 338   1      }
 339          //============================================PCF8951部分=======================================
 340          // A/D读取光敏电阻(RD1)或电压采集(RB2)数值
 341          unsigned char Read_ADC(unsigned char n)
 342          {
 343   1              unsigned char temp;
 344   1              IIC_Start();
 345   1              IIC_SendByte(0x90);
 346   1              IIC_WaitAck();
 347   1              if (n == 1)
 348   1              {
 349   2                      IIC_SendByte(0x01);//读取光敏电阻RB1
 350   2              }
 351   1              else if (n == 2)
 352   1              {
 353   2                      IIC_SendByte(0x03);//读取滑动变阻器RB2
 354   2              }
 355   1              IIC_WaitAck();
 356   1              IIC_Stop();
 357   1              
 358   1              Delay_Keys(500);//while(500--);延时等待
 359   1              
 360   1              IIC_Start();
 361   1              IIC_SendByte(0x91);
 362   1              IIC_WaitAck();
 363   1              temp = IIC_RecByte();//读取
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 7   

 364   1              IIC_SendAck(1); 
 365   1              IIC_Stop();
 366   1              return temp;
 367   1      }
 368          
 369          //Read_ADC(1) -> (0~255) -> *2 -> (0~500)V
 370          
 371          // D/A写电压
 372          void Xie_ADC(unsigned char dat)
 373          {
 374   1              IIC_Start();
 375   1              IIC_SendByte(0x90);
 376   1          IIC_WaitAck();
 377   1          IIC_SendByte(0x40);
 378   1          IIC_WaitAck();
 379   1          IIC_SendByte(dat);
 380   1          IIC_WaitAck();
 381   1          IIC_Stop();
 382   1      }
 383          //============================================定时器T0初始化=======================================
 384          uchar count = 0;
 385          uchar pwm_dut = 0;//占空比
 386          void Init_T0()
 387          {
 388   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 389   1              TH0 = (65536 - 2000) / 256;
 390   1              TL0 = (65536 - 2000) % 256;
 391   1              
 392   1              EA = 1;
 393   1              ET0 = 1;
 394   1              TR0 = 1;
 395   1      }
 396          //============================================定时器T1初始化=======================================
 397          void Init_T1()
 398          {
 399   1              TMOD = (TMOD & 0x0f) | 0x00;//定时
 400   1      //      TH1 = (65536 - 12) / 256;
 401   1      //      TL1 = (65536 - 12) % 256;
 402   1              
 403   1      //      EA = 1;
 404   1      //      ET1 = 1;
 405   1      //      TR1 = 1;
 406   1      }
 407          //==========================================系统初始化=============================================
 408          void Init_Sys()
 409          {
 410   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 411   1              P0 = 0xff;
 412   1              P2 &= 0x1f;
 413   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 414   1              P0 = 0x00;
 415   1              P2 &= 0x1f;
 416   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 417   1              P0 = 0xff;
 418   1              P2 &= 0x1f;
 419   1              P2 = (P2 & 0x1f) | 0xe0;
 420   1              P0 = 0xff;
 421   1              
 422   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 423   1      }
 424          
 425          void LED_control() {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 8   

 426   1              // ================= 测试开始 =============
 427   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 428   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 429   1      //      P2 &= 0x1f;
 430   1              // ================= 测试结束 =============
 431   1              
 432   1              // =========================================== 代码开始 ======================================
 433   1              
 434   1              // =========================================== 代码结束 ======================================
 435   1      }
 436          
 437          void main()
 438          {
 439   1              Init_Sys();
 440   1              
 441   1              Init_T1();
 442   1      //      TMOD = (TMOD & 0x0f) | 0x00;//定时
 443   1              Init_T0();
 444   1              Init_18b20();
 445   1      
 446   1              My_Write_Ds1302();
 447   1              
 448   1              while(1)
 449   1              {
 450   2      //              LED_control();
 451   2              if(f_2ms == 1)
 452   2              {
 453   3                  f_2ms = 0;                  
 454   3                              LED_control();
 455   3                              // =======================按键开始========================
 456   3                              /*根据需要选择对应的按键类型*/
 457   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 458   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 459   3                              Change_Keys();        // 3.矩阵按键扫描
 460   3                              /*根据需要添加对应按键*/
 461   3                              if (GN == 4) {  // S4
 462   4                                      // =========================================== 代码开始 ======================================
 463   4                                      LED0_On();
 464   4                                      
 465   4                                      dis_model_s4 ++ ;
 466   4                                      if (dis_model_s4 > 2) dis_model_s4 = 0;
 467   4                                      // =========================================== 代码结束 ======================================
 468   4                                      while(Scan_Keys());
 469   4                                      // =========================================== 代码开始 ======================================
 470   4                                      LED0_Off();
 471   4                                      
 472   4                                      // =========================================== 代码结束 ======================================
 473   4                              }
 474   3                              
 475   3                              if (GN == 5) {  // S5
 476   4                                      // =========================================== 代码开始 ======================================
 477   4                                      LED0_On();
 478   4                                      
 479   4                                      // =========================================== 代码结束 ======================================
 480   4                                      while(Scan_Keys());
 481   4                                      // =========================================== 代码开始 ======================================
 482   4                                      LED0_Off();
 483   4                                      // =========================================== 代码结束 ======================================
 484   4                              }
 485   3                              if (GN == 8) {  // S8
 486   4                                      // =========================================== 代码开始 ======================================
 487   4                                      LED0_On();
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 9   

 488   4                                      
 489   4                                      // =========================================== 代码结束 ======================================
 490   4                                      while(Scan_Keys());
 491   4                                      // =========================================== 代码开始 ======================================
 492   4                                      LED0_Off();
 493   4                                      // =========================================== 代码结束 ======================================
 494   4                              }
 495   3                              if (GN == 9) {  // S9
 496   4                                      // =========================================== 代码开始 ======================================
 497   4                                      LED0_On();
 498   4                                      
 499   4                                      // =========================================== 代码结束 ======================================
 500   4                                      while(Scan_Keys());
 501   4                                      // =========================================== 代码开始 ======================================
 502   4                                      LED0_Off();
 503   4                                      // =========================================== 代码结束 ======================================
 504   4                              }
 505   3                              // =======================按键结束========================
 506   3                                                      
 507   3                              // =========================================== 测试代码开始 ======================================                      
 508   3                              // =======================1.温度读取开始========================
 509   3                              
 510   3                              // =======================1.温度读取结束========================
 511   3                              
 512   3                              // =========================================== 测试代码结束 ======================================
 513   3                              
 514   3                              // =========================================== 代码开始 ======================================
 515   3                              if (f_200ms_ds1302) {
 516   4                                      f_200ms_ds1302 = 0;
 517   4                                      My_Read_Ds1302();
 518   4                              }
 519   3                              
 520   3                              if (dis_model_s4 == 0) {  // 时间显示
 521   4                                      num1=ds1302_h/10;num2=ds1302_h%10;num3=11;
 522   4                                      num4=ds1302_m/10;num5=ds1302_m%10;num6=11;
 523   4                                      num7=ds1302_s/10;num8=ds1302_s%10;
 524   4                              }
 525   3                              else if (dis_model_s4 == 1) {  // 回转
 526   4                                      num1=dis_model_s4;num2=10;num3=10;num4=10;
 527   4                                      num4=11;num5=11;num6=11;
 528   4                                      num7=11;num8=11;
 529   4                              }
 530   3                              else if (dis_model_s4 == 2) {  // 参数
 531   4                                      num1=dis_model_s4;num2=10;num3=10;num4=10;
 532   4                                      num4=11;num5=11;num6=11;
 533   4                                      num7=11;num8=11;
 534   4                              }
 535   3                              // =========================================== 代码结束 ======================================
 536   3              }
 537   2          }
 538   1      }
 539          
 540          void Service_T0() interrupt 1
 541          {
 542   1              TH0 = (65536 - 2000) / 256;
 543   1              TL0 = (65536 - 2000) % 256;
 544   1              
 545   1              f_2ms = 1;
 546   1              
 547   1              num_2ms ++ ;
 548   1              
 549   1              if (num_2ms == 500) {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 10  

 550   2                      f_1s = 1;
 551   2                      num_2ms = 0;
 552   2              }
 553   1              
 554   1              if (f_1s == 1) {
 555   2                      f_1s = 0;
 556   2                      
 557   2                      if (f_time) num_s ++ ;
 558   2                      
 559   2                      // 按键长按
 560   2      //              if (is_key_set_time && dis_model == 2) {
 561   2      //                      num_s_key ++ ;
 562   2      //                      if (num_s_key == 2) {
 563   2      //                              LED4_On();
 564   2      //                              f_key_long = 1;
 565   2      //                      }
 566   2      //              }                       
 567   2                              
 568   2                      
 569   2                      if (num_s == 9) 
 570   2                              num_s = 0;
 571   2                      
 572   2              }
 573   1              
 574   1              // 数码管闪烁
 575   1              num_2ms_smg ++ ;
 576   1              if (num_2ms_smg == 250) {
 577   2                      num_2ms_smg = 0;
 578   2                      f_500ms_smg = ~f_500ms_smg;
 579   2              }
 580   1              
 581   1              // 按键双击
 582   1              if (stat_key != 0) {
 583   2                      count_key_t ++ ;
 584   2              }
 585   1              
 586   1              // 时间读取刷新
 587   1              num_2ms_ds1302 ++ ;
 588   1              if (num_2ms_ds1302 == 100) {
 589   2                      f_200ms_ds1302 = 1;
 590   2                      num_2ms_ds1302 = 0;
 591   2              }
 592   1                      /***************************************************
 593   1              与时间相关的变量的更新放在里面
 594   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 595   1              ***************************************************/
 596   1              // =========================================== 代码开始 ======================================
 597   1              
 598   1              // =========================================== 代码结束 ======================================
 599   1              
 600   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 601   1      }
*** WARNING C294 IN LINE 229 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1609    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     54      14
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 17:18:44 PAGE 11  

   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
