C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc\pack_file\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /********************************************
   2          (1.1)led依次向右点亮，亮度可用软件进行调节
   3          ********************************************/
   4          /****************
   5          #include <STC15F2K60S2.H>
   6          #include <intrins.h>
   7          #define uchar unsigned char 
   8          #define uint unsigned int 
   9          uchar t_2ms,l_2ms;
  10          bit f_2ms;
  11          
  12          uchar led_type[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  13          //uchar bdata U6=0xff;  
  14          //sbit led1=U6^0;
  15          //sbit led2=U6^1;
  16          //sbit led3=U6^2;
  17          //sbit led4=U6^3;
  18          //sbit led5=U6^4;
  19          //sbit led6=U6^5;
  20          //sbit led7=U6^6;
  21          //sbit led8=U6^7;
  22          
  23          void time1_int1()
  24          {
  25            EA=1;
  26            ET1=1;
  27            TR1=1;
  28            TMOD=(TMOD&0x0f)|0x10;
  29            TH1=(65535-2000)/256;
  30            TL1=(65535-2000)%256; 
  31          }
  32          
  33          void initial_all()
  34          {
  35            P2=(P2&0x1f)|0xa0;  
  36            P0=0x00;  
  37            P2=(P2&0x1f); 
  38            P2=(P2&0x1f)|0x80;  
  39            P0=0xff;  
  40            P2=(P2&0x1f);   
  41            P2=(P2&0x1f)|0xc0;  
  42            P0=0xff;  
  43            P2=(P2&0x1f);   
  44            P2=(P2&0x1f)|0xe0;  
  45            P0=0xff;  
  46            P2=(P2&0x1f);   
  47          }
  48          void main()
  49          {
  50            uchar led;
  51            initial_all();
  52            time1_int1();
  53            while(1)
  54            {
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 2   

  55             if(f_2ms)
  56             {
  57              f_2ms=0;
  58          
  59              if(++l_2ms==10)
  60              {
  61                l_2ms=0;
  62                P2=(P2&0x1f)|0x80;  
  63                P0=0xff;  
  64                P2=(P2&0x1f);     
  65              }
  66               if(l_2ms==1) 
  67               {
  68                P2=(P2&0x1f)|0x80;  
  69                P0=led_type[led];
  70                P2=(P2&0x1f);        
  71               }         
  72              if(++t_2ms==250)
  73              {
  74                t_2ms=0;
  75                led++;
  76                if(led==8)
  77                  led=0;
  78              } 
  79             }//f_2ms;
  80            }
  81          }
  82          
  83          void cl_time1_int1() interrupt 3
  84          {
  85            TH1=(65535-2000)/256;
  86            TL1=(65535-2000)%256; 
  87            f_2ms=1;
  88          }
  89          
  90          
  91          ***************/
  92          
  93          /********************************************
  94          (1.2)蜂鸣器与继电器每秒点亮其中一个
  95          ********************************************/
  96          /*****************
  97          #include <STC15F2K60S2.H>
  98          #include <intrins.h>
  99          #define uchar unsigned char 
 100          #define uint unsigned int 
 101          uint t_2ms;
 102          bit f_2ms;
 103          bit flag;
 104          
 105          
 106          uchar bdata U9;
 107          sbit relay=U9^4;
 108          sbit beep=U9^6;
 109          
 110          
 111          void time1_int1()
 112          {
 113            EA=1;
 114            ET1=1;
 115            TR1=1;
 116            TMOD=(TMOD&0x0f)|0x10;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 3   

 117            TH1=(65535-2000)/256;
 118            TL1=(65535-2000)%256; 
 119          }
 120          
 121          void initial_all()
 122          {
 123            P2=(P2&0x1f)|0xa0;  
 124            P0=0x00;  
 125            P2=(P2&0x1f); 
 126            P2=(P2&0x1f)|0x80;  
 127            P0=0xff;  
 128            P2=(P2&0x1f);   
 129            P2=(P2&0x1f)|0xc0;  
 130            P0=0xff;  
 131            P2=(P2&0x1f);   
 132            P2=(P2&0x1f)|0xe0;  
 133            P0=0xff;  
 134            P2=(P2&0x1f);   
 135          }
 136          void main()
 137          {
 138            initial_all();
 139            time1_int1();
 140            while(1)
 141            {
 142             if(f_2ms)
 143             {
 144              f_2ms=0;
 145              if(++t_2ms==500)
 146              {
 147                t_2ms=0;
 148                flag ^= 1;      
 149              }
 150               if(flag)
 151               {
 152                relay=1;beep=0; 
 153                P2=(P2&0x1f)|0xa0;  
 154                P0=U9;  
 155                P2=(P2&0x1f);         
 156               }
 157               else
 158               {
 159                relay=0;beep=1;
 160                P2=(P2&0x1f)|0xa0;  
 161                P0=U9;  
 162                P2=(P2&0x1f);         
 163               }
 164               
 165             }//f_2ms;
 166            }
 167          }
 168          
 169          void cl_time1_int1() interrupt 3
 170          {
 171            TH1=(65535-2000)/256;
 172            TL1=(65535-2000)%256; 
 173            f_2ms=1;
 174          }
 175          *****************/
 176          
 177          
 178          /********************************************
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 4   

 179          (1.3)P34输出不同占空比脉冲信号，软件调节。可测出（1，2，3，4，5）V电压
 180          ********************************************/
 181          /********************
 182          #include <STC15F2K60S2.H>
 183          #include <intrins.h>
 184          #define uchar unsigned char 
 185          #define uint unsigned int 
 186          uint t_2ms;
 187          bit f_2ms;
 188          
 189          sbit output=P3^4;
 190          
 191          void time1_int1()
 192          {
 193            EA=1;
 194            ET1=1;
 195            TR1=1;
 196            TMOD=(TMOD&0x0f)|0x10;
 197            TH1=(65535-2000)/256;
 198            TL1=(65535-2000)%256; 
 199          }
 200          
 201          void initial_all()
 202          {
 203            P2=(P2&0x1f)|0xa0;  
 204            P0=0x00;  
 205            P2=(P2&0x1f); 
 206            P2=(P2&0x1f)|0x80;  
 207            P0=0xff;  
 208            P2=(P2&0x1f);   
 209            P2=(P2&0x1f)|0xc0;  
 210            P0=0xff;  
 211            P2=(P2&0x1f);   
 212            P2=(P2&0x1f)|0xe0;  
 213            P0=0xff;  
 214            P2=(P2&0x1f);   
 215          }
 216          void main()
 217          {
 218            initial_all();
 219            time1_int1();
 220            while(1)
 221            {
 222             if(f_2ms)
 223             {
 224              f_2ms=0;
 225              if(++t_2ms==10)
 226              {
 227                t_2ms=0;
 228                output=0;
 229              }
 230              if(t_2ms==8)
 231              {
 232                output=1;
 233              }          
 234             }//f_2ms;
 235            }
 236          }
 237          
 238          void cl_time1_int1() interrupt 3
 239          {
 240            TH1=(65535-2000)/256;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 5   

 241            TL1=(65535-2000)%256; 
 242            f_2ms=1;
 243          }
 244          *******************/
 245          
 246          
 247          /********************************************
 248          (2.1)利用定时器1中断扫描数码管动态显示，交替显示带点数字与不带电数字
 249          ********************************************/
 250          /**************
 251          #include <STC15F2K60S2.H>
 252          #include <intrins.h>
 253          #define uchar unsigned char 
 254          #define uint unsigned int 
 255          uchar type1[]={0xc0,  
 256                          0xf9,  
 257                          0xa4,   
 258                          0xb0,  
 259                          0x99,  
 260                          0x92,  
 261                          0x82,  
 262                          0xf8,  
 263                          0x80,  
 264                          0x90,0xff};
 265          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
 266          uchar num1,num2,num3,num4,num5,num6,num7,num8;
 267          uint t_2ms;
 268          bit f_2ms;
 269          bit flag;
 270          
 271          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
 272          {
 273            char i;
 274            P2=(P2&0x1f)|0xc0;
 275            P0=type2[i];
 276            P2=(P2&0x1f);
 277            P0=0xff;
 278            switch(i)
 279            {
 280              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
 281              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
 282              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
 283              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
 284              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
 285              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
 286              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
 287              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
 288            }
 289            if(++i==8)
 290              i=0;
 291          }
 292          
 293          void time1_int1()
 294          {
 295            EA=1;
 296            ET1=1;
 297            TR1=1;
 298            TMOD=(TMOD&0x0f)|0x10;
 299            TH1=(65535-2000)/256;
 300            TL1=(65535-2000)%256; 
 301          }
 302          
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 6   

 303          void initial_all()
 304          {
 305            P2=(P2&0x1f)|0xa0;  
 306            P0=0x00;  
 307            P2=(P2&0x1f); 
 308            P2=(P2&0x1f)|0x80;  
 309            P0=0xff;  
 310            P2=(P2&0x1f);   
 311            P2=(P2&0x1f)|0xc0;  
 312            P0=0xff;  
 313            P2=(P2&0x1f);   
 314            P2=(P2&0x1f)|0xe0;  
 315            P0=0xff;  
 316            P2=(P2&0x1f);   
 317          }
 318          void main()
 319          {
 320            initial_all();
 321            time1_int1();
 322            while(1)
 323            {
 324             if(f_2ms)
 325             {
 326              f_2ms=0;
 327              if(++t_2ms==500)
 328              {
 329                t_2ms=0;
 330                flag ^= 1;
 331              } 
 332              if(flag)
 333              {
 334                type1[0]=0xc0;type1[1]=0xf9;type1[2]=0xa4;type1[3]=0xb0;
 335                type1[4]=0x99;type1[5]=0x92;type1[6]=0x82;type1[7]=0xf8;
 336                type1[8]=0x80;type1[9]=0x90;
 337              }
 338              else
 339              {
 340                type1[0]=0xc0&0x7f;type1[1]=0xf9&0x7f;type1[2]=0xa4&0x7f;type1[3]=0xb0&0x7f;
 341                type1[4]=0x99&0x7f;type1[5]=0x92&0x7f;type1[6]=0x82&0x7f;type1[7]=0xf8&0x7f;
 342                type1[8]=0x80&0x7f;type1[9]=0x90&0x7f;
 343              } 
 344              num1=1;num2=2;num3=3;num4=4;num5=5;num6=6;num7=7;num8=8;
 345             }//f_2ms;
 346            }
 347          }
 348          
 349          void cl_time1_int1() interrupt 3
 350          {
 351            TH1=(65535-2000)/256;
 352            TL1=(65535-2000)%256; 
 353            f_2ms=1;
 354            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
 355          }
 356          
 357          ****************/
 358          
 359          /********************************************
 360          (3.1)显示独立按键键值。实验按下显示与松手显示
 361          ********************************************/
 362          /*****************
 363          #include <STC15F2K60S2.H>
 364          #include <intrins.h>
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 7   

 365          #define uchar unsigned char 
 366          #define uint unsigned int 
 367          uchar type1[]={0xc0,  
 368                          0xf9,  
 369                          0xa4,   
 370                          0xb0,  
 371                          0x99,  
 372                          0x92,  
 373                          0x82,  
 374                          0xf8,  
 375                          0x80,  
 376                          0x90,0xff};
 377          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
 378          uchar num1,num2,num3,num4,num5,num6,num7,num8;
 379          uint t_2ms;
 380          bit f_2ms;
 381          uchar GN;
 382          
 383          
 384          
 385          void Delay10ms()    //@12.000MHz
 386          {
 387            unsigned char i, j;
 388          
 389            i = 117;
 390            j = 184;
 391            do
 392            {
 393              while (--j);
 394            } while (--i);
 395          }
 396          
 397          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
 398          {
 399            char i;
 400            P2=(P2&0x1f)|0xc0;
 401            P0=type2[i];
 402            P2=(P2&0x1f);
 403            P0=0xff;
 404            switch(i)
 405            {
 406              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
 407              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
 408              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
 409              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
 410              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
 411              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
 412              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
 413              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
 414            }
 415            if(++i==8)
 416              i=0;
 417          }
 418          //=============================================key
 419          uchar key_scan()
 420          {
 421            uchar temp;
 422            temp=(~P3)&0x0f;
 423            if(temp==0) return 0;
 424            Delay10ms();
 425            temp=(~P3)&0x0f;
 426            if(temp==0) return 0; 
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 8   

 427            return temp;  
 428          }
 429          void key_change()
 430          {
 431            uchar D;
 432            D=key_scan();
 433            switch(D)
 434            {
 435              case 8:GN=4;break;
 436              case 4:GN=5;break;
 437              case 2:GN=6;break;
 438              case 1:GN=7;break;
 439              //case 0:GN=0;break;    
 440            }
 441            while(key_scan());//实现松手显示
 442          }
 443          
 444          void time1_int1()
 445          {
 446            EA=1;
 447            ET1=1;
 448            TR1=1;
 449            TMOD=(TMOD&0x0f)|0x10;
 450            TH1=(65535-2000)/256;
 451            TL1=(65535-2000)%256; 
 452          }
 453          
 454          void initial_all()
 455          {
 456            P2=(P2&0x1f)|0xa0;  
 457            P0=0x00;  
 458            P2=(P2&0x1f); 
 459            P2=(P2&0x1f)|0x80;  
 460            P0=0xff;  
 461            P2=(P2&0x1f);   
 462            P2=(P2&0x1f)|0xc0;  
 463            P0=0xff;  
 464            P2=(P2&0x1f);   
 465            P2=(P2&0x1f)|0xe0;  
 466            P0=0xff;  
 467            P2=(P2&0x1f);   
 468          }
 469          void main()
 470          {
 471            initial_all();
 472            time1_int1();
 473            while(1)
 474            {
 475             if(f_2ms)
 476             {
 477              f_2ms=0;
 478              key_change();
 479               
 480          
 481              num1=10;num2=10;num3=10;num4=10;num5=10;num6=10;num7=10;num8=GN;
 482             }//f_2ms;
 483            }
 484          }
 485          
 486          void cl_time1_int1() interrupt 3
 487          {
 488            TH1=(65535-2000)/256;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 9   

 489            TL1=(65535-2000)%256; 
 490            f_2ms=1;
 491            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
 492          }
 493          *******************/
 494          
 495          
 496          
 497          /********************************************
 498          (3.2)显示矩阵按键键值。（3*4   与   4*4）
 499          ********************************************/
 500          /*****************
 501          #include <STC15F2K60S2.H>
 502          #include <intrins.h>
 503          #define uchar unsigned char 
 504          #define uint unsigned int 
 505          uchar type1[]={0xc0,  
 506                          0xf9,  
 507                          0xa4,   
 508                          0xb0,  
 509                          0x99,  
 510                          0x92,  
 511                          0x82,  
 512                          0xf8,  
 513                          0x80,  
 514                          0x90,0xff};
 515          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
 516          uchar num1,num2,num3,num4,num5,num6,num7,num8;
 517          uint t_2ms;
 518          bit f_2ms;
 519          uchar GN;
 520          
 521          void Delay10ms()    //@12.000MHz
 522          {
 523            unsigned char i, j;
 524          
 525            i = 117;
 526            j = 184;
 527            do
 528            {
 529              while (--j);
 530            } while (--i);
 531          }
 532          
 533          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
 534          {
 535            char i;
 536            P2=(P2&0x1f)|0xc0;
 537            P0=type2[i];
 538            P2=(P2&0x1f);
 539            P0=0xff;
 540            switch(i)
 541            {
 542              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
 543              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
 544              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
 545              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
 546              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
 547              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
 548              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
 549              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
 550            }
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 10  

 551            if(++i==8)
 552              i=0;
 553          }
 554          //====================================================key
 555          uchar key_scan()
 556          {
 557            uchar H,L;
 558          //  P3=0xcf;P44=0;P42=0;H=(~P3)&0x0f;  //4*4
 559              P3=0xdf;P44=0;P42=0;H=(~P3)&0x0f;  //3*4  
 560            if(H==0) return 0;
 561            Delay10ms();
 562          //  P3=0x0f;P44=0;P42=0;H=(~P3)&0x0f; //4*4
 563            P3=0xdf;P44=0;P42=0;H=(~P3)&0x0f;   //3*4
 564            if(H==0) return 0;
 565            P3=0xf0;P44=1;P42=1;L=(~P3)&0x20;
 566            if(P44==0) L|=0x80;
 567            if(P42==0) L|=0x40;
 568            return H+L;
 569          }
 570          void key_change()
 571          {
 572            uchar D;
 573            D=key_scan();
 574            switch(D)
 575            {
 576              case 0x88:GN=4;break;
 577              case 0x84:GN=5;break;
 578              case 0x82:GN=6;break;
 579              case 0x81:GN=7;break;
 580              case 0x48:GN=8;break;
 581              case 0x44:GN=9;break;
 582              case 0x42:GN=10;break;
 583              case 0x41:GN=11;break;
 584              case 0x28:GN=12;break;
 585              case 0x24:GN=13;break;
 586              case 0x22:GN=14;break;
 587              case 0x21:GN=15;break;
 588              case 0x18:GN=16;break;
 589              case 0x14:GN=17;break;
 590              case 0x12:GN=18;break;
 591              case 0x11:GN=19;break;
 592          
 593              //case 0:GN=0;break;    
 594            }   
 595          }
 596          
 597          void time1_int1()
 598          {
 599            EA=1;
 600            ET1=1;
 601            TR1=1;
 602            TMOD=(TMOD&0x0f)|0x10;
 603            TH1=(65535-2000)/256;
 604            TL1=(65535-2000)%256; 
 605          }
 606          
 607          void initial_all()
 608          {
 609            P2=(P2&0x1f)|0xa0;  
 610            P0=0x00;  
 611            P2=(P2&0x1f); 
 612            P2=(P2&0x1f)|0x80;  
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 11  

 613            P0=0xff;  
 614            P2=(P2&0x1f);   
 615            P2=(P2&0x1f)|0xc0;  
 616            P0=0xff;  
 617            P2=(P2&0x1f);   
 618            P2=(P2&0x1f)|0xe0;  
 619            P0=0xff;  
 620            P2=(P2&0x1f);   
 621          }
 622          void main()
 623          {
 624            initial_all();
 625            time1_int1();
 626            while(1)
 627            {
 628             if(f_2ms)
 629             {
 630              f_2ms=0;
 631              key_change();
 632               
 633              num1=10;num2=10;num3=10;num4=10;num5=10;num6=10;num7=GN/10;num8=GN%10;
 634             }//f_2ms;
 635            }
 636          }
 637          
 638          void cl_time1_int1() interrupt 3
 639          {
 640            TH1=(65535-2000)/256;
 641            TL1=(65535-2000)%256; 
 642            f_2ms=1;
 643            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
 644          }
 645          
 646          *****************/
 647          /********************************************
 648          (3.3)独立按键，实现长按有效，实验双击有效
 649          ********************************************/
 650          /*****************
 651          #include <STC15F2K60S2.H>
 652          #include <intrins.h>
 653          #define uchar unsigned char 
 654          #define uint unsigned int 
 655          uchar type1[]={0xc0,  
 656                          0xf9,  
 657                          0xa4,   
 658                          0xb0,  
 659                          0x99,  
 660                          0x92,  
 661                          0x82,  
 662                          0xf8,  
 663                          0x80,  
 664                          0x90,0xff};
 665          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
 666          uchar num1,num2,num3,num4,num5,num6,num7,num8;
 667          uint t_2ms;
 668          bit f_2ms;
 669          uchar GN;
 670          uchar bdata U6=0xff;  
 671          sbit led1=U6^0;
 672          sbit led2=U6^1;
 673          //-------------------
 674          bit f_led1;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 12  

 675          bit f_led2;
 676          
 677          bit f_chang;
 678          bit f_lim;
 679          
 680          void Delay10ms()    //@12.000MHz
 681          {
 682            unsigned char i, j;
 683          
 684            i = 117;
 685            j = 184;
 686            do
 687            {
 688              while (--j);
 689            } while (--i);
 690          }
 691          
 692          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
 693          {
 694            char i;
 695            P2=(P2&0x1f)|0xc0;
 696            P0=type2[i];
 697            P2=(P2&0x1f);
 698            P0=0xff;
 699            switch(i)
 700            {
 701              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
 702              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
 703              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
 704              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
 705              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
 706              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
 707              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
 708              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
 709            }
 710            if(++i==8)
 711              i=0;
 712          }
 713          //=============================================key
 714          uchar key_scan()
 715          {
 716            uchar temp;
 717            temp=(~P3)&0x0f;
 718            if(temp==0) return 0;
 719            Delay10ms();
 720            temp=(~P3)&0x0f;
 721            if(temp==0) return 0; 
 722            return temp;  
 723          }
 724          void key_change()
 725          {
 726            uchar D;
 727            D=key_scan();
 728            switch(D)
 729            {
 730              case 8:GN=4;break;
 731              case 4:GN=5;break;
 732              case 2:GN=6;break;
 733              case 1:GN=7;break;
 734              case 0:GN=0;break;    
 735            }
 736            //while(key_scan());//实现松手显示
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 13  

 737          }
 738          
 739          void time1_int1()
 740          {
 741            EA=1;
 742            ET1=1;
 743            TR1=1;
 744            TMOD=(TMOD&0x0f)|0x10;
 745            TH1=(65535-2000)/256;
 746            TL1=(65535-2000)%256; 
 747          }
 748          
 749          void initial_all()
 750          {
 751            P2=(P2&0x1f)|0xa0;  
 752            P0=0x00;  
 753            P2=(P2&0x1f); 
 754            P2=(P2&0x1f)|0x80;  
 755            P0=0xff;  
 756            P2=(P2&0x1f);   
 757            P2=(P2&0x1f)|0xc0;  
 758            P0=0xff;  
 759            P2=(P2&0x1f);   
 760            P2=(P2&0x1f)|0xe0;  
 761            P0=0xff;  
 762            P2=(P2&0x1f);   
 763          }
 764          void main()
 765          {
 766            initial_all();
 767            time1_int1();
 768            while(1)
 769            {
 770             if(f_2ms)
 771             {
 772              f_2ms=0;
 773              key_change();
 774              if(GN==4)//短按键
 775              {     
 776                f_chang=1;
 777                f_lim=0;
 778                while(key_scan());
 779                t_2ms=0;
 780                if(f_lim==0)
 781                {
 782                  f_led1 ^= 1;        
 783                }
 784              }
 785              //-----------------------
 786              if(f_led1)
 787              {
 788                led1=0;
 789                P0=0xff;
 790                P2=(P2&0x1f)|0x80;  
 791                P0=U6;  
 792                P2=(P2&0x1f);       
 793              }
 794              else
 795              {
 796                led1=1;
 797                P0=0xff;
 798                P2=(P2&0x1f)|0x80;  
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 14  

 799                P0=U6;  
 800                P2=(P2&0x1f);       
 801              }
 802              //------------------------
 803              if(f_led2)
 804              {
 805                led2=0;
 806                P0=0xff;
 807                P2=(P2&0x1f)|0x80;  
 808                P0=U6;  
 809                P2=(P2&0x1f);       
 810              }
 811              else
 812              {
 813                led2=1;
 814                P0=0xff;
 815                P2=(P2&0x1f)|0x80;  
 816                P0=U6;  
 817                P2=(P2&0x1f);       
 818              }
 819          
 820              num1=10;num2=10;num3=10;num4=10;num5=10;num6=10;num7=10;num8=GN;
 821             }//f_2ms;
 822            }
 823          }
 824          
 825          void cl_time1_int1() interrupt 3
 826          {
 827            TH1=(65535-2000)/256;
 828            TL1=(65535-2000)%256; 
 829            f_2ms=1;
 830            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
 831            
 832            if(f_chang==1)
 833            {
 834              if(++t_2ms==500)
 835              {
 836                t_2ms=0;
 837                f_lim=1;
 838                f_led2 ^= 1;
 839                f_chang=0;
 840              }   
 841            }
 842          }
 843          *******************/
 844          
 845          
 846          /********************************************
 847          (4.1)数码管显示555方波发生器频率，高位不用的应熄灭
 848          ********************************************/
 849          /******************
 850          #include <STC15F2K60S2.H>
 851          #include <intrins.h>
 852          #define uchar unsigned char 
 853          #define uint unsigned int 
 854          uchar type1[]={0xc0,  
 855                          0xf9,  
 856                          0xa4,   
 857                          0xb0,  
 858                          0x99,  
 859                          0x92,  
 860                          0x82,  
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 15  

 861                          0xf8,  
 862                          0x80,  
 863                          0x90,0xff};
 864          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
 865          uchar num1,num2,num3,num4,num5,num6,num7,num8;
 866          uint t_2ms;
 867          bit f_2ms;
 868          uint temp;
 869          bit flag;
 870          
 871          
 872          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
 873          {
 874            char i;
 875            P2=(P2&0x1f)|0xc0;
 876            P0=type2[i];
 877            P2=(P2&0x1f);
 878            P0=0xff;
 879            switch(i)
 880            {
 881              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
 882              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
 883              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
 884              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
 885              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
 886              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
 887              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
 888              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
 889            }
 890            if(++i==8)
 891              i=0;
 892          }
 893          //===================================================数据处理
 894          void shujv_chuli(uint D)
 895          {
 896            if(D<10)
 897            {
 898              num4=num5=num6=num7=10;
 899              num8=D;
 900            }
 901            if(D>9 && D<100)
 902            {
 903              num4=num5=num6=10;
 904              num7=D/10;num8=D%10;
 905            } 
 906            if(D>99 && D<1000)
 907            {
 908              num4=num5=10;
 909              num6=D/100;num7=D%100/10;num8=D%10;
 910            }   
 911            if(D>999 && D<10000)
 912            {
 913              num4=10;
 914              num5=D/1000;num6=D%1000/100;num7=D%100/10;num8=D%10;
 915            }   
 916            if(D>9999)
 917            {
 918              num4=D/10000;num5=D%10000/1000;num6=D%1000/100;num7=D%100/10;num8=D%10;
 919            }
 920            
 921          }
 922          
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 16  

 923          void time0()
 924          {
 925            TMOD=(TMOD&0xf0)|0x05;
 926            TH0=0;
 927            TR0=0;    
 928          }
 929          void time1_int1()
 930          {
 931            EA=1;
 932            ET1=1;
 933            TR1=1;
 934            TMOD=(TMOD&0x0f)|0x10;
 935            TH1=(65535-2000)/256;
 936            TL1=(65535-2000)%256; 
 937          }
 938          
 939          void initial_all()
 940          {
 941            P2=(P2&0x1f)|0xa0;  
 942            P0=0x00;  
 943            P2=(P2&0x1f); 
 944            P2=(P2&0x1f)|0x80;  
 945            P0=0xff;  
 946            P2=(P2&0x1f);   
 947            P2=(P2&0x1f)|0xc0;  
 948            P0=0xff;  
 949            P2=(P2&0x1f);   
 950            P2=(P2&0x1f)|0xe0;  
 951            P0=0xff;  
 952            P2=(P2&0x1f);   
 953          }
 954          void main()
 955          {
 956            initial_all();
 957            time1_int1();
 958            time0();
 959            while(1)
 960            {
 961             if(f_2ms)
 962             {
 963              f_2ms=0;
 964              shujv_chuli(temp);
 965          
 966          
 967              
 968             }//f_2ms;
 969            }
 970          }
 971          
 972          void cl_time1_int1() interrupt 3
 973          {
 974            TH1=(65535-2000)/256;
 975            TL1=(65535-2000)%256; 
 976            f_2ms=1;
 977            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
 978            
 979            if(++t_2ms==250)
 980            {
 981              t_2ms=0;
 982              flag=~flag;
 983              if(flag)
 984              {
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 17  

 985                TH0=0;
 986                TL0=0;
 987                TR0=1;
 988              }
 989              else
 990              {
 991                TR0=0;
 992                temp=((TH0<<8)+TL0)*2;
 993              }   
 994            } 
 995          }
 996          *************************/
 997          
 998          
 999          
1000          /********************************************
1001          (5.1)DS1302显示时分秒，通过软件写入1302时分秒
1002          ********************************************/
1003          /*********************
1004          #include <STC15F2K60S2.H>
1005          #include "ds1302.h" 
1006          #include <intrins.h>
1007          #define uchar unsigned char 
1008          #define uint unsigned int 
1009          uchar code type1[]={0xc0,  
1010                          0xf9,  
1011                          0xa4,   
1012                          0xb0,  
1013                          0x99,  
1014                          0x92,  
1015                          0x82,  
1016                          0xf8,  
1017                          0x80,  
1018                          0x90,0xff};
1019          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1020          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1021          uint t_2ms;
1022          bit f_2ms;
1023          uchar hour,minute,second;
1024          
1025          
1026          
1027          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1028          {
1029            char i;
1030            P2=(P2&0x1f)|0xc0;
1031            P0=type2[i];
1032            P2=(P2&0x1f);
1033            P0=0xff;
1034            switch(i)
1035            {
1036              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1037              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1038              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1039              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1040              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1041              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1042              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
1043              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
1044            }
1045            if(++i==8)
1046              i=0;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 18  

1047          }
1048          //===================================================1302
1049          void xie_1302(uchar a,uchar b,uchar c)
1050          {
1051            Write_Ds1302_Byte( 0x8e,0x00 );
1052            Write_Ds1302_Byte( 0x84,a );
1053            Write_Ds1302_Byte( 0x82,b );
1054            Write_Ds1302_Byte( 0x80,c );  
1055          }
1056          void du_1302()
1057          {
1058            hour=Read_Ds1302_Byte( 0x85 );  hour=(hour>>4)*10+(hour&0x0f);
1059            minute=Read_Ds1302_Byte( 0x83 );minute=(minute>>4)*10+(minute&0x0f);
1060            second=Read_Ds1302_Byte( 0x81 );second=(second>>4)*10+(second&0x0f);
1061          
1062          }
1063          uchar d_bcd(uchar D)
1064          {
1065            uchar dat1,dat2;
1066            dat1=D/10;
1067            dat2=D%10;
1068            dat2=dat1*16+dat2;
1069            return dat2;
1070          }
1071          
1072          void time1_int1()
1073          {
1074            EA=1;
1075            ET1=1;
1076            TR1=1;
1077            TMOD=(TMOD&0x0f)|0x10;
1078            TH1=(65535-2000)/256;
1079            TL1=(65535-2000)%256; 
1080          }
1081          
1082          void initial_all()
1083          {
1084            P2=(P2&0x1f)|0xa0;  
1085            P0=0x00;  
1086            P2=(P2&0x1f); 
1087            P2=(P2&0x1f)|0x80;  
1088            P0=0xff;  
1089            P2=(P2&0x1f);   
1090            P2=(P2&0x1f)|0xc0;  
1091            P0=0xff;  
1092            P2=(P2&0x1f);   
1093            P2=(P2&0x1f)|0xe0;  
1094            P0=0xff;  
1095            P2=(P2&0x1f);   
1096          }
1097          void main()
1098          {
1099            initial_all();
1100            time1_int1();
1101          
1102            xie_1302(d_bcd(20),d_bcd(21),d_bcd(58));
1103            while(1)
1104            {
1105             if(f_2ms)
1106             {
1107              f_2ms=0;
1108              du_1302();
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 19  

1109               
1110              num1=hour/10;num2=hour%10;     num3=10;
1111              num4=minute/10;num5=minute%10; num6=10;
1112              num7=second/10;num8=second%10;
1113             }//f_2ms;
1114            }
1115          }
1116          
1117          void cl_time1_int1() interrupt 3
1118          {
1119            TH1=(65535-2000)/256;
1120            TL1=(65535-2000)%256; 
1121            f_2ms=1;
1122            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1123            
1124          }
1125          
1126          ************************/
1127          
1128          /********************************************
1129          (6.1)ds18b20显示温度数据，实验不同分辨率下的数据显示（0.5/0.25/0.125/0.0625）
1130          ********************************************/
1131          /******************
1132          #include <STC15F2K60S2.H>
1133          #include "onewire.h"
1134          #include <intrins.h>
1135          #define uchar unsigned char 
1136          #define uint unsigned int 
1137          uchar code type1[]={0xc0,  
1138                          0xf9,  
1139                          0xa4,   
1140                          0xb0,  
1141                          0x99,  
1142                          0x92,  
1143                          0x82,  
1144                          0xf8,  
1145                          0x80,  
1146                          0x90,0xff};
1147          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1148          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1149          uint t_2ms;
1150          bit f_2ms;
1151          
1152          
1153          
1154          
1155          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1156          {
1157            char i;
1158            P2=(P2&0x1f)|0xc0;
1159            P0=type2[i];
1160            P2=(P2&0x1f);
1161            P0=0xff;
1162            switch(i)
1163            {
1164              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1165              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1166              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1167              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1168              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1169              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1170              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 20  

1171              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
1172            }
1173            if(++i==8)
1174              i=0;
1175          }
1176          
1177          void time1_int1()
1178          {
1179            EA=1;
1180            ET1=1;
1181            TR1=1;
1182            TMOD=(TMOD&0x0f)|0x10;
1183            TH1=(65535-2000)/256;
1184            TL1=(65535-2000)%256; 
1185          }
1186          
1187          void initial_all()
1188          {
1189            P2=(P2&0x1f)|0xa0;  
1190            P0=0x00;  
1191            P2=(P2&0x1f); 
1192            P2=(P2&0x1f)|0x80;  
1193            P0=0xff;  
1194            P2=(P2&0x1f);   
1195            P2=(P2&0x1f)|0xc0;  
1196            P0=0xff;  
1197            P2=(P2&0x1f);   
1198            P2=(P2&0x1f)|0xe0;  
1199            P0=0xff;  
1200            P2=(P2&0x1f);   
1201          }
1202          void main()
1203          {
1204            uint temp;
1205            initial_all();
1206            time1_int1();
1207            initial_18b20();
1208            while(1)
1209            {
1210             if(f_2ms)
1211             {
1212              f_2ms=0;
1213          
1214               temp=rd_temperature( );
1215               
1216               
1217               
1218               num1=temp/10000; num2=temp%10000/1000;num3=temp%1000/100;num4=temp%100/10;num5=temp%10;
1219               
1220             }//f_2ms;
1221            }
1222          }
1223          
1224          void cl_time1_int1() interrupt 3
1225          {
1226            TH1=(65535-2000)/256;
1227            TL1=(65535-2000)%256; 
1228            f_2ms=1;
1229            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1230            
1231          }
1232          **********/
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 21  

1233          
1234          /********************************************
1235          (7.1)24c02存取数据，上电自动读取存入的数据。连续存入10个数据，利用数组
1236          ********************************************/
1237          /*****************
1238          #include <STC15F2K60S2.H>
1239          #include "iic.h"
1240          #include <intrins.h>
1241          #define uchar unsigned char 
1242          #define uint unsigned int 
1243          uchar code type1[]={0xc0,  
1244                          0xf9,  
1245                          0xa4,   
1246                          0xb0,  
1247                          0x99,  
1248                          0x92,  
1249                          0x82,  
1250                          0xf8,  
1251                          0x80,  
1252                          0x90,0xff};
1253          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1254          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1255          uint t_2ms;
1256          bit f_2ms;
1257          
1258          
1259          
1260          
1261          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1262          {
1263            char i;
1264            P2=(P2&0x1f)|0xc0;
1265            P0=type2[i];
1266            P2=(P2&0x1f);
1267            P0=0xff;
1268            switch(i)
1269            {
1270              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1271              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1272              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1273              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1274              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1275              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1276              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
1277              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
1278            }
1279            if(++i==8)
1280              i=0;
1281          }
1282          //====================================24c02
1283          void xie_24c02(uchar addr,uchar dat)
1284          {
1285            IIC_Start( );
1286            IIC_SendByte(0xa0+0);
1287            IIC_WaitAck( );
1288            IIC_SendByte(addr);
1289            IIC_WaitAck( );
1290            IIC_SendByte(dat);
1291            IIC_WaitAck( ); 
1292            IIC_Stop( );
1293              
1294          }
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 22  

1295          uchar du_24c02(uchar addr)
1296          {
1297            uchar D;
1298            IIC_Start( );
1299            IIC_SendByte(0xa0+0);
1300            IIC_WaitAck( );
1301            IIC_SendByte(addr);
1302            IIC_WaitAck( ); 
1303            
1304            IIC_Start( );
1305            IIC_SendByte(0xa0+1);
1306            IIC_WaitAck( ); 
1307            D=IIC_RecByte( );
1308            IIC_SendAck(1); 
1309            IIC_Stop( );
1310            return D;
1311          }
1312          
1313          void time1_int1()
1314          {
1315            EA=1;
1316            ET1=1;
1317            TR1=1;
1318            TMOD=(TMOD&0x0f)|0x10;
1319            TH1=(65535-2000)/256;
1320            TL1=(65535-2000)%256; 
1321          }
1322          
1323          void initial_all()
1324          {
1325            P2=(P2&0x1f)|0xa0;  
1326            P0=0x00;  
1327            P2=(P2&0x1f); 
1328            P2=(P2&0x1f)|0x80;  
1329            P0=0xff;  
1330            P2=(P2&0x1f);   
1331            P2=(P2&0x1f)|0xc0;  
1332            P0=0xff;  
1333            P2=(P2&0x1f);   
1334            P2=(P2&0x1f)|0xe0;  
1335            P0=0xff;  
1336            P2=(P2&0x1f);   
1337          }
1338          void main()
1339          {
1340            
1341            initial_all();
1342            time1_int1();
1343            xie_24c02( 1 , 1);
1344            while(1)
1345            {
1346             if(f_2ms)
1347             {
1348              f_2ms=0;
1349           
1350              num1=du_24c02(1);num2=10;
1351               
1352             }//f_2ms;
1353            }
1354          }
1355          
1356          void cl_time1_int1() interrupt 3
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 23  

1357          {
1358            TH1=(65535-2000)/256;
1359            TL1=(65535-2000)%256; 
1360            f_2ms=1;
1361            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1362            
1363          }
1364          *****************/
1365          
1366          
1367          /********************************************
1368          (8.1)AD,分别读取电位器与光敏电阻的电压，实验多次读取求取平均值的方法使数据稳定
1369          ********************************************/
1370          /******************
1371          #include <STC15F2K60S2.H>
1372          #include "iic.h"
1373          #include <intrins.h>
1374          #define uchar unsigned char 
1375          #define uint unsigned int 
1376          uchar code type1[]={0xc0,  
1377                          0xf9,  
1378                          0xa4,   
1379                          0xb0,  
1380                          0x99,  
1381                          0x92,  
1382                          0x82,  
1383                          0xf8,  
1384                          0x80,  
1385                          0x90,0xff};
1386          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1387          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1388          uint t_2ms;
1389          bit f_2ms;
1390          
1391          
1392          
1393          
1394          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1395          {
1396            char i;
1397            P2=(P2&0x1f)|0xc0;
1398            P0=type2[i];
1399            P2=(P2&0x1f);
1400            P0=0xff;
1401            switch(i)
1402            {
1403              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1404              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1405              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1406              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1407              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1408              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1409              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
1410              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
1411            }
1412            if(++i==8)
1413              i=0;
1414          }
1415          //=====================================adc
1416          void initial_adc(uchar addr)
1417          {
1418            IIC_Start( );
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 24  

1419            IIC_SendByte(0x90+0);
1420            IIC_WaitAck( );
1421            IIC_SendByte(addr);
1422            IIC_WaitAck( ); 
1423            IIC_Stop( );    
1424          }
1425          uint du_adc()
1426          {
1427            uint D;
1428            IIC_Start( );
1429            IIC_SendByte(0x90+1);
1430            IIC_WaitAck( ); 
1431            D=IIC_RecByte( );
1432            IIC_SendAck(1); 
1433            IIC_Stop( );
1434            D=(D*500.0)/255;
1435            
1436            return D;
1437          }
1438          
1439          void time1_int1()
1440          {
1441            EA=1;
1442            ET1=1;
1443            TR1=1;
1444            TMOD=(TMOD&0x0f)|0x10;
1445            TH1=(65535-2000)/256;
1446            TL1=(65535-2000)%256; 
1447          }
1448          
1449          void initial_all()
1450          {
1451            P2=(P2&0x1f)|0xa0;  
1452            P0=0x00;  
1453            P2=(P2&0x1f); 
1454            P2=(P2&0x1f)|0x80;  
1455            P0=0xff;  
1456            P2=(P2&0x1f);   
1457            P2=(P2&0x1f)|0xc0;  
1458            P0=0xff;  
1459            P2=(P2&0x1f);   
1460            P2=(P2&0x1f)|0xe0;  
1461            P0=0xff;  
1462            P2=(P2&0x1f);   
1463          }
1464          void main()
1465          {
1466            uint temp;
1467            initial_all();
1468            time1_int1();
1469            initial_adc(0x1);
1470            while(1)
1471            {
1472             if(f_2ms)
1473             {
1474              f_2ms=0;
1475          
1476              if(++t_2ms==50)
1477              {
1478                t_2ms=0;
1479                temp=du_adc();
1480               // temp=(temp*3)/3;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 25  

1481              }     
1482           
1483               num1=temp/100;num2=temp%100/10;num3=temp%10;num4=10;
1484               
1485             }//f_2ms;
1486            }
1487          }
1488          
1489          void cl_time1_int1() interrupt 3
1490          {
1491            TH1=(65535-2000)/256;
1492            TL1=(65535-2000)%256; 
1493            f_2ms=1;
1494            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1495            
1496          }
1497          *************/
1498          
1499          /********************************************
1500          (8.2)DA输出，利用通道到0读取回来，进行显示
1501          ********************************************/
1502          /*************
1503          #include <STC15F2K60S2.H>
1504          #include "iic.h"
1505          #include <intrins.h>
1506          #define uchar unsigned char 
1507          #define uint unsigned int 
1508          uchar code type1[]={0xc0,  
1509                          0xf9,  
1510                          0xa4,   
1511                          0xb0,  
1512                          0x99,  
1513                          0x92,  
1514                          0x82,  
1515                          0xf8,  
1516                          0x80,  
1517                          0x90,0xff};
1518          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1519          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1520          uint t_2ms;
1521          bit f_2ms;
1522          
1523          
1524          
1525          
1526          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1527          {
1528            char i;
1529            P2=(P2&0x1f)|0xc0;
1530            P0=type2[i];
1531            P2=(P2&0x1f);
1532            P0=0xff;
1533            switch(i)
1534            {
1535              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1536              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1537              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1538              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1539              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1540              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1541              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
1542              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 26  

1543            }
1544            if(++i==8)
1545              i=0;
1546          }
1547          void initial_adc(uchar addr)
1548          {
1549            IIC_Start( );
1550            IIC_SendByte(0x90+0);
1551            IIC_WaitAck( );
1552            IIC_SendByte(addr);
1553            IIC_WaitAck( ); 
1554            IIC_Stop( );    
1555          }
1556          uint du_adc()
1557          {
1558            uint D;
1559            IIC_Start( );
1560            IIC_SendByte(0x90+1);
1561            IIC_WaitAck( ); 
1562            D=IIC_RecByte( );
1563            IIC_SendAck(1); 
1564            IIC_Stop( );
1565            D=(D*500.0)/255;
1566            
1567            return D;
1568          }
1569          void xie_dac(uchar D)
1570          {
1571            IIC_Start( );
1572            IIC_SendByte(0x90+0);
1573            IIC_WaitAck( );
1574            IIC_SendByte(0x40);
1575            IIC_WaitAck( ); 
1576            IIC_SendByte(D);
1577            IIC_WaitAck( ); 
1578            IIC_Stop( );
1579              
1580          }
1581          uchar change_D(uint D)
1582          {
1583            uint D1;
1584            D1=(D*255.0)/500;
1585            return D1;
1586          }
1587          
1588          void time1_int1()
1589          {
1590            EA=1;
1591            ET1=1;
1592            TR1=1;
1593            TMOD=(TMOD&0x0f)|0x10;
1594            TH1=(65535-2000)/256;
1595            TL1=(65535-2000)%256; 
1596          }
1597          
1598          void initial_all()
1599          {
1600            P2=(P2&0x1f)|0xa0;  
1601            P0=0x00;  
1602            P2=(P2&0x1f); 
1603            P2=(P2&0x1f)|0x80;  
1604            P0=0xff;  
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 27  

1605            P2=(P2&0x1f);   
1606            P2=(P2&0x1f)|0xc0;  
1607            P0=0xff;  
1608            P2=(P2&0x1f);   
1609            P2=(P2&0x1f)|0xe0;  
1610            P0=0xff;  
1611            P2=(P2&0x1f);   
1612          }
1613          void main()
1614          {
1615            char a;
1616            uint temp;
1617            initial_all();
1618            time1_int1();
1619            initial_adc(0x0);
1620            while(1)
1621            {
1622             if(f_2ms)
1623             {
1624              f_2ms=0;
1625              
1626          //    if(a==0)
1627          //    {
1628                xie_dac(change_D(100));
1629          //      a=1;
1630          //    }
1631               
1632               
1633          //    if(++t_2ms==100)
1634          //    {
1635          //      t_2ms=0;
1636          //      initial_adc(0x0);
1637                temp=du_adc();
1638          //    }     
1639              num1=temp/100; num2=temp%100/10;num3=temp%10;
1640               
1641               
1642               
1643             }//f_2ms;
1644            }
1645          }
1646          
1647          void cl_time1_int1() interrupt 3
1648          {
1649            TH1=(65535-2000)/256;
1650            TL1=(65535-2000)%256; 
1651            f_2ms=1;
1652            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1653            
1654          }
1655          
1656          *************************/
1657          
1658          
1659          /********************************************
1660          (9.1)超声波测距
1661          ********************************************/
1662          /*********************
1663          #include <STC15F2K60S2.H>
1664          #include <intrins.h>
1665          #define uchar unsigned char 
1666          #define uint unsigned int 
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 28  

1667          uchar code type1[]={0xc0,  
1668                          0xf9,  
1669                          0xa4,   
1670                          0xb0,  
1671                          0x99,  
1672                          0x92,  
1673                          0x82,  
1674                          0xf8,  
1675                          0x80,  
1676                          0x90,0xff};
1677          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1678          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1679          uint t_2ms;
1680          bit f_2ms;
1681          sbit trig=P1^0;
1682          sbit echo=P1^1;
1683          
1684          
1685          
1686          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1687          {
1688            char i;
1689            P2=(P2&0x1f)|0xc0;
1690            P0=type2[i];
1691            P2=(P2&0x1f);
1692            P0=0xff;
1693            switch(i)
1694            {
1695              case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1696              case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1697              case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1698              case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1699              case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1700              case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1701              case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
1702              case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
1703            }
1704            if(++i==8)
1705              i=0;
1706          }
1707          //===========================================超声波
1708          uchar f_count=10;
1709          uchar csb_send()
1710          {
1711            f_count=10;
1712            trig=0;
1713            TR0=1;
1714            while(f_count--)
1715            {
1716              while(!TF0);
1717              trig ^= 1;
1718              TH0=(65535-12)/256;
1719              TL0=(65535-12)%256;
1720              TF0=0;
1721            }
1722            TR0=0;
1723            TH0=0;
1724            TL0=0;
1725            TR0=1;
1726            while(echo && !TF0);
1727            TR0=0;
1728            
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 29  

1729            if(TF0)
1730            {
1731              TF0=0;
1732              return 99;    
1733            }
1734            else
1735              return ((TH0<<8)+TL0)*0.017;
1736            
1737          }
1738          
1739          void time0()
1740          {
1741            TMOD=(TMOD&0xf0)|0x01;
1742            TH0=(65535-12)/256;
1743            TL0=(65535-12)%256; 
1744          }
1745          void time1_int1()
1746          {
1747            EA=1;
1748            ET1=1;
1749            TR1=1;
1750            TMOD=(TMOD&0x0f)|0x10;
1751            TH1=(65535-2000)/256;
1752            TL1=(65535-2000)%256; 
1753          }
1754          
1755          void initial_all()
1756          {
1757            P2=(P2&0x1f)|0xa0;  
1758            P0=0x00;  
1759            P2=(P2&0x1f); 
1760            P2=(P2&0x1f)|0x80;  
1761            P0=0xff;  
1762            P2=(P2&0x1f);   
1763            P2=(P2&0x1f)|0xc0;  
1764            P0=0xff;  
1765            P2=(P2&0x1f);   
1766            P2=(P2&0x1f)|0xe0;  
1767            P0=0xff;  
1768            P2=(P2&0x1f);   
1769          }
1770          void main()
1771          {
1772            uint temp;
1773            initial_all();
1774            time1_int1();
1775            time0();
1776            while(1)
1777            {
1778             if(f_2ms)
1779             {
1780              f_2ms=0;
1781              temp=csb_send();
1782          
1783              num1=temp/10; num2=temp%10;num3=10; 
1784             }//f_2ms;
1785            }
1786          }
1787          
1788          void cl_time1_int1() interrupt 3
1789          {
1790            TH1=(65535-2000)/256;
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 30  

1791            TL1=(65535-2000)%256; 
1792            f_2ms=1;
1793            smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1794            
1795          }
1796          
1797          ************************/
1798          
1799          /********************************************
1800          (10.1)串口发送数据与接受数据（参考第十届的题）
1801          ********************************************/
1802          
1803          #include <STC15F2K60S2.H>
1804          #include <intrins.h>
1805          #include <stdio.h>
1806          #include <string.h>
1807          
1808          #define uchar unsigned char 
1809          #define uint unsigned int 
1810          uchar code type1[]={0xc0,  
1811                          0xf9,  
1812                          0xa4,   
1813                          0xb0,  
1814                          0x99,  
1815                          0x92,  
1816                          0x82,  
1817                          0xf8,  
1818                          0x80,  
1819                          0x90,0xff};
1820          uchar code type2[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
1821          uchar num1,num2,num3,num4,num5,num6,num7,num8;
1822          uint t_2ms;
1823          bit f_2ms;
1824          
1825          
1826          
1827          
1828          void smg_display(char n1,char n2,char n3,char n4,char n5,char n6,char n7,char n8)
1829          {
1830   1        char i;
1831   1        P2=(P2&0x1f)|0xc0;
1832   1        P0=type2[i];
1833   1        P2=(P2&0x1f);
1834   1        P0=0xff;
1835   1        switch(i)
1836   1        {
1837   2          case 0:P2=(P2&0x1f)|0xe0;P0=type1[n1];P2=(P2&0x1f);break;
1838   2          case 1:P2=(P2&0x1f)|0xe0;P0=type1[n2];P2=(P2&0x1f);break;
1839   2          case 2:P2=(P2&0x1f)|0xe0;P0=type1[n3];P2=(P2&0x1f);break;
1840   2          case 3:P2=(P2&0x1f)|0xe0;P0=type1[n4];P2=(P2&0x1f);break;
1841   2          case 4:P2=(P2&0x1f)|0xe0;P0=type1[n5];P2=(P2&0x1f);break;
1842   2          case 5:P2=(P2&0x1f)|0xe0;P0=type1[n6];P2=(P2&0x1f);break;
1843   2          case 6:P2=(P2&0x1f)|0xe0;P0=type1[n7];P2=(P2&0x1f);break;
1844   2          case 7:P2=(P2&0x1f)|0xe0;P0=type1[n8];P2=(P2&0x1f);break;       
1845   2        }
1846   1        if(++i==8)
1847   1          i=0;
1848   1      }
1849          //===================================串口发送
1850          uchar busy;
1851          void send_byte(uchar *dat,uchar len)
1852          {
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 31  

1853   1        while(len--)
1854   1        {
1855   2          SBUF=*dat;
1856   2          busy=1;
1857   2          dat++;
1858   2          while(busy);  
1859   2        } 
1860   1      }
1861          
1862          void UartInit(void)   //4800bps@12.000MHz
1863          {
1864   1        SCON = 0x50;    //8位数据,可变波特率
1865   1        AUXR |= 0x01;   //串口1选择定时器2为波特率发生器
1866   1        AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
1867   1        T2L = 0x8F;   //设定定时初值
1868   1        T2H = 0xFD;   //设定定时初值
1869   1        AUXR |= 0x10;   //启动定时器2
1870   1        
1871   1        ES=1;
1872   1      }
1873          
1874          
1875          void time1_int1()
1876          {
1877   1        EA=1;
1878   1        ET1=1;
1879   1        TR1=1;
1880   1        TMOD=(TMOD&0x0f)|0x10;
1881   1        TH1=(65535-2000)/256;
1882   1        TL1=(65535-2000)%256; 
1883   1      }
1884          
1885          void initial_all()
1886          {
1887   1        P2=(P2&0x1f)|0xa0;  
1888   1        P0=0x00;  
1889   1        P2=(P2&0x1f); 
1890   1        P2=(P2&0x1f)|0x80;  
1891   1        P0=0xff;  
1892   1        P2=(P2&0x1f);   
1893   1        P2=(P2&0x1f)|0xc0;  
1894   1        P0=0xff;  
1895   1        P2=(P2&0x1f);   
1896   1        P2=(P2&0x1f)|0xe0;  
1897   1        P0=0xff;  
1898   1        P2=(P2&0x1f);   
1899   1      }
1900            uchar p1;
1901            uchar p2;
1902            uchar pass_word1[]="wy";
1903            uchar pass_word2[]="zcl";
1904            uchar type3[]="chang zhou gong xue yuan di yi shuai\r\n";
1905            uchar idata str1[40];
1906            uchar idata str2[40];
1907            uint a=12;
1908          void main()
1909          {
1910   1      
1911   1        initial_all();
1912   1        time1_int1();
1913   1      
1914   1         UartInit( );
C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 32  

1915   1        while(1)
1916   1        {
1917   2         if(f_2ms)
1918   2         {
1919   3          f_2ms=0;
1920   3            if(p1>=2)
1921   3            {
1922   4              p1=0;
1923   4              sprintf (str1,"nv pen you %d \r\n", a);
1924   4              send_byte(str1,strlen  (str1));
1925   4            }
1926   3            if(p2>=3)
1927   3            {
1928   4              p2=0;
1929   4              sprintf (str2,"nan pen you %d \r\n", ++a);
1930   4              send_byte(str2,strlen  (str2));
1931   4            }    
1932   3           
1933   3           
1934   3           
1935   3         }//f_2ms;
1936   2        }
1937   1      }
1938          
1939          void cl_time1_int1() interrupt 3
1940          {
1941   1        TH1=(65535-2000)/256;
1942   1        TL1=(65535-2000)%256; 
1943   1        f_2ms=1;
1944   1        smg_display(num1,num2,num3,num4,num5,num6,num7,num8);
1945   1        
1946   1      }
1947          void cl_UartInit( )  interrupt 4
1948          {
1949   1        if(RI)
1950   1        {
1951   2          RI=0;
1952   2          if(pass_word1[p1]==SBUF)
1953   2            p1++;
1954   2          else
1955   2            p1=0;
1956   2      //----------------------
1957   2          if(pass_word2[p2]==SBUF)
1958   2            p2++;
1959   2          else
1960   2            p2=0;   
1961   2        }
1962   1        if(TI)
1963   1        {
1964   2          TI=0;
1965   2          busy=0; 
1966   2        }
1967   1        
1968   1        
1969   1        
1970   1        
1971   1      }
1972          
1973          
1974          


C51 COMPILER V9.55   MAIN                                                                  06/17/2022 21:40:28 PAGE 33  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    595    ----
   CONSTANT SIZE    =     54    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     61       9
   IDATA SIZE       =     80    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
