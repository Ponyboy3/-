C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          #define uchar unsigned char 
   4          #define uint unsigned int
   5          
   6          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   7          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
   8          // xxx
   9          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  10          
  11          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  12          uchar GN;  // 按键标志位
  13          bit f_2ms, f_50ms;  // 2ms, 50ms标志位
  14          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  15          
  16          sbit S7 = P3^0;
  17          sbit S6 = P3^1;
  18          sbit S5 = P3^2;
  19          sbit S4 = P3^3;
  20          
  21          sbit L0 = P0^0;
  22          sbit L1 = P0^1;
  23          sbit L2 = P0^2;
  24          sbit L3 = P0^3;
  25          sbit L4 = P0^4;
  26          sbit L5 = P0^5;
  27          sbit L6 = P0^6;
  28          
  29          // =========================================== 代码开始 ======================================
  30          bit f_1s;  // 1s标志位
  31          
  32          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  33          // =========================================== 代码结束 ======================================
  34          uchar k_mode = 0;
  35          
  36          //=========================================普通延时函数(模板函数)=================================
  37          void Delay(uint t) {
  38   1              while( t -- );
  39   1              while( t -- );
  40   1      }
  41          //=======================================单个LED控制函数(模板函数)================================
  42          // 根据项目需要删减
  43          
  44          // ======================LED0====================
  45          void LED0_On() {
  46   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  47   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  48   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  49   1              temp_Led_P0 = P0;
  50   1              P2 &= 0x1f;
  51   1      }
  52          void LED0_Off() {
  53   1              P0 = 0xff & temp_Led_P0;
  54   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 2   

  55   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  56   1              temp_Led_P0 = P0;
  57   1              P2 &= 0x1f;
  58   1      }
  59          // ======================LED1====================
  60          void LED1_On() {
  61   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  62   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  63   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  64   1              temp_Led_P0 = P0;
  65   1              P2 &= 0x1f;
  66   1      }
  67          void LED1_Off() {
  68   1              P0 = 0xff & temp_Led_P0;
  69   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  70   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  71   1              temp_Led_P0 = P0;
  72   1              P2 &= 0x1f;
  73   1      }
  74          // ======================LED2====================
  75          void LED2_On() {
  76   1              P0 = 0xff & temp_Led_P0;
  77   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  78   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  79   1              temp_Led_P0 = P0;
  80   1              P2 &= 0x1f;
  81   1      }
  82          void LED2_Off() {
  83   1              P0 = 0xff & temp_Led_P0;
  84   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  85   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  86   1              temp_Led_P0 = P0;
  87   1              P2 &= 0x1f;
  88   1      }
  89          // ======================LED3====================
  90          void LED3_On() {
  91   1              P0 = 0xff & temp_Led_P0;
  92   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  93   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
  94   1              temp_Led_P0 = P0;
  95   1              P2 &= 0x1f;
  96   1      }
  97          void LED3_Off() {
  98   1              P0 = 0xff & temp_Led_P0;
  99   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 100   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 101   1              temp_Led_P0 = P0;
 102   1              P2 &= 0x1f;
 103   1      }
 104          // ======================LED4====================
 105          void LED4_On() {
 106   1              P0 = 0xff & temp_Led_P0;
 107   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 108   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 109   1              temp_Led_P0 = P0;
 110   1              P2 &= 0x1f;
 111   1      }
 112          void LED4_Off() {
 113   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 114   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 115   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 116   1              temp_Led_P0 = P0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 3   

 117   1              P2 &= 0x1f;
 118   1      }
 119          // ======================LED5====================
 120          void LED5_On() {
 121   1              P0 = 0xff & temp_Led_P0;
 122   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 123   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 124   1              temp_Led_P0 = P0;
 125   1              P2 &= 0x1f;
 126   1      }
 127          void LED5_Off() {
 128   1              P0 = 0xff & temp_Led_P0;
 129   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 130   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 131   1              temp_Led_P0 = P0;
 132   1              P2 &= 0x1f;
 133   1      }
 134          // ======================LED6====================
 135          void LED6_On() {
 136   1              P0 = 0xff & temp_Led_P0;
 137   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 138   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 139   1              temp_Led_P0 = P0;
 140   1              P2 &= 0x1f;
 141   1      }
 142          void LED6_Off() {
 143   1              P0 = 0xff & temp_Led_P0;
 144   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 145   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 146   1              temp_Led_P0 = P0;
 147   1              P2 &= 0x1f;
 148   1      }
 149          
 150          void LED_On(uchar n) {
 151   1              P0 = 0xff & temp_Led_P0;
 152   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 153   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 154   1              temp_Led_P0 = P0;
 155   1              P2 &= 0x1f;
 156   1      }
*** WARNING C280 IN LINE 150 OF main.c: 'n': unreferenced local variable
 157          //=========================================数码管显示==============================================
 158          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 159          {
 160   1              char i;
 161   1              P0 = 0xff;
 162   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 163   1              P0 = type2[i];
 164   1              P2 &= 0x1f;
 165   1              switch(i)//数码管位选
 166   1              {
 167   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 168   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 169   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 170   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 171   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 172   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 173   2                                                                              if(0)  // 根据需要的条件
 174   2                                                                              {
 175   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 176   3                                                                              }
 177   2                                                                              else
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 4   

 178   2                                                                                      P0 = type1[n6];
 179   2                                                                                                        P2 &= 0x1f;break;
 180   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 181   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 182   2              }
 183   1              if(++i==8)
 184   1                      i = 0;
 185   1      }
 186          //============================================独立按键============================================
 187          /***************************************************
 188          写法一：
 189          有按键被按下，GN标记，后面根据需要功能进行操作
 190          ***************************************************/
 191          void Delay_Keys(uint t)
 192          {
 193   1              while(t--);
 194   1      }
 195          uchar Scan_Keys_Alone()
 196          {
 197   1              char d;
 198   1              d = (~P3) & 0x0f;
 199   1              if(d == 0) return 0;
 200   1              Delay_Keys(100);
 201   1              if(d == 0) return 0;
 202   1              Delay_Keys(100);
 203   1              return d;
 204   1      }
 205          void Change_Keys_Alone()
 206          {
 207   1              switch(Scan_Keys_Alone())
 208   1              {
 209   2                      case 8:GN = 1;break;//S4
 210   2                      case 4:GN = 2;break;//S5
 211   2                      case 2:GN = 3;break;//S6
 212   2                      case 1:GN = 4;break;//S7
 213   2                      case 0:GN = 0;break;
 214   2              }
 215   1      }
 216          
 217          /***************************************************
 218          写法二：
 219          有按键被按下，按下是一种状态，松开是另一种状态
 220          （如：按下时某个灯亮，松开时灯灭）
 221          ***************************************************/
 222          void ScanKeys_Alone() 
 223          {
 224   1              if (S7 == 0) {
 225   2                      Delay_Keys(100);
 226   2                      if (S7 == 0) {
 227   3                              // =========================================== 代码开始 ======================================
 228   3                              
 229   3                              // =========================================== 代码结束 ======================================
 230   3                              while(S7 == 0);
 231   3                              // =========================================== 代码开始 ======================================
 232   3      //                      k_mode ++ ;
 233   3      //                      if (k_mode == 4) k_mode = 0;
 234   3                              // =========================================== 代码结束 ======================================
 235   3                      }
 236   2              }
 237   1              
 238   1              if (S6 == 0) {
 239   2                      Delay_Keys(100);
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 5   

 240   2                      if (S6 == 0) {
 241   3                              // =========================================== 代码开始 ======================================
 242   3                              
 243   3                              // =========================================== 代码结束 ======================================
 244   3                              while(S6 == 0);
 245   3                              // =========================================== 代码开始 ======================================
 246   3      
 247   3                              // =========================================== 代码结束 ======================================
 248   3                      }
 249   2              }
 250   1              
 251   1              if (S5 == 0) {
 252   2                      Delay_Keys(100);
 253   2                      if (S5 == 0) {
 254   3                              // =========================================== 代码开始 ======================================
 255   3      
 256   3                              // =========================================== 代码结束 ======================================
 257   3                              while(S5 == 0);
 258   3                              // =========================================== 代码开始 ======================================
 259   3      
 260   3                              // =========================================== 代码结束 ======================================
 261   3                      }
 262   2              }
 263   1      
 264   1              if (S4 == 0) {
 265   2                      Delay_Keys(100);
 266   2                      if (S4 == 0) {
 267   3                              // =========================================== 代码开始 ======================================
 268   3      
 269   3                              // =========================================== 代码结束 ======================================
 270   3                              while(S4 == 0);
 271   3                              // =========================================== 代码开始 ======================================
 272   3      
 273   3                              // =========================================== 代码结束 ======================================
 274   3                      }
 275   2              }
 276   1      }
 277          
 278          // ================= 代码结束 =============
 279          
 280          //============================================矩阵按键============================================
 281          sfr P4 = 0xc0;
 282          sbit P44 = P4^4;
 283          sbit P42 = P4^2;
 284          
 285          uchar Scan_Keys()
 286          {
 287   1              char H,L;
 288   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 289   1              if(H == 0) return 0;
 290   1              Delay_Keys(100);
 291   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 292   1              if(H == 0) return 0;
 293   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 294   1              if(P44 == 0) L |= 0x80;
 295   1              if(P42 == 0) L |= 0x40;
 296   1              return (H+L);
 297   1      }
 298          
 299          void Change_Keys()
 300          {
 301   1              switch(Scan_Keys())
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 6   

 302   1              {
 303   2                      case 0x88:GN = 4;break;  // S4
 304   2                      case 0x84:GN = 5;break;  // S5
 305   2                      case 0x82:GN = 6;break;  // S6
 306   2                      case 0x81:GN = 7;break;  // S7
 307   2                      case 0x48:GN = 8;break;  // S8
 308   2                      case 0x44:GN = 9;break;  // S9
 309   2                      case 0x42:GN = 10;break;  // S10
 310   2                      case 0x41:GN = 11;break;  // S11
 311   2                      case 0x28:GN = 12;break;  // S12
 312   2                      case 0x24:GN = 13;break;  // S13
 313   2                      case 0x22:GN = 14;break;  // S14
 314   2                      case 0x21:GN = 15;break;  // S15
 315   2                      case 0x18:GN = 16;break;  // S16
 316   2                      case 0x14:GN = 17;break;  // S17
 317   2                      case 0x12:GN = 18;break;  // S18
 318   2                      case 0x11:GN = 19;break;  // S19
 319   2                      case 0:GN = 0;break;
 320   2              }
 321   1      }
 322          //============================================定时器T0初始化=======================================
 323          uchar count = 0;
 324          uchar pwm_dut = 0;//占空比
 325          void Init_T0()
 326          {
 327   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 328   1              TH0 = (65536 - 100) / 256;  // 50ms
 329   1              TL0 = (65536 - 100) % 256; 
 330   1              
 331   1              EA = 1;
 332   1              ET0 = 1;
 333   1      //      TR0 = 1;
 334   1      }
 335          //============================================定时器T1初始化=======================================
 336          void Init_T1()
 337          {
 338   1              TMOD = (TMOD & 0x0f) | 0x10;//定时
 339   1              TH1 = (65536 - 2000) / 256;//2ms
 340   1              TL1 = (65536 - 2000) % 256;
 341   1              
 342   1              EA = 1;
 343   1              ET1 = 1;
 344   1              TR1 = 1;
 345   1      }
 346          //==========================================系统初始化=============================================
 347          void Init_Sys()
 348          {
 349   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 350   1              P0 = 0xff;
 351   1              P2 &= 0x1f;
 352   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 353   1              P0 = 0x00;
 354   1              P2 &= 0x1f;
 355   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 356   1              P0 = 0xff;
 357   1              P2 &= 0x1f;
 358   1              P2 = (P2 & 0x1f) | 0xe0;
 359   1              P0 = 0xff;
 360   1              
 361   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 362   1      }
 363          
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 7   

 364          void LED_control() {
 365   1              // ================= 测试开始 =============
 366   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 367   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 368   1      //      P2 &= 0x1f;
 369   1              // ================= 测试结束 =============
 370   1              
 371   1              // =========================================== 代码开始 ======================================
 372   1              
 373   1              // =========================================== 代码结束 ======================================
 374   1      }
 375          
 376          void main()
 377          {
 378   1              Init_Sys();
 379   1              Init_T1();
 380   1              Init_T0();
 381   1              
 382   1              while(1)
 383   1              {
 384   2      //              LED_control();
 385   2              if(f_2ms == 1)
 386   2              {
 387   3                  f_2ms = 0;                  
 388   3                              LED_control();  // xxx
 389   3                              // =======================按键开始========================
 390   3                              /*根据需要选择对应的按键类型*/
 391   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 392   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 393   3                              Change_Keys();        // 3.矩阵按键扫描
 394   3                              if (GN == 16) {  // S16
 395   4                                      // =========================================== 代码开始 ======================================
 396   4                                      LED1_On();
 397   4                                      // =========================================== 代码结束 ======================================
 398   4                                      while(Scan_Keys());
 399   4                                      // =========================================== 代码开始 ======================================
 400   4                                      LED1_Off();
 401   4                                      // =========================================== 代码结束 ======================================
 402   4                              }
 403   3                              
 404   3                              if (GN == 7) {  // S7
 405   4                                      // =========================================== 代码开始 ======================================
 406   4      //                              LED1_On();
 407   4                                      // =========================================== 代码结束 ======================================
 408   4                                      while(Scan_Keys());
 409   4                                      // =========================================== 代码开始 ======================================
 410   4                                      k_mode ++ ;
 411   4                                      if (k_mode == 4) k_mode = 0;
 412   4                                      // =========================================== 代码结束 ======================================
 413   4                              }
 414   3                              // 根据需要添加对应按键
 415   3                              // =======================按键结束========================
 416   3                              
 417   3                              // =========================================== 代码开始 ======================================
 418   3                              if  (k_mode == 0) {
 419   4                                      TR0 = 0;
 420   4                                      LED0_Off();
 421   4                              }
 422   3                              else if (k_mode == 1) {
 423   4                                      TR0 = 1;
 424   4                                      pwm_dut = 10;
 425   4                              }
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 8   

 426   3                              else if (k_mode == 2) {
 427   4                                      pwm_dut = 50;
 428   4                              }
 429   3                              else if (k_mode == 3) {
 430   4                                      pwm_dut = 90;
 431   4                              }
 432   3                              // =========================================== 代码结束 ======================================
 433   3              }
 434   2          }
 435   1      }
 436          
 437          void Service_T0() interrupt 1
 438          {
 439   1              TH0 = (65536 - 100) / 256;
 440   1              TL0 = (65536 - 100) % 256;
 441   1              
 442   1              count++;
 443   1              if(count <= pwm_dut)
 444   1              {
 445   2                      LED0_On();
 446   2              }
 447   1              else if(count < 100)
 448   1              {
 449   2                      LED0_Off();
 450   2              }
 451   1              else if(count == 100)
 452   1              {
 453   2                      LED0_On();;
 454   2                      count = 0;
 455   2              }
 456   1      }
 457          
 458          void Service_T1() interrupt 3
 459          {
 460   1              TH1 = (65536 - 2000) / 256;
 461   1              TL1 = (65536 - 2000) % 256;
 462   1              
 463   1              f_2ms = 1;
 464   1              
 465   1              /***************************************************
 466   1              与时间相关的变量的更新放在里面
 467   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 468   1              ***************************************************/
 469   1              // =========================================== 代码开始 ======================================
 470   1              num_2ms ++ ;
 471   1              if (num_2ms == 500) {
 472   2                      f_1s = 1;
 473   2                      num_2ms = 0;
 474   2              }
 475   1              if (f_1s == 1) {
 476   2                      f_1s = 0;
 477   2                      num_s ++ ;
 478   2                      if (num_s == 10) 
 479   2                      num_s = 0;
 480   2              }
 481   1              num1 = 2;num2 = 0; num3 = 2; num4 = k_mode;
 482   1              num5=num6=11;
 483   1              num7=num_s / 10, num8=num_s % 10;
 484   1              // =========================================== 代码结束 ======================================
 485   1              
 486   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 487   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 22:59:26 PAGE 9   

*** WARNING C294 IN LINE 175 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1298    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
