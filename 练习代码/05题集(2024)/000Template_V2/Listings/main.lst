C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          #define uchar unsigned char 
   4          #define uint unsigned int
   5          
   6          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   7          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
   8          // xxx
   9          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  10          
  11          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  12          uchar GN;  // 按键标志位
  13          bit f_2ms;  // 2ms标志位
  14          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  15          
  16          sbit S7 = P3^0;
  17          sbit S6 = P3^1;
  18          sbit S5 = P3^2;
  19          sbit S4 = P3^3;
  20          
  21          sbit L1 = P0^0;
  22          sbit L2 = P0^1;
  23          sbit L3 = P0^2;
  24          sbit L4 = P0^3;
  25          sbit L5 = P0^4;
  26          sbit L6 = P0^5;
  27          
  28          bit f_1s, f_10ms;  // 1s标志位
  29          
  30          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  31          
  32          uint num_2ms_ne555=0, freq;
  33          // =========================================== 代码开始 ======================================
  34          
  35          
  36          // =========================================== 代码结束 ======================================
  37          
  38          
  39          //=========================================普通延时函数(模板函数)=================================
  40          void Delay(uint t) {
  41   1              while( t -- );
  42   1              while( t -- );
  43   1      }
  44          //=======================================单个LED控制函数(模板函数)================================
  45          // ======================LED1====================
  46          void LED1_On() {
  47   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  48   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  49   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  50   1              temp_Led_P0 = P0;
  51   1              P2 &= 0x1f;
  52   1      }
  53          void LED1_Off() {
  54   1              P0 = 0xff & temp_Led_P0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 2   

  55   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  56   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  57   1              temp_Led_P0 = P0;
  58   1              P2 &= 0x1f;
  59   1      }
  60          // ======================LED2====================
  61          void LED2_On() {
  62   1              P0 = 0xff & temp_Led_P0;
  63   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  64   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  65   1              temp_Led_P0 = P0;
  66   1              P2 &= 0x1f;
  67   1      }
  68          void LED2_Off() {
  69   1              P0 = 0xff & temp_Led_P0;
  70   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  71   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  72   1              temp_Led_P0 = P0;
  73   1              P2 &= 0x1f;
  74   1      }
  75          // ======================LED3====================
  76          void LED3_On() {
  77   1              P0 = 0xff & temp_Led_P0;
  78   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  79   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
  80   1              temp_Led_P0 = P0;
  81   1              P2 &= 0x1f;
  82   1      }
  83          void LED3_Off() {
  84   1              P0 = 0xff & temp_Led_P0;
  85   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  86   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
  87   1              temp_Led_P0 = P0;
  88   1              P2 &= 0x1f;
  89   1      }
  90          // ======================LED4====================
  91          void LED4_On() {
  92   1              P0 = 0xff & temp_Led_P0;
  93   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  94   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
  95   1              temp_Led_P0 = P0;
  96   1              P2 &= 0x1f;
  97   1      }
  98          void LED4_Off() {
  99   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 100   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 101   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 102   1              temp_Led_P0 = P0;
 103   1              P2 &= 0x1f;
 104   1      }
 105          // ======================LED5====================
 106          void LED5_On() {
 107   1              P0 = 0xff & temp_Led_P0;
 108   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 109   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 110   1              temp_Led_P0 = P0;
 111   1              P2 &= 0x1f;
 112   1      }
 113          void LED5_Off() {
 114   1              P0 = 0xff & temp_Led_P0;
 115   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 116   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 3   

 117   1              temp_Led_P0 = P0;
 118   1              P2 &= 0x1f;
 119   1      }
 120          // ======================LED6====================
 121          void LED6_On() {
 122   1              P0 = 0xff & temp_Led_P0;
 123   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 124   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 125   1              temp_Led_P0 = P0;
 126   1              P2 &= 0x1f;
 127   1      }
 128          void LED6_Off() {
 129   1              P0 = 0xff & temp_Led_P0;
 130   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 131   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 132   1              temp_Led_P0 = P0;
 133   1              P2 &= 0x1f;
 134   1      }
 135          
 136          void LED_On(uchar n) {
 137   1              P0 = 0xff & temp_Led_P0;
 138   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 139   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 140   1              temp_Led_P0 = P0;
 141   1              P2 &= 0x1f;
 142   1      }
*** WARNING C280 IN LINE 136 OF main.c: 'n': unreferenced local variable
 143          //=========================================数码管显示==============================================
 144          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 145          {
 146   1              char i;
 147   1              P0 = 0xff;
 148   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 149   1              P0 = type2[i];
 150   1              P2 &= 0x1f;
 151   1              switch(i)//数码管位选
 152   1              {
 153   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 154   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 155   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 156   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 157   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 158   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 159   2                                                                              if(0)  // 根据需要的条件
 160   2                                                                              {
 161   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 162   3                                                                              }
 163   2                                                                              else
 164   2                                                                                      P0 = type1[n6];
 165   2                                                                                                        P2 &= 0x1f;break;
 166   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 167   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 168   2              }
 169   1              if(++i==8)
 170   1                      i = 0;
 171   1      }
 172          //============================================独立按键============================================
 173          /***************************************************
 174          写法一：
 175          有按键被按下，GN标记，后面根据需要功能进行操作
 176          ***************************************************/
 177          void Delay_Keys(uint t)
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 4   

 178          {
 179   1              while(t--);
 180   1      }
 181          uchar Scan_Keys_Alone()
 182          {
 183   1              char d;
 184   1              d = (~P3) & 0x0f;
 185   1              if(d == 0) return 0;
 186   1              Delay_Keys(100);
 187   1              if(d == 0) return 0;
 188   1              Delay_Keys(100);
 189   1              return d;
 190   1      }
 191          void Change_Keys_Alone()
 192          {
 193   1              switch(Scan_Keys_Alone())
 194   1              {
 195   2                      case 8:GN = 1;break;//S4
 196   2                      case 4:GN = 2;break;//S5
 197   2                      case 2:GN = 3;break;//S6
 198   2                      case 1:GN = 4;break;//S7
 199   2                      case 0:GN = 0;break;
 200   2              }
 201   1      }
 202          
 203          /***************************************************
 204          写法二：
 205          有按键被按下，按下是一种状态，松开是另一种状态
 206          （如：按下时某个灯亮，松开时灯灭）
 207          ***************************************************/
 208          void ScanKeys_Alone() 
 209          {
 210   1              if (S7 == 0) {
 211   2                      Delay_Keys(100);
 212   2                      if (S7 == 0) {
 213   3                              // =========================================== 代码开始 ======================================
 214   3                              
 215   3                              // =========================================== 代码结束 ======================================
 216   3                              while(S7 == 0);
 217   3                              // =========================================== 代码开始 ======================================
 218   3      
 219   3                              // =========================================== 代码结束 ======================================
 220   3                      }
 221   2              }
 222   1              
 223   1              if (S6 == 0) {
 224   2                      Delay_Keys(100);
 225   2                      if (S6 == 0) {
 226   3                              // =========================================== 代码开始 ======================================
 227   3                              
 228   3                              // =========================================== 代码结束 ======================================
 229   3                              while(S6 == 0);
 230   3                              // =========================================== 代码开始 ======================================
 231   3      
 232   3                              // =========================================== 代码结束 ======================================
 233   3                      }
 234   2              }
 235   1              
 236   1              if (S5 == 0) {
 237   2                      Delay_Keys(100);
 238   2                      if (S5 == 0) {
 239   3                              // =========================================== 代码开始 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 5   

 240   3      
 241   3                              // =========================================== 代码结束 ======================================
 242   3                              while(S5 == 0);
 243   3                              // =========================================== 代码开始 ======================================
 244   3      
 245   3                              // =========================================== 代码结束 ======================================
 246   3                      }
 247   2              }
 248   1      
 249   1              if (S4 == 0) {
 250   2                      Delay_Keys(100);
 251   2                      if (S4 == 0) {
 252   3                              // =========================================== 代码开始 ======================================
 253   3      
 254   3                              // =========================================== 代码结束 ======================================
 255   3                              while(S4 == 0);
 256   3                              // =========================================== 代码开始 ======================================
 257   3      
 258   3                              // =========================================== 代码结束 ======================================
 259   3                      }
 260   2              }
 261   1      }
 262          
 263          // ================= 代码结束 =============
 264          
 265          //============================================矩阵按键============================================
 266          sfr P4 = 0xc0;
 267          sbit P44 = P4^4;
 268          sbit P42 = P4^2;
 269          
 270          uchar Scan_Keys()
 271          {
 272   1              char H,L;
 273   1              
 274   1      //      TR0 = 0;
 275   1              
 276   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 277   1              if(H == 0) return 0;
 278   1              Delay_Keys(100);
 279   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 280   1              if(H == 0) return 0;
 281   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 282   1              if(P44 == 0) L |= 0x80;
 283   1              if(P42 == 0) L |= 0x40;
 284   1              
 285   1      //      TR0 = 1;
 286   1              
 287   1              return (H+L);
 288   1      }
 289          
 290          void Change_Keys()
 291          {
 292   1              switch(Scan_Keys())
 293   1              {
 294   2                      case 0x88:GN = 4;break;  // S4
 295   2                      case 0x84:GN = 5;break;  // S5
 296   2                      case 0x82:GN = 6;break;  // S6
 297   2                      case 0x81:GN = 7;break;  // S7
 298   2                      case 0x48:GN = 8;break;  // S8
 299   2                      case 0x44:GN = 9;break;  // S9
 300   2                      case 0x42:GN = 10;break;  // S10
 301   2                      case 0x41:GN = 11;break;  // S11
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 6   

 302   2                      case 0x28:GN = 12;break;  // S12
 303   2                      case 0x24:GN = 13;break;  // S13
 304   2                      case 0x22:GN = 14;break;  // S14
 305   2                      case 0x21:GN = 15;break;  // S15
 306   2                      case 0x18:GN = 16;break;  // S16
 307   2                      case 0x14:GN = 17;break;  // S17
 308   2                      case 0x12:GN = 18;break;  // S18
 309   2                      case 0x11:GN = 19;break;  // S19
 310   2                      case 0:GN = 0;break;
 311   2              }
 312   1      }
 313          
 314          sbit P32 = P3^2;
 315          sbit P33 = P3^3;
 316          void key_array_init() {
 317   1              P32 = 1;
 318   1              P33 = 1;
 319   1              P42 = 0;
 320   1              P44 = 0;
 321   1      }
 322          
 323          void key_array_scan() {
 324   1              if (P32 == 0) {
 325   2                      P32 = 0;
 326   2                      P42 = 1;
 327   2                      P44 = 1;
 328   2                      if (P42 == 0) {
 329   3                              Delay_Keys(100);
 330   3                              if (P42 == 0) {  // S9
 331   4                                      // =========================================== 代码开始 ======================================
 332   4                                      
 333   4                                      // =========================================== 代码结束 ======================================
 334   4                                      while (P42 == 0);
 335   4                                      // =========================================== 代码开始 ======================================
 336   4                                      num1 = 9;
 337   4                                      // =========================================== 代码结束 ======================================
 338   4                              }
 339   3                      }
 340   2                      else if (P44 == 0) {
 341   3                              Delay_Keys(100);
 342   3                              if (P44 == 0) {  // S5
 343   4                                      // =========================================== 代码开始 ======================================
 344   4                                      
 345   4                                      // =========================================== 代码结束 ======================================
 346   4                                      while (P44 == 0);
 347   4                                      // =========================================== 代码开始 ======================================
 348   4                                      num1 = 5;
 349   4                                      // =========================================== 代码结束 ======================================
 350   4                              }
 351   3                      }
 352   2              }
 353   1              
 354   1              if (P33 == 0) {
 355   2                      P33 = 0;
 356   2                      P42 = 1;
 357   2                      P44 = 1;
 358   2                      if (P42 == 0) {
 359   3                              Delay_Keys(100);
 360   3                              if (P42 == 0) {  // S8
 361   4                                      // =========================================== 代码开始 ======================================
 362   4      
 363   4                                      // =========================================== 代码结束 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 7   

 364   4                                      while (P42 == 0);
 365   4                                      // =========================================== 代码开始 ======================================
 366   4                                      num1 = 8;
 367   4                                      // =========================================== 代码结束 ======================================
 368   4                              }
 369   3                      }
 370   2                      else if (P44 == 0) {
 371   3                              Delay_Keys(100);
 372   3                              if (P44 == 0) {  // S4
 373   4                                      // =========================================== 代码开始 ======================================
 374   4                                      
 375   4                                      // =========================================== 代码结束 ======================================
 376   4                                      while(P44 == 0);
 377   4                                      // =========================================== 代码开始 ======================================
 378   4                                      num1 = 4;
 379   4                                      // =========================================== 代码结束 ======================================
 380   4                              }
 381   3                      }
 382   2              }
 383   1              
 384   1              key_array_init();
 385   1      }
 386          
 387          //============================================定时器T1初始化=======================================
 388          void Init_T1()
 389          {
 390   1              TMOD = (TMOD & 0xf0) | 0x10;//定时
 391   1              TH1 = (65536 - 2000) / 256;//2ms
 392   1              TL1 = (65536 - 2000) % 256;
 393   1              
 394   1              EA = 1;
 395   1              ET1 = 1;
 396   1              TR1 = 1;
 397   1      }
 398          //============================================定时器T0初始化=======================================
 399          void Init_T0()
 400          {
 401   1              TMOD = (TMOD & 0xf0) | 0x05;//定时
 402   1              TH0 = 0;
 403   1              TL0 = 0;
 404   1              
 405   1              TR0 = 1;
 406   1      }
 407          //==========================================系统初始化=============================================
 408          void Init_Sys()
 409          {
 410   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 411   1              P0 = 0xff;
 412   1              P2 &= 0x1f;
 413   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 414   1              P0 = 0x00;
 415   1              P2 &= 0x1f;
 416   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 417   1              P0 = 0xff;
 418   1              P2 &= 0x1f;
 419   1              P2 = (P2 & 0x1f) | 0xe0;
 420   1              P0 = 0xff;
 421   1              
 422   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 423   1      }
 424          
 425          void LED_control() {
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 8   

 426   1              // ================= 测试开始 =============
 427   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 428   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 429   1      //      P2 &= 0x1f;
 430   1              // ================= 测试结束 =============
 431   1              
 432   1              // =========================================== 代码开始 ======================================
 433   1              
 434   1              // =========================================== 代码结束 ======================================
 435   1      }
 436          
 437          void main()
 438          {
 439   1              Init_Sys();
 440   1              Init_T1();
 441   1              Init_T0();
 442   1              
 443   1              while(1)
 444   1              {
 445   2      //              LED_control();
 446   2              if(f_2ms == 1)
 447   2              {
 448   3                  f_2ms = 0;                  
 449   3                              LED_control();  // xxx
 450   3                              // =======================按键========================
 451   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 452   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 453   3      //                      Change_Keys();        // 3.矩阵按键扫描
 454   3                              key_array_scan();     // 4.矩阵按键扫描(Ne555专用)
 455   3                              
 456   3                              // =========================================== 代码开始 ======================================
 457   3                              num3 = freq / 10000;
 458   3                              num4 = freq % 10000 / 1000;
 459   3                              num5 = freq % 1000 / 100;
 460   3                              num6 = freq % 100 / 10;
 461   3                              num7 = freq % 10;
 462   3                              // =========================================== 代码结束 ======================================
 463   3              }
 464   2          }
 465   1      }
 466          void Service_T1() interrupt 3
 467          {
 468   1              TH1 = (65536 - 2000) / 256;
 469   1              TL1 = (65536 - 2000) % 256;
 470   1              
 471   1              f_2ms = 1;
 472   1              
 473   1              if (++ num_2ms == 5) {
 474   2                      num_2ms = 0;
 475   2                      f_10ms = 1;
 476   2              }
 477   1              /***************************************************
 478   1              与时间相关的变量的更新放在里面
 479   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 480   1              ***************************************************/
 481   1              // =========================================== 代码开始 ======================================
 482   1              if (++ num_2ms_ne555 >= 500)
 483   1              {
 484   2                      num_2ms_ne555 = 0;
 485   2                      freq = (TH0 << 8) | TL0;
 486   2                      TH0 = 0;
 487   2                      TL0 = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 14:08:22 PAGE 9   

 488   2              }
 489   1              // =========================================== 代码结束 ======================================
 490   1              
 491   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 492   1      }
*** WARNING C294 IN LINE 161 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1275    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
