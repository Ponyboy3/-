C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          #define uchar unsigned char 
   4          #define uint unsigned int
   5          
   6          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   7          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
   8          // xxx
   9          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  10          
  11          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  12          uchar GN;  // 按键标志位
  13          bit f_2ms, f_50ms;  // 2ms, 50ms标志位
  14          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  15          
  16          sbit S7 = P3^0;
  17          sbit S6 = P3^1;
  18          sbit S5 = P3^2;
  19          sbit S4 = P3^3;
  20          
  21          sbit L0 = P0^0;
  22          sbit L1 = P0^1;
  23          sbit L2 = P0^2;
  24          sbit L3 = P0^3;
  25          sbit L4 = P0^4;
  26          sbit L5 = P0^5;
  27          sbit L6 = P0^6;
  28          
  29          // =========================================== 代码开始 ======================================
  30          bit f_1s;  // 1s标志位
  31          
  32          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  33          
  34          uchar urdat;    
  35          // =========================================== 代码结束 ======================================
  36          
  37          
  38          //=========================================普通延时函数(模板函数)=================================
  39          void Delay(uint t) {
  40   1              while( t -- );
  41   1              while( t -- );
  42   1      }
  43          //=======================================单个LED控制函数(模板函数)================================
  44          // 根据项目需要删减
  45          
  46          // ======================LED0====================
  47          void LED0_On() {
  48   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  49   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  50   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  51   1              temp_Led_P0 = P0;
  52   1              P2 &= 0x1f;
  53   1      }
  54          void LED0_Off() {
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 2   

  55   1              P0 = 0xff & temp_Led_P0;
  56   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  57   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  58   1              temp_Led_P0 = P0;
  59   1              P2 &= 0x1f;
  60   1      }
  61          // ======================LED1====================
  62          void LED1_On() {
  63   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  64   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  65   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  66   1              temp_Led_P0 = P0;
  67   1              P2 &= 0x1f;
  68   1      }
  69          void LED1_Off() {
  70   1              P0 = 0xff & temp_Led_P0;
  71   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  72   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  73   1              temp_Led_P0 = P0;
  74   1              P2 &= 0x1f;
  75   1      }
  76          // ======================LED2====================
  77          void LED2_On() {
  78   1              P0 = 0xff & temp_Led_P0;
  79   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  80   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  81   1              temp_Led_P0 = P0;
  82   1              P2 &= 0x1f;
  83   1      }
  84          void LED2_Off() {
  85   1              P0 = 0xff & temp_Led_P0;
  86   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  87   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  88   1              temp_Led_P0 = P0;
  89   1              P2 &= 0x1f;
  90   1      }
  91          // ======================LED3====================
  92          void LED3_On() {
  93   1              P0 = 0xff & temp_Led_P0;
  94   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  95   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
  96   1              temp_Led_P0 = P0;
  97   1              P2 &= 0x1f;
  98   1      }
  99          void LED3_Off() {
 100   1              P0 = 0xff & temp_Led_P0;
 101   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 102   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 103   1              temp_Led_P0 = P0;
 104   1              P2 &= 0x1f;
 105   1      }
 106          // ======================LED4====================
 107          void LED4_On() {
 108   1              P0 = 0xff & temp_Led_P0;
 109   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 110   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 111   1              temp_Led_P0 = P0;
 112   1              P2 &= 0x1f;
 113   1      }
 114          void LED4_Off() {
 115   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 116   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 3   

 117   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 118   1              temp_Led_P0 = P0;
 119   1              P2 &= 0x1f;
 120   1      }
 121          // ======================LED5====================
 122          void LED5_On() {
 123   1              P0 = 0xff & temp_Led_P0;
 124   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 125   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 126   1              temp_Led_P0 = P0;
 127   1              P2 &= 0x1f;
 128   1      }
 129          void LED5_Off() {
 130   1              P0 = 0xff & temp_Led_P0;
 131   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 132   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 133   1              temp_Led_P0 = P0;
 134   1              P2 &= 0x1f;
 135   1      }
 136          // ======================LED6====================
 137          void LED6_On() {
 138   1              P0 = 0xff & temp_Led_P0;
 139   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 140   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 141   1              temp_Led_P0 = P0;
 142   1              P2 &= 0x1f;
 143   1      }
 144          void LED6_Off() {
 145   1              P0 = 0xff & temp_Led_P0;
 146   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 147   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 148   1              temp_Led_P0 = P0;
 149   1              P2 &= 0x1f;
 150   1      }
 151          
 152          void LED_On(uchar n) {
 153   1              P0 = 0xff & temp_Led_P0;
 154   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 155   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 156   1              temp_Led_P0 = P0;
 157   1              P2 &= 0x1f;
 158   1      }
*** WARNING C280 IN LINE 152 OF main.c: 'n': unreferenced local variable
 159          //=========================================数码管显示==============================================
 160          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 161          {
 162   1              char i;
 163   1              P0 = 0xff;
 164   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 165   1              P0 = type2[i];
 166   1              P2 &= 0x1f;
 167   1              switch(i)//数码管位选
 168   1              {
 169   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 170   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 171   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 172   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 173   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 174   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 175   2                                                                              if(0)  // 根据需要的条件
 176   2                                                                              {
 177   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 4   

 178   3                                                                              }
 179   2                                                                              else
 180   2                                                                                      P0 = type1[n6];
 181   2                                                                                                        P2 &= 0x1f;break;
 182   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 183   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 184   2              }
 185   1              if(++i==8)
 186   1                      i = 0;
 187   1      }
 188          //============================================独立按键============================================
 189          /***************************************************
 190          写法一：
 191          有按键被按下，GN标记，后面根据需要功能进行操作
 192          ***************************************************/
 193          void Delay_Keys(uint t)
 194          {
 195   1              while(t--);
 196   1      }
 197          uchar Scan_Keys_Alone()
 198          {
 199   1              char d;
 200   1              d = (~P3) & 0x0f;
 201   1              if(d == 0) return 0;
 202   1              Delay_Keys(100);
 203   1              if(d == 0) return 0;
 204   1              Delay_Keys(100);
 205   1              return d;
 206   1      }
 207          void Change_Keys_Alone()
 208          {
 209   1              switch(Scan_Keys_Alone())
 210   1              {
 211   2                      case 8:GN = 1;break;//S4
 212   2                      case 4:GN = 2;break;//S5
 213   2                      case 2:GN = 3;break;//S6
 214   2                      case 1:GN = 4;break;//S7
 215   2                      case 0:GN = 0;break;
 216   2              }
 217   1      }
 218          
 219          /***************************************************
 220          写法二：
 221          有按键被按下，按下是一种状态，松开是另一种状态
 222          （如：按下时某个灯亮，松开时灯灭）
 223          ***************************************************/
 224          void ScanKeys_Alone() 
 225          {
 226   1              if (S7 == 0) {
 227   2                      Delay_Keys(100);
 228   2                      if (S7 == 0) {
 229   3                              // =========================================== 代码开始 ======================================
 230   3                              
 231   3                              // =========================================== 代码结束 ======================================
 232   3                              while(S7 == 0);
 233   3                              // =========================================== 代码开始 ======================================
 234   3      
 235   3                              // =========================================== 代码结束 ======================================
 236   3                      }
 237   2              }
 238   1              
 239   1              if (S6 == 0) {
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 5   

 240   2                      Delay_Keys(100);
 241   2                      if (S6 == 0) {
 242   3                              // =========================================== 代码开始 ======================================
 243   3                              
 244   3                              // =========================================== 代码结束 ======================================
 245   3                              while(S6 == 0);
 246   3                              // =========================================== 代码开始 ======================================
 247   3      
 248   3                              // =========================================== 代码结束 ======================================
 249   3                      }
 250   2              }
 251   1              
 252   1              if (S5 == 0) {
 253   2                      Delay_Keys(100);
 254   2                      if (S5 == 0) {
 255   3                              // =========================================== 代码开始 ======================================
 256   3      
 257   3                              // =========================================== 代码结束 ======================================
 258   3                              while(S5 == 0);
 259   3                              // =========================================== 代码开始 ======================================
 260   3      
 261   3                              // =========================================== 代码结束 ======================================
 262   3                      }
 263   2              }
 264   1      
 265   1              if (S4 == 0) {
 266   2                      Delay_Keys(100);
 267   2                      if (S4 == 0) {
 268   3                              // =========================================== 代码开始 ======================================
 269   3      
 270   3                              // =========================================== 代码结束 ======================================
 271   3                              while(S4 == 0);
 272   3                              // =========================================== 代码开始 ======================================
 273   3      
 274   3                              // =========================================== 代码结束 ======================================
 275   3                      }
 276   2              }
 277   1      }
 278          
 279          // ================= 代码结束 =============
 280          
 281          //============================================矩阵按键============================================
 282          sfr P4 = 0xc0;
 283          sbit P44 = P4^4;
 284          sbit P42 = P4^2;
 285          
 286          uchar Scan_Keys()
 287          {
 288   1              char H,L;
 289   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 290   1              if(H == 0) return 0;
 291   1              Delay_Keys(100);
 292   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 293   1              if(H == 0) return 0;
 294   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 295   1              if(P44 == 0) L |= 0x80;
 296   1              if(P42 == 0) L |= 0x40;
 297   1              return (H+L);
 298   1      }
 299          
 300          void Change_Keys()
 301          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 6   

 302   1              switch(Scan_Keys())
 303   1              {
 304   2                      case 0x88:GN = 4;break;  // S4
 305   2                      case 0x84:GN = 5;break;  // S5
 306   2                      case 0x82:GN = 6;break;  // S6
 307   2                      case 0x81:GN = 7;break;  // S7
 308   2                      case 0x48:GN = 8;break;  // S8
 309   2                      case 0x44:GN = 9;break;  // S9
 310   2                      case 0x42:GN = 10;break;  // S10
 311   2                      case 0x41:GN = 11;break;  // S11
 312   2                      case 0x28:GN = 12;break;  // S12
 313   2                      case 0x24:GN = 13;break;  // S13
 314   2                      case 0x22:GN = 14;break;  // S14
 315   2                      case 0x21:GN = 15;break;  // S15
 316   2                      case 0x18:GN = 16;break;  // S16
 317   2                      case 0x14:GN = 17;break;  // S17
 318   2                      case 0x12:GN = 18;break;  // S18
 319   2                      case 0x11:GN = 19;break;  // S19
 320   2                      case 0:GN = 0;break;
 321   2              }
 322   1      }
 323          //============================================定时器T0初始化=======================================
 324          uchar count = 0;
 325          uchar pwm_dut = 0;//占空比
 326          void Init_T0()
 327          {
 328   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 329   1              TH0 = (65536 - 2000) / 256;
 330   1              TL0 = (65536 - 2000) % 256;
 331   1              
 332   1              EA = 1;
 333   1              ET0 = 1;
 334   1              TR0 = 1;
 335   1      }
 336          //============================================定时器T1初始化=======================================
 337          //void Init_T1()
 338          //{
 339          //      TMOD = (TMOD & 0x0f) | 0x10;//定时
 340          //      TH1 = (65536 - 2000) / 256;//2ms
 341          //      TL1 = (65536 - 2000) % 256;
 342          //      
 343          //      EA = 1;
 344          //      ET1 = 1;
 345          //      TR1 = 1;
 346          //}
 347          //============================================串口初始化============================================
 348          #include "intrins.h"
 349          #include "string.h"
 350          
 351          sfr AUXR = 0x8e;  // 辅助寄存器
 352          #define BAUD         9600
 353          #define SYSTEMCLOCK  12000000L
 354          uchar command = 0x00;
 355          void Init_Uart()
 356          {
 357   1              TMOD = (TMOD & 0x0f) | 0x00;
 358   1              TL1 = (65535-(SYSTEMCLOCK / 4 / BAUD));
 359   1              TH1 = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 360   1      //      ET1 = 0;                    //禁止定时器1中断
 361   1              TR1 = 1;                    //启动定时器1
 362   1              
 363   1              SCON = 0x50;
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 7   

 364   1              AUXR = 0x40;
 365   1              
 366   1              ES = 1;
 367   1              EA = 1;
 368   1              
 369   1      //      SCON = 0x50;            //8位数据,可变波特率
 370   1      //      AUXR &= 0xBF;           //定时器1时钟为Fosc/12,即12T
 371   1      //      AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 372   1      //      TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 373   1      //      TL1 = 0xE8;             //设定定时初值
 374   1      //      TH1 = 0xFF;             //设定定时初值
 375   1      //      ET1 = 0;                //禁止定时器1中断
 376   1      
 377   1      //      ES = 1;
 378   1      //      EA = 1;  
 379   1      //      TR1 = 1;                //启动定时器1
 380   1      }
 381          // 发送一个字节数据
 382          void Send_Byte(unsigned char dat)
 383          {
 384   1              SBUF = dat;
 385   1              while(TI == 0);
 386   1              TI = 0;
 387   1      }
 388          //发送一串字符串
 389          void Send_String(unsigned char* str)
 390          {
 391   1        
 392   1        while(*str != '\0')
 393   1        {
 394   2          Send_Byte(*(str++));
 395   2        }
 396   1      }
 397          //==========================================系统初始化=============================================
 398          void Init_Sys()
 399          {
 400   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 401   1              P0 = 0xff;
 402   1              P2 &= 0x1f;
 403   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 404   1              P0 = 0x00;
 405   1              P2 &= 0x1f;
 406   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 407   1              P0 = 0xff;
 408   1              P2 &= 0x1f;
 409   1              P2 = (P2 & 0x1f) | 0xe0;
 410   1              P0 = 0xff;
 411   1              
 412   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 413   1      }
 414          
 415          void LED_control() {
 416   1              // ================= 测试开始 =============
 417   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 418   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 419   1      //      P2 &= 0x1f;
 420   1              // ================= 测试结束 =============
 421   1              
 422   1              // =========================================== 代码开始 ======================================
 423   1              
 424   1              // =========================================== 代码结束 ======================================
 425   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 8   

 426          
 427          void main()
 428          {
 429   1              Init_Sys();
 430   1      //      Init_T1();
 431   1              Init_T0();
 432   1              
 433   1              Init_Uart();
 434   1      //      Send_Byte(0x5a);
 435   1      //      Send_Byte(0xa5);
 436   1              Send_String("I am OK\r\n");
 437   1              
 438   1              while(1)
 439   1              {
 440   2      //              LED_control();
 441   2              if(f_2ms == 1)
 442   2              {
 443   3                  f_2ms = 0;                  
 444   3                              LED_control();  // xxx
 445   3                              // =======================按键开始========================
 446   3                              /*根据需要选择对应的按键类型*/
 447   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 448   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 449   3                              Change_Keys();        // 3.矩阵按键扫描
 450   3                              if (GN == 16) {  // S16
 451   4                                      // =========================================== 代码开始 ======================================
 452   4                                      LED1_On();
 453   4                                      // =========================================== 代码结束 ======================================
 454   4                                      while(Scan_Keys());
 455   4                                      // =========================================== 代码开始 ======================================
 456   4                                      LED1_Off();
 457   4                                      // =========================================== 代码结束 ======================================
 458   4                              }
 459   3                              // 根据需要添加对应按键
 460   3                              // =======================按键结束========================
 461   3                              
 462   3                              // =========================================== 代码开始 ======================================
 463   3                              if(command != 0x00)
 464   3                              {
 465   4                                      switch(command & 0xf0)
 466   4                                      {
 467   5                                              case 0xa0:
 468   5                                                      P0 = temp_Led_P0;
 469   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 470   5                                                      P0 = (P0 | 0x0f) & ((~command) | 0xf0);
 471   5                                                      temp_Led_P0 = P0;
 472   5                                                      P2 &= 0x1f;
 473   5                                                      command = 0x00;
 474   5                                              break;
 475   5                                              case 0xb0:
 476   5                                                      P0 = temp_Led_P0;
 477   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 478   5                                                      P0 = (P0 | 0xf0) & (((~command) << 4) | 0x0f);
 479   5                                                      temp_Led_P0 = P0;
 480   5                                                      P2 &= 0x1f;
 481   5                                                      command = 0x00;
 482   5                                              break;
 483   5                                              case 0xc0:
 484   5                                                      Send_String("system is running...!\r\n");
 485   5                                                      command = 0x00;
 486   5                                              break;
 487   5                                      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:03:37 PAGE 9   

 488   4                              }
 489   3                              // =========================================== 代码结束 ======================================
 490   3              }
 491   2          }
 492   1      }
 493          
 494          void Service_T0() interrupt 1
 495          {
 496   1              TH0 = (65536 - 2000) / 256;
 497   1              TL0 = (65536 - 2000) % 256;
 498   1              
 499   1              f_2ms = 1;
 500   1              
 501   1              /***************************************************
 502   1              与时间相关的变量的更新放在里面
 503   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 504   1              ***************************************************/
 505   1              // =========================================== 代码开始 ======================================
 506   1              num_2ms ++ ;
 507   1              if (num_2ms == 500) {
 508   2                      f_1s = 1;
 509   2                      num_2ms = 0;
 510   2              }
 511   1              if (f_1s == 1) {
 512   2                      f_1s = 0;
 513   2                      num_s ++ ;
 514   2                      if (num_s == 9) 
 515   2                      num_s = 0;
 516   2              }
 517   1              num1 = 2;num2 = 0; num3 = 2; num4 = 4;
 518   1              num5=num6=11;
 519   1              num7=num_s / 10, num8=num_s % 10;
 520   1              // =========================================== 代码结束 ======================================
 521   1              
 522   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 523   1      }
 524          
 525          void ServiceUart() interrupt 4
 526          {
 527   1              if(RI == 1)
 528   1              {
 529   2                      RI = 0;//人工清零
 530   2                      urdat = SBUF;
 531   2                      command = SBUF;
 532   2      //              Send_Byte(urdat + 1);
 533   2      //              send_byte(0x5a);
 534   2      //              send_byte(0xa5);
 535   2              }
 536   1      }
*** WARNING C294 IN LINE 177 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1343    ----
   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
