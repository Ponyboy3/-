C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          #define uchar unsigned char 
   4          #define uint unsigned int
   5          
   6          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   7          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
   8          // xxx
   9          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  10          
  11          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  12          uchar GN;  // 按键标志位
  13          bit f_2ms, f_50ms;  // 2ms, 50ms标志位
  14          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  15          
  16          sbit S7 = P3^0;
  17          sbit S6 = P3^1;
  18          sbit S5 = P3^2;
  19          sbit S4 = P3^3;
  20          
  21          sbit L1 = P0^0;
  22          sbit L2 = P0^1;
  23          sbit L3 = P0^2;
  24          sbit L4 = P0^3;
  25          sbit L5 = P0^4;
  26          sbit L6 = P0^5;
  27          
  28          // =========================================== 代码开始 ======================================
  29          bit f_1s, f_1m;  // 1s标志位
  30          
  31          uint num_2ms = 0, num_50ms = 0, num_s = 0, num_m;  // 多少个2ms, 1s
  32          // =========================================== 代码结束 ======================================
  33          
  34          //=========================================普通延时函数(模板函数)=================================
  35          void Delay(uint t) {
  36   1              while( t -- );
  37   1              while( t -- );
  38   1      }
  39          //=======================================单个LED控制函数(模板函数)================================
  40          // ======================LED1====================
  41          void LED1_On() {
  42   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  43   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  44   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  45   1              temp_Led_P0 = P0;
  46   1              P2 &= 0x1f;
  47   1      }
  48          void LED1_Off() {
  49   1              P0 = 0xff & temp_Led_P0;
  50   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  51   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  52   1              temp_Led_P0 = P0;
  53   1              P2 &= 0x1f;
  54   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 2   

  55          // ======================LED2====================
  56          void LED2_On() {
  57   1              P0 = 0xff & temp_Led_P0;
  58   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  59   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  60   1              temp_Led_P0 = P0;
  61   1              P2 &= 0x1f;
  62   1      }
  63          void LED2_Off() {
  64   1              P0 = 0xff & temp_Led_P0;
  65   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  66   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  67   1              temp_Led_P0 = P0;
  68   1              P2 &= 0x1f;
  69   1      }
  70          // ======================LED3====================
  71          void LED3_On() {
  72   1              P0 = 0xff & temp_Led_P0;
  73   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  74   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
  75   1              temp_Led_P0 = P0;
  76   1              P2 &= 0x1f;
  77   1      }
  78          void LED3_Off() {
  79   1              P0 = 0xff & temp_Led_P0;
  80   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  81   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
  82   1              temp_Led_P0 = P0;
  83   1              P2 &= 0x1f;
  84   1      }
  85          // ======================LED4====================
  86          void LED4_On() {
  87   1              P0 = 0xff & temp_Led_P0;
  88   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  89   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
  90   1              temp_Led_P0 = P0;
  91   1              P2 &= 0x1f;
  92   1      }
  93          void LED4_Off() {
  94   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
  95   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  96   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
  97   1              temp_Led_P0 = P0;
  98   1              P2 &= 0x1f;
  99   1      }
 100          // ======================LED5====================
 101          void LED5_On() {
 102   1              P0 = 0xff & temp_Led_P0;
 103   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 104   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 105   1              temp_Led_P0 = P0;
 106   1              P2 &= 0x1f;
 107   1      }
 108          void LED5_Off() {
 109   1              P0 = 0xff & temp_Led_P0;
 110   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 111   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 112   1              temp_Led_P0 = P0;
 113   1              P2 &= 0x1f;
 114   1      }
 115          // ======================LED6====================
 116          void LED6_On() {
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 3   

 117   1              P0 = 0xff & temp_Led_P0;
 118   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 119   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 120   1              temp_Led_P0 = P0;
 121   1              P2 &= 0x1f;
 122   1      }
 123          void LED6_Off() {
 124   1              P0 = 0xff & temp_Led_P0;
 125   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 126   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 127   1              temp_Led_P0 = P0;
 128   1              P2 &= 0x1f;
 129   1      }
 130          
 131          void LED_On(uchar n) {
 132   1              P0 = 0xff & temp_Led_P0;
 133   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 134   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 135   1              temp_Led_P0 = P0;
 136   1              P2 &= 0x1f;
 137   1      }
*** WARNING C280 IN LINE 131 OF main.c: 'n': unreferenced local variable
 138          //=========================================数码管显示==============================================
 139          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 140          {
 141   1              char i;
 142   1              P0 = 0xff;
 143   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 144   1              P0 = type2[i];
 145   1              P2 &= 0x1f;
 146   1              switch(i)//数码管位选
 147   1              {
 148   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 149   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 150   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 151   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 152   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 153   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 154   2                                                                              if(0)  // 根据需要的条件
 155   2                                                                              {
 156   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 157   3                                                                              }
 158   2                                                                              else
 159   2                                                                                      P0 = type1[n6];
 160   2                                                                                                        P2 &= 0x1f;break;
 161   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 162   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 163   2              }
 164   1              if(++i==8)
 165   1                      i = 0;
 166   1      }
 167          //============================================独立按键============================================
 168          /***************************************************
 169          写法一：
 170          有按键被按下，GN标记，后面根据需要功能进行操作
 171          ***************************************************/
 172          void Delay_Keys(uint t)
 173          {
 174   1              while(t--);
 175   1      }
 176          uchar Scan_Keys_Alone()
 177          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 4   

 178   1              char d;
 179   1              d = (~P3) & 0x0f;
 180   1              if(d == 0) return 0;
 181   1              Delay_Keys(100);
 182   1              if(d == 0) return 0;
 183   1              Delay_Keys(100);
 184   1              return d;
 185   1      }
 186          void Change_Keys_Alone()
 187          {
 188   1              switch(Scan_Keys_Alone())
 189   1              {
 190   2                      case 8:GN = 1;break;//S4
 191   2                      case 4:GN = 2;break;//S5
 192   2                      case 2:GN = 3;break;//S6
 193   2                      case 1:GN = 4;break;//S7
 194   2                      case 0:GN = 0;break;
 195   2              }
 196   1      }
 197          
 198          /***************************************************
 199          写法二：
 200          有按键被按下，按下是一种状态，松开是另一种状态
 201          （如：按下时某个灯亮，松开时灯灭）
 202          ***************************************************/
 203          void ScanKeys_Alone() 
 204          {
 205   1              if (S7 == 0) {
 206   2                      Delay_Keys(100);
 207   2                      if (S7 == 0) {
 208   3                              // =========================================== 代码开始 ======================================
 209   3                              
 210   3                              // =========================================== 代码结束 ======================================
 211   3                              while(S7 == 0);
 212   3                              // =========================================== 代码开始 ======================================
 213   3      
 214   3                              // =========================================== 代码结束 ======================================
 215   3                      }
 216   2              }
 217   1              
 218   1              if (S6 == 0) {
 219   2                      Delay_Keys(100);
 220   2                      if (S6 == 0) {
 221   3                              // =========================================== 代码开始 ======================================
 222   3                              
 223   3                              // =========================================== 代码结束 ======================================
 224   3                              while(S6 == 0);
 225   3                              // =========================================== 代码开始 ======================================
 226   3      
 227   3                              // =========================================== 代码结束 ======================================
 228   3                      }
 229   2              }
 230   1              
 231   1              if (S5 == 0) {
 232   2                      Delay_Keys(100);
 233   2                      if (S5 == 0) {
 234   3                              // =========================================== 代码开始 ======================================
 235   3      
 236   3                              // =========================================== 代码结束 ======================================
 237   3                              while(S5 == 0);
 238   3                              // =========================================== 代码开始 ======================================
 239   3      
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 5   

 240   3                              // =========================================== 代码结束 ======================================
 241   3                      }
 242   2              }
 243   1      
 244   1              if (S4 == 0) {
 245   2                      Delay_Keys(100);
 246   2                      if (S4 == 0) {
 247   3                              // =========================================== 代码开始 ======================================
 248   3      
 249   3                              // =========================================== 代码结束 ======================================
 250   3                              while(S4 == 0);
 251   3                              // =========================================== 代码开始 ======================================
 252   3      
 253   3                              // =========================================== 代码结束 ======================================
 254   3                      }
 255   2              }
 256   1      }
 257          
 258          // ================= 代码结束 =============
 259          
 260          //============================================矩阵按键============================================
 261          sfr P4 = 0xc0;
 262          sbit P44 = P4^4;
 263          sbit P42 = P4^2;
 264          
 265          uchar Scan_Keys()
 266          {
 267   1              char H,L;
 268   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 269   1              if(H == 0) return 0;
 270   1              Delay_Keys(100);
 271   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 272   1              if(H == 0) return 0;
 273   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 274   1              if(P44 == 0) L |= 0x80;
 275   1              if(P42 == 0) L |= 0x40;
 276   1              return (H+L);
 277   1      }
 278          
 279          void Change_Keys()
 280          {
 281   1              switch(Scan_Keys())
 282   1              {
 283   2                      case 0x88:GN = 4;break;  // S4
 284   2                      case 0x84:GN = 5;break;  // S5
 285   2                      case 0x82:GN = 6;break;  // S6
 286   2                      case 0x81:GN = 7;break;  // S7
 287   2                      case 0x48:GN = 8;break;  // S8
 288   2                      case 0x44:GN = 9;break;  // S9
 289   2                      case 0x42:GN = 10;break;  // S10
 290   2                      case 0x41:GN = 11;break;  // S11
 291   2                      case 0x28:GN = 12;break;  // S12
 292   2                      case 0x24:GN = 13;break;  // S13
 293   2                      case 0x22:GN = 14;break;  // S14
 294   2                      case 0x21:GN = 15;break;  // S15
 295   2                      case 0x18:GN = 16;break;  // S16
 296   2                      case 0x14:GN = 17;break;  // S17
 297   2                      case 0x12:GN = 18;break;  // S18
 298   2                      case 0x11:GN = 19;break;  // S19
 299   2                      case 0:GN = 0;break;
 300   2              }
 301   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 6   

 302          //============================================定时器T0初始化=======================================
 303          void Init_T0()
 304          {
 305   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 306   1              TH0 = (65536 - 50000) / 256;  // 50ms
 307   1              TL0 = (65536 - 50000) % 256; 
 308   1              
 309   1              EA = 1;
 310   1              ET0 = 1;
 311   1              TR0 = 1;
 312   1      }
 313          //============================================定时器T1初始化=======================================
 314          void Init_T1()
 315          {
 316   1              TMOD = (TMOD & 0x0f) | 0x10;//定时
 317   1              TH1 = (65536 - 2000) / 256;//2ms
 318   1              TL1 = (65536 - 2000) % 256;
 319   1              
 320   1              EA = 1;
 321   1              ET1 = 1;
 322   1              TR1 = 1;
 323   1      }
 324          //==========================================系统初始化=============================================
 325          void Init_Sys()
 326          {
 327   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 328   1              P0 = 0xff;
 329   1              P2 &= 0x1f;
 330   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 331   1              P0 = 0x00;
 332   1              P2 &= 0x1f;
 333   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 334   1              P0 = 0xff;
 335   1              P2 &= 0x1f;
 336   1              P2 = (P2 & 0x1f) | 0xe0;
 337   1              P0 = 0xff;
 338   1              
 339   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 340   1      }
 341          
 342          void LED_control() {
 343   1              // ================= 测试开始 =============
 344   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 345   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 346   1      //      P2 &= 0x1f;
 347   1              // ================= 测试结束 =============
 348   1              
 349   1              // =========================================== 代码开始 ======================================
 350   1              
 351   1              // =========================================== 代码结束 ======================================
 352   1      }
 353          
 354          void main()
 355          {
 356   1              Init_Sys();
 357   1              Init_T1();
 358   1              Init_T0();
 359   1              
 360   1              while(1)
 361   1              {
 362   2      //              LED_control();
 363   2              if(f_2ms == 1)
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 7   

 364   2              {
 365   3                  f_2ms = 0;                  
 366   3                              LED_control();  // xxx
 367   3                              // =======================按键开始========================
 368   3                              /*根据需要选择对应的按键类型*/
 369   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 370   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 371   3                              Change_Keys();        // 3.矩阵按键扫描
 372   3                              if (GN == 16) {  // S16
 373   4                                      // =========================================== 代码开始 ======================================
 374   4                                      LED1_On();
 375   4                                      // =========================================== 代码结束 ======================================
 376   4                                      while(Scan_Keys());
 377   4                                      // =========================================== 代码开始 ======================================
 378   4                                      LED1_Off();
 379   4                                      // =========================================== 代码结束 ======================================
 380   4                              }
 381   3                              // 根据需要添加对应按键
 382   3                              // =======================按键结束========================
 383   3                              
 384   3                              // =========================================== 代码开始 ======================================
 385   3                              num1 = num_m / 10, num2 = num_m % 10;
 386   3                              num3 = num6 = 11;
 387   3                              num4 = num_s / 10, num5 = num_s % 10;
 388   3                              num7 = num_50ms / 10, num8 = num_50ms % 10;
 389   3                              // =========================================== 代码结束 ======================================
 390   3              }
 391   2          }
 392   1      }
 393          
 394          void Service_T0() interrupt 2
 395          {
 396   1              TH0 = (65536 - 50000) / 256;
 397   1              TL0 = (65536 - 50000) % 256;
 398   1              
 399   1              f_50ms = 1;
 400   1              
 401   1              num_50ms ++ ;
 402   1              if (num_50ms == 20) {
 403   2                      
 404   2                      num_50ms = 0;
 405   2                      num_s ++ ;
 406   2              }
 407   1              
 408   1              if (num_s == 60) {
 409   2                      num_s = 0;
 410   2                      num_m ++ ;
 411   2              }
 412   1      }
 413          
 414          void Service_T1() interrupt 3
 415          {
 416   1              TH1 = (65536 - 2000) / 256;
 417   1              TL1 = (65536 - 2000) % 256;
 418   1              
 419   1              f_2ms = 1;
 420   1              
 421   1              /***************************************************
 422   1              与时间相关的变量的更新放在里面
 423   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 424   1              ***************************************************/
 425   1              // =========================================== 代码开始 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 23:24:08 PAGE 8   

 426   1      //      num_2ms ++ ;
 427   1      //      if (num_2ms == 500) {
 428   1      //              f_1s = 1;
 429   1      //              num_2ms = 0;
 430   1      //      }
 431   1      //      if (f_1s == 1) {
 432   1      //              f_1s = 0;
 433   1      //              num_s ++ ;
 434   1      //              if (num_s == 9) 
 435   1      //              num_s = 0;
 436   1      //      }
 437   1      //      num1 = 2;num2 = 0; num3 = 2; num4 = 4;
 438   1      //      num5=num6=11;
 439   1      //      num7=num_s / 10, num8=num_s % 10;
 440   1              // =========================================== 代码结束 ======================================
 441   1              
 442   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 443   1      }
*** WARNING C294 IN LINE 156 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1183    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
