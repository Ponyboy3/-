C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "ds1302.h"
   3          #include "iic.h"
   4          #include "onewire.h"
   5          
   6          #define uchar unsigned char 
   7          #define uint unsigned int
   8          
   9          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
  10          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,
  11                                                    0xc6,  // C 12
  12                                                    0x89,  // H 13
  13                                                    0x8e,  // F 14
  14                                                    0x8c,  // P 15
  15                                                    0x86,  // E 16
  16                                                    0x88}; // A 17
  17          // xxx
  18          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  19          
  20          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  21          //uchar GN;  // 按键标志位
  22          bit f_2ms;  // 2ms标志位
  23          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  24          
  25          sbit S7 = P3^0;
  26          sbit S6 = P3^1;
  27          sbit S5 = P3^2;
  28          sbit S4 = P3^3;
  29          
  30          sbit L1 = P0^0;
  31          sbit L2 = P0^1;
  32          sbit L3 = P0^2;
  33          sbit L4 = P0^3;
  34          sbit L5 = P0^4;
  35          sbit L6 = P0^5;
  36          sbit L7 = P0^6;
  37          sbit L8 = P0^7;
  38          
  39          uint num_2ms = 0;  // 多少个2ms
  40          
  41          uint num_2ms_ne555=0, freq;
  42          // =========================================== 代码开始 ======================================
  43          //=========数码管显示模式
  44          uchar dis_smg_model = 1, dis_smg_model_old;
  45          //=========ds1302数据
  46          uint h_ds1302;  // 时
  47          uint m_ds1302;  // 分
  48          uint s_ds1302;  // 秒
  49          // =========ADC数据
  50          uchar adc_value_read = 0;  // 当前读到
  51          uchar adc_value_old = 0;  // 上次读到
  52          // =========温度参数
  53          char temp_param = 30;
  54          // =========触发数据
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 2   

  55          bit trigger;
  56          uint trigger_time_2ms;
  57          uchar trigger_times = 0;  // 触发次数
  58          uint trigger_h_ds1302;  // 时
  59          uint trigger_m_ds1302;  // 分
  60          uint trigger_s_ds1302;  // 秒
  61          // =========温度湿度数据
  62          uint humi_smg, humi_max, humi_ave;
  63          uint temper_smg, temper_max, temper_ave;
  64          uint humi[10], temper[10];
  65          //LED闪烁
  66          uint num_2ms_led = 0;
  67          bit is_num_2ms_led;
  68          // S9长按
  69          uint press_num_2ms_s9;
  70          bit is_long_press_s9;
  71          // =========================================== 代码结束 ======================================
  72          
  73          
  74          //=========================================普通延时函数(模板函数)=================================
  75          void Delay(uint t) {
  76   1              while( t -- );
  77   1              while( t -- );
  78   1      }
  79          //=======================================单个LED控制函数(模板函数)================================
  80          // ======================LED1====================
  81          void LED1_On() {
  82   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  83   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  84   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  85   1              temp_Led_P0 = P0;
  86   1              P2 &= 0x1f;
  87   1      }
  88          void LED1_Off() {
  89   1              P0 = 0xff & temp_Led_P0;
  90   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  91   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  92   1              temp_Led_P0 = P0;
  93   1              P2 &= 0x1f;
  94   1      }
  95          // ======================LED2====================
  96          void LED2_On() {
  97   1              P0 = 0xff & temp_Led_P0;
  98   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  99   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
 100   1              temp_Led_P0 = P0;
 101   1              P2 &= 0x1f;
 102   1      }
 103          void LED2_Off() {
 104   1              P0 = 0xff & temp_Led_P0;
 105   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 106   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
 107   1              temp_Led_P0 = P0;
 108   1              P2 &= 0x1f;
 109   1      }
 110          // ======================LED3====================
 111          void LED3_On() {
 112   1              P0 = 0xff & temp_Led_P0;
 113   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 114   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 115   1              temp_Led_P0 = P0;
 116   1              P2 &= 0x1f;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 3   

 117   1      }
 118          void LED3_Off() {
 119   1              P0 = 0xff & temp_Led_P0;
 120   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 121   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 122   1              temp_Led_P0 = P0;
 123   1              P2 &= 0x1f;
 124   1      }
 125          // ======================LED4====================
 126          void LED4_On() {
 127   1              P0 = 0xff & temp_Led_P0;
 128   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 129   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 130   1              temp_Led_P0 = P0;
 131   1              P2 &= 0x1f;
 132   1      }
 133          void LED4_Off() {
 134   1              P0 = 0xff & temp_Led_P0;
 135   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 136   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 137   1              temp_Led_P0 = P0;
 138   1              P2 &= 0x1f;
 139   1      }
 140          // ======================LED5====================
 141          void LED5_On() {
 142   1              P0 = 0xff & temp_Led_P0;
 143   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 144   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 145   1              temp_Led_P0 = P0;
 146   1              P2 &= 0x1f;
 147   1      }
 148          void LED5_Off() {
 149   1              P0 = 0xff & temp_Led_P0;
 150   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 151   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 152   1              temp_Led_P0 = P0;
 153   1              P2 &= 0x1f;
 154   1      }
 155          // ======================LED6====================
 156          void LED6_On() {
 157   1              P0 = 0xff & temp_Led_P0;
 158   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 159   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 160   1              temp_Led_P0 = P0;
 161   1              P2 &= 0x1f;
 162   1      }
 163          void LED6_Off() {
 164   1              P0 = 0xff & temp_Led_P0;
 165   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 166   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 167   1              temp_Led_P0 = P0;
 168   1              P2 &= 0x1f;
 169   1      }
 170          // ======================LED7====================
 171          void LED7_On() {
 172   1              P0 = 0xff & temp_Led_P0;
 173   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 174   1              L7 = 0;  // 要将P0放在这两句代码之间，避免错乱
 175   1              temp_Led_P0 = P0;
 176   1              P2 &= 0x1f;
 177   1      }
 178          void LED7_Off() {
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 4   

 179   1              P0 = 0xff & temp_Led_P0;
 180   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 181   1              L7 = 1;  // 要将P0放在这两句代码之间，避免错乱
 182   1              temp_Led_P0 = P0;
 183   1              P2 &= 0x1f;
 184   1      }
 185          // ======================LED68====================
 186          void LED8_On() {
 187   1              P0 = 0xff & temp_Led_P0;
 188   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 189   1              L8 = 0;  // 要将P0放在这两句代码之间，避免错乱
 190   1              temp_Led_P0 = P0;
 191   1              P2 &= 0x1f;
 192   1      }
 193          void LED8_Off() {
 194   1              P0 = 0xff & temp_Led_P0;
 195   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 196   1              L8 = 1;  // 要将P0放在这两句代码之间，避免错乱
 197   1              temp_Led_P0 = P0;
 198   1              P2 &= 0x1f;
 199   1      }
 200          //=========================================数码管显示==============================================
 201          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 202          {
 203   1              char i;
 204   1              P0 = 0xff;
 205   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 206   1              P0 = type2[i];
 207   1              P2 &= 0x1f;
 208   1              switch(i)//数码管位选
 209   1              {
 210   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 211   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 212   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 213   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 214   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 215   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 216   2                                                                              if(0)  // 根据需要的条件
 217   2                                                                              {
 218   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 219   3                                                                              }
 220   2                                                                              else
 221   2                                                                                      P0 = type1[n6];
 222   2                                                                              P2 &= 0x1f;break;
 223   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;
 224   2                                                                              if ((dis_smg_model == 2 && trigger_times > 0) || (dis_smg_model == 3 && trigger_times > 0)) {
 225   3                                                                                      P0 = type1[n7]&0x7f;  // 加入小数点
 226   3                                                                              }
 227   2                                                                              else
 228   2                                                                                      P0 = type1[n7];
 229   2                                                                              P2 &= 0x1f;break;
 230   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 231   2              }
 232   1              if(++i==8)
 233   1                      i = 0;
 234   1      }
 235          //============================================矩阵按键============================================
 236          sfr P4 = 0xc0;
 237          sbit P44 = P4^4;
 238          sbit P42 = P4^2;
 239          sbit P32 = P3^2;
 240          sbit P33 = P3^3;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 5   

 241          void Delay_Keys(uint t)
 242          {
 243   1              while(t--);
 244   1      }
 245          
 246          void key_array_init() {
 247   1              P32 = 1;
 248   1              P33 = 1;
 249   1              P42 = 0;
 250   1              P44 = 0;
 251   1      }
 252          
 253          void key_array_scan() {
 254   1              if (P32 == 0) {
 255   2                      P32 = 0;
 256   2                      P42 = 1;
 257   2                      P44 = 1;
 258   2                      if (P42 == 0) {
 259   3                              Delay_Keys(100);
 260   3                              if (P42 == 0) {  // S9
 261   4                                      // =========================================== 代码开始 ======================================
 262   4                                      if (dis_smg_model == 5) {
 263   5                                              temp_param -- ;
 264   5                                              if (temp_param <= 0) {
 265   6                                                      temp_param = 0;
 266   6                                              }
 267   5                                      }
 268   4                                      
 269   4                                      is_long_press_s9 = 1;
 270   4      //                              press_num_2ms_s9
 271   4                                      // =========================================== 代码结束 ======================================
 272   4                                      while (P42 == 0);
 273   4                                      // =========================================== 代码开始 ======================================
 274   4      //                              is_long_s9 = 0;
 275   4      //                              is_long_press_s9 = 0;
 276   4                                      // =========================================== 代码结束 ======================================
 277   4                              }
 278   3                      }
 279   2                      else if (P44 == 0) {
 280   3                              Delay_Keys(100);
 281   3                              if (P44 == 0) {  // S5
 282   4                                      // =========================================== 代码开始 ======================================
 283   4                                      if (dis_smg_model == 2) {
 284   5                                              dis_smg_model = 3;
 285   5                                      }
 286   4                                      else if (dis_smg_model == 3) {
 287   5                                              dis_smg_model = 4;
 288   5                                      }
 289   4                                      else if (dis_smg_model == 4) {
 290   5                                              dis_smg_model = 2;
 291   5                                      }
 292   4                                      // =========================================== 代码结束 ======================================
 293   4                                      while (P44 == 0);
 294   4                                      // =========================================== 代码开始 ======================================
 295   4                                      // =========================================== 代码结束 ======================================
 296   4                              }
 297   3                      }
 298   2              }
 299   1              
 300   1              if (P33 == 0) {
 301   2                      P33 = 0;
 302   2                      P42 = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 6   

 303   2                      P44 = 1;
 304   2                      if (P42 == 0) {
 305   3                              Delay_Keys(100);
 306   3                              if (P42 == 0) {  // S8
 307   4                                      // =========================================== 代码开始 ======================================
 308   4                                      if (dis_smg_model == 5) {
 309   5                                              temp_param ++ ;
 310   5                                              if (temp_param >= 99) {
 311   6                                                      temp_param = 99;
 312   6                                              }
 313   5                                      }
 314   4                                      // =========================================== 代码结束 ======================================
 315   4                                      while (P42 == 0);
 316   4                                      // =========================================== 代码开始 ======================================
 317   4      
 318   4                                      // =========================================== 代码结束 ======================================
 319   4                              }
 320   3                      }
 321   2                      else if (P44 == 0) {
 322   3                              Delay_Keys(100);
 323   3                              if (P44 == 0) {  // S4
 324   4                                      // =========================================== 代码开始 ======================================
 325   4                                      if (dis_smg_model == 1) {
 326   5                                              dis_smg_model = 2;
 327   5                                      }
 328   4                                      else if (dis_smg_model == 2 | dis_smg_model == 3 | dis_smg_model == 4) {
 329   5                                              dis_smg_model = 5;
 330   5                                      }
 331   4                                      else if (dis_smg_model == 5) {
 332   5                                              dis_smg_model = 1;
 333   5                                      }
 334   4                                      // =========================================== 代码结束 ======================================
 335   4                                      while(P44 == 0);
 336   4                                      // =========================================== 代码开始 ======================================
 337   4      
 338   4                                      // =========================================== 代码结束 ======================================
 339   4                              }
 340   3                      }
 341   2              }
 342   1              
 343   1              key_array_init();
 344   1      }
 345          //============================================Ds13023============================================
 346          void My_Write_Ds1302()
 347          {
 348   1              Write_Ds1302_Byte(0x8e,0x00);
 349   1              Write_Ds1302_Byte(0x84,0x13);  // 时
 350   1              Write_Ds1302_Byte(0x82,0x03);  // 分
 351   1              Write_Ds1302_Byte(0x80,0x05);  // 秒
 352   1      }
 353          void My_Read_Ds1302()
 354          {
 355   1              ET1 = 0;
 356   1              
 357   1              h_ds1302 = Read_Ds1302_Byte(0x85);  // 时
 358   1              h_ds1302 = (h_ds1302 >> 4) * 10 + (h_ds1302 & 0x0f);
 359   1              m_ds1302 = Read_Ds1302_Byte(0x83);  // 分
 360   1              m_ds1302 = (m_ds1302 >> 4) * 10 + (m_ds1302 & 0x0f);
 361   1              s_ds1302 = Read_Ds1302_Byte(0x81);  // 秒
 362   1              s_ds1302 = (s_ds1302 >> 4) * 10 + (s_ds1302 & 0x0f);
 363   1              
 364   1              ET1 = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 7   

 365   1      }
 366          //==========================================温度数据处理=============================================
 367          void Handle_temper() {
 368   1              uint sum = 0;
 369   1              uchar i = 0;
 370   1              temper[(trigger_times - 1) % 10] = temper_smg;
 371   1              
 372   1              if (temper_smg > temper_max) {
 373   2                      temper_max = temper_smg;
 374   2              }
 375   1              
 376   1              // 求平均温度
 377   1              if (trigger_times < 10) {
 378   2                      for (i = 0; i < trigger_times; i ++ ) {
 379   3                              sum += temper[i];
 380   3                      }
 381   2                      
 382   2                      temper_ave = sum / trigger_times;
 383   2              }
 384   1              else {
 385   2                      for (i = 0; i < 10; i ++ ) {
 386   3                              sum += temper[i];
 387   3                      }
 388   2                      
 389   2                      temper_ave = sum / 10;
 390   2              }
 391   1      }
 392          //============================================DS18B20初始化============================================
 393          void Init_18b20()
 394          {
 395   1              char i;
 396   1              init_ds18b20();
 397   1              Write_DS18B20(0xcc);
 398   1              Write_DS18B20(0x44);  // 启动温度转换
 399   1      //      Write_DS18B20(0x00);
 400   1      //      Write_DS18B20(0x00);
 401   1      //      Write_DS18B20(0x7f);
 402   1              
 403   1              for (i = 0; i < 8; i ++ ) {  // 等待第一次采集结束，不会显示85
 404   2                      Delay_Keys(60000);
 405   2              }
 406   1      }
 407          
 408          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 409                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 410                                                                           // 和一位小数可用unsigned char.
 411          {
 412   1              unsigned char H,L;
 413   1              
 414   1              init_ds18b20();
 415   1              Write_DS18B20(0xcc);
 416   1              Write_DS18B20(0x44);
 417   1              init_ds18b20();
 418   1              Write_DS18B20(0xcc);
 419   1              Write_DS18B20(0xbe);
 420   1              
 421   1              L = Read_DS18B20();
 422   1              H = Read_DS18B20();
 423   1              
 424   1              init_ds18b20();
 425   1              Write_DS18B20(0xcc);
 426   1              Write_DS18B20(0x44);
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 8   

 427   1              
 428   1              //1.保留整数--23
 429   1              //temp = (H<<4) + (L>>4);
 430   1              
 431   1              //2.保留1位小数--23.4
 432   1              return ((H<<8) + L)*5/8;
 433   1              
 434   1              //3.保留2位小数--23.45
 435   1      //      return ((H<<8)+L)*25/4;  // (50/8)
 436   1      }
 437          //============================================PCF8951部分=======================================
 438          // A/D读取光敏电阻(RD1)或电压采集(RB2)数值
 439          unsigned char Read_ADC(unsigned char n)
 440          {
 441   1              unsigned char temp;
 442   1              IIC_Start();
 443   1              IIC_SendByte(0x90);
 444   1              IIC_WaitAck();
 445   1              if (n == 1)
 446   1              {
 447   2                      IIC_SendByte(0x01);//读取光敏电阻RB1
 448   2              }
 449   1              else if (n == 2)
 450   1              {
 451   2                      IIC_SendByte(0x03);//读取滑动变阻器RB2
 452   2              }
 453   1              IIC_WaitAck();
 454   1              IIC_Stop();
 455   1              
 456   1              Delay_Keys(500);//while(500--);延时等待
 457   1              
 458   1              IIC_Start();
 459   1              IIC_SendByte(0x91);
 460   1              IIC_WaitAck();
 461   1              temp = IIC_RecByte();//读取
 462   1              IIC_SendAck(1); 
 463   1              IIC_Stop();
 464   1              return temp;
 465   1      }
 466          
 467          //Read_ADC(1) -> (0~255) -> *2 -> (0~500)V
 468          
 469          // D/A写电压
 470          void Xie_ADC(unsigned char dat)
 471          {
 472   1              IIC_Start();
 473   1              IIC_SendByte(0x90);
 474   1          IIC_WaitAck();
 475   1          IIC_SendByte(0x40);
 476   1          IIC_WaitAck();
 477   1          IIC_SendByte(dat);
 478   1          IIC_WaitAck();
 479   1          IIC_Stop();
 480   1      }
 481          //============================================定时器T1初始化=======================================
 482          void Init_T1()
 483          {
 484   1              TMOD = (TMOD & 0xf0) | 0x10;//定时
 485   1              TH1 = (65536 - 2000) / 256;//2ms
 486   1              TL1 = (65536 - 2000) % 256;
 487   1              
 488   1              EA = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 9   

 489   1              ET1 = 1;
 490   1              TR1 = 1;
 491   1      }
 492          //============================================定时器T0初始化=======================================
 493          void Init_T0()
 494          {
 495   1              TMOD = (TMOD & 0xf0) | 0x05;//定时
 496   1              TH0 = 0;
 497   1              TL0 = 0;
 498   1              
 499   1              TR0 = 1;
 500   1      }
 501          //==========================================系统初始化=============================================
 502          void Init_Sys()
 503          {
 504   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 505   1              P0 = 0xff;
 506   1              P2 &= 0x1f;
 507   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 508   1              P0 = 0x00;
 509   1              P2 &= 0x1f;
 510   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 511   1              P0 = 0xff;
 512   1              P2 &= 0x1f;
 513   1              P2 = (P2 & 0x1f) | 0xe0;
 514   1              P0 = 0xff;
 515   1              
 516   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 517   1      }
 518          //==========================================LED控制=============================================
 519          void LED_control() {
 520   1              // ================= 测试开始 =============
 521   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 522   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 523   1      //      P2 &= 0x1f;
 524   1              // ================= 测试结束 =============
 525   1              
 526   1              // =========================================== 代码开始 ======================================
 527   1      //      if (trigger) {
 528   1      //              LED4_On();
 529   1      //      }
 530   1      //      else {
 531   1      //              LED4_Off();
 532   1      //      }
 533   1              
 534   1              if (dis_smg_model == 1) {
 535   2                      LED1_On();
 536   2              }
 537   1              else {
 538   2                      LED1_Off();
 539   2              }
 540   1              
 541   1              if (dis_smg_model == 2 || dis_smg_model == 3 || dis_smg_model == 4) {
 542   2                      LED2_On();
 543   2              }
 544   1              else {
 545   2                      LED2_Off();
 546   2              }
 547   1              
 548   1              if (dis_smg_model == 6) {
 549   2                      LED3_On();
 550   2              }
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 10  

 551   1              else {
 552   2                      LED3_Off();
 553   2              }
 554   1              
 555   1              LED7_Off();
 556   1              LED8_Off();
 557   1              // =========================================== 代码结束 ======================================
 558   1      }
 559          //==========================================频率数据处理=============================================
 560          void Handle_humi() {
 561   1              uint sum = 0;
 562   1              uchar i = 0;
 563   1              humi[(trigger_times - 1) % 10] = humi_smg;
 564   1              
 565   1              if (humi_smg > humi_max) {
 566   2                      humi_max = humi_smg;
 567   2              }
 568   1              
 569   1              // 求平均温度
 570   1              if (trigger_times < 10) {
 571   2                      for (i = 0; i < trigger_times; i ++ ) {
 572   3                              sum += humi[i];
 573   3                      }
 574   2                      
 575   2                      humi_ave = sum / trigger_times;
 576   2              }
 577   1              else {
 578   2                      for (i = 0; i < 10; i ++ ) {
 579   3                              sum += humi[i];
 580   3                      }
 581   2                      
 582   2                      humi_ave = sum / 10;
 583   2              }
 584   1      }
 585          //==========================================频率转湿度=============================================
 586          void Freq_to_humi() {
 587   1              float humi = 0;
 588   1              if (freq >= 200 && freq <= 2000) {
 589   2                      humi = 2.0 * (freq - 200) / 45.0;
 590   2                      
 591   2                      humi_smg = humi * 10;
 592   2                      LED5_Off();
 593   2                      
 594   2                      Handle_humi();
 595   2              }
 596   1              else {
 597   2                      humi_smg = 99;
 598   2                      LED5_On();
 599   2              }
 600   1      }
 601          void main()
 602          {
 603   1              Init_Sys();
 604   1              Init_T1();
 605   1              Init_T0();
 606   1              My_Write_Ds1302();
 607   1              
 608   1              Init_18b20();
 609   1              
 610   1              while(1)
 611   1              {
 612   2      //              LED_control();
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 11  

 613   2              if(f_2ms == 1)
 614   2              {
 615   3                  f_2ms = 0;                  
 616   3                              LED_control();  // xxx
 617   3                              
 618   3                              My_Read_Ds1302();  // 时间扫描
 619   3                              
 620   3                              // =======================按键========================
 621   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 622   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 623   3      //                      Change_Keys();        // 3.矩阵按键扫描
 624   3                              key_array_scan();     // 4.矩阵按键扫描(Ne555专用)
 625   3                              
 626   3                              // =========================================== 代码开始 ======================================
 627   3                              if (dis_smg_model == 1) {
 628   4                                      dis_smg_model_old = dis_smg_model;
 629   4                                      
 630   4                                      num1 = h_ds1302 / 10;num2 = h_ds1302 % 10;
 631   4                                      num3 = num6 = 11;
 632   4                                      num4 = m_ds1302 / 10;num5 = m_ds1302 % 10;
 633   4                                      num7 = s_ds1302 / 10;num8 = s_ds1302 % 10;
 634   4                              }
 635   3                              else if (dis_smg_model == 2) {  // C
 636   4                                      dis_smg_model_old = dis_smg_model;
 637   4                                      
 638   4                                      num1 = 12;
 639   4                                      
 640   4                                      if (trigger_times >= 1) {
 641   5                                              num2 = 10;
 642   5                                              num3 = temper_max / 100;num4 = temper_max % 100 / 10;
 643   5                                              num5 = 11;
 644   5                                              num6 = temper_ave / 100;num7 = temper_ave % 100 / 10;num8 = temper_ave % 10;
 645   5                                      }
 646   4                                      else {
 647   5                                              num2 = 10;
 648   5                                              num3 = 10;
 649   5                                              num6 = 10;
 650   5                                              num4 = 10;num5 = 10;
 651   5                                              num7 = 10;num8 = 10;
 652   5                                      }
 653   4                              }
 654   3                              else if (dis_smg_model == 3) {  // H
 655   4                                      dis_smg_model_old = dis_smg_model;
 656   4                                      
 657   4                                      num1 = 13;num2 = 10;
 658   4                                      
 659   4                                      if (trigger_times >= 1) {
 660   5                                              num3 = humi_max / 100;num4 = humi_max % 100/ 10;
 661   5                                              num5 = 11;
 662   5                                              num6 = humi_ave / 100;num7 = humi_ave % 100 / 10;num8 = humi_ave % 10;
 663   5                                      }
 664   4                                      else {
 665   5                                              num3 = 10;
 666   5                                              num6 = 10;
 667   5                                              num4 = 10;num5 = 10;
 668   5                                              num7 = 10;num8 = 10;
 669   5                                      }
 670   4                              }
 671   3                              else if (dis_smg_model == 4) {  // F
 672   4                                      dis_smg_model_old = dis_smg_model;
 673   4                                      
 674   4                                      num1 = 14;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 12  

 675   4                                      
 676   4                                      num2 = trigger_times / 10;
 677   4                                      num3 = trigger_times % 10;
 678   4                                      if (trigger_times >= 1) {
 679   5                                              num6 = 11;
 680   5                                              num4 = trigger_h_ds1302 / 10;num5 = trigger_h_ds1302 % 10;
 681   5                                              num7 = trigger_m_ds1302 / 10;num8 = trigger_m_ds1302 % 10;
 682   5                                      }
 683   4                                      else {
 684   5                                              num6 = 10;
 685   5                                              num4 = 10;num5 = 10;
 686   5                                              num7 = 10;num8 = 10;
 687   5                                      }
 688   4                              }
 689   3                              else if (dis_smg_model == 5) {  // P
 690   4                                      dis_smg_model_old = dis_smg_model;
 691   4                                      
 692   4                                      num1 = 15;
 693   4                                      num2 = 10;
 694   4                                      num3 = 10;
 695   4                                      num4 = 10;
 696   4                                      num5 = 10;
 697   4                                      num6 = 10;
 698   4                                      num7 = temp_param / 10;num8 = temp_param % 10;
 699   4                              }
 700   3                              else if (dis_smg_model == 6) {  // E
 701   4                                      num1 = 16;
 702   4                                      num2 = 10;
 703   4                                      num3 = 10;
 704   4                                      num4 = temper_smg / 100; num5 = temper_smg % 100 / 10;
 705   4                                      num6 = 11;
 706   4                                      if (humi_smg == 99) {
 707   5                                              num7 = 17;num8 = 17;
 708   5                                      }
 709   4                                      else {
 710   5                                              num7 = humi_smg / 100;num8 = humi_smg % 100 / 10;
 711   5                                      }
 712   4                              }
 713   3                              
 714   3      //                      num3 = freq / 10000;
 715   3      //                      num4 = freq % 10000 / 1000;
 716   3      //                      num5 = freq % 1000 / 100;
 717   3      //                      num6 = freq % 100 / 10;
 718   3      //                      num7 = freq % 10;
 719   3                              
 720   3                              // 读取
 721   3                              if (trigger == 0) {  // 只有在未触发时才能触发
 722   4                                      adc_value_read = Read_ADC(1);  // 读取光敏电阻
 723   4                                      if (adc_value_read < 50 && adc_value_old >= 50)
 724   4                                      {
 725   5                                              trigger = 1;
 726   5                                              trigger_time_2ms = 0;
 727   5                                              dis_smg_model = 6;
 728   5                                      }
 729   4                                      else {
 730   5                                              trigger = 0;
 731   5                                      }
 732   4                                      adc_value_old = adc_value_read;
 733   4                              }
 734   3                              
 735   3                              
 736   3                              if (trigger) {
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 13  

 737   4      //                              LED1_On();
 738   4                                      
 739   4                                      Freq_to_humi();
 740   4                                      temper_smg = Read_Temperature();
 741   4                                      if (humi_smg != 99) {
 742   5                                              Handle_temper();
 743   5                                      }
 744   4                                      
 745   4                                      
 746   4                                      if (trigger_times >= 2) {
 747   5                                              uchar n;
 748   5                                              n = (trigger_times -1)%10;
 749   5                                              if (n == 0) {
 750   6                                                      if (temper[0] > temper[9] && humi[0] > humi[9]) {
 751   7                                                              LED6_On();
 752   7                                                      }
 753   6                                                      else {
 754   7                                                              LED6_Off();
 755   7                                                      }
 756   6                                              }
 757   5                                              else {
 758   6                                                      if (temper[n] > temper[n - 1] && humi[n] > humi[n - 1]) {
 759   7                                                              LED6_On();
 760   7                                                      }
 761   6                                                      else {
 762   7                                                              LED6_Off();
 763   7                                                      }
 764   6                                              }
 765   5                                      }
 766   4                                      
 767   4                                      My_Read_Ds1302();  // 时间扫描
 768   4                                      trigger_h_ds1302 = h_ds1302;
 769   4                                      trigger_m_ds1302 = m_ds1302;
 770   4                                      trigger_s_ds1302 = s_ds1302;
 771   4                                      
 772   4      //                              dis_smg_model = 6;
 773   4                              }
 774   3                              else {
 775   4      //                              LED1_Off();
 776   4                              }
 777   3                              
 778   3                              if (temper_smg > temp_param * 10) {
 779   4                                      if (is_num_2ms_led) {
 780   5                                              LED4_On();
 781   5                                      }
 782   4                                      else {
 783   5                                              LED4_Off();
 784   5                                      }
 785   4                              }
 786   3                              else {
 787   4                                      LED4_Off();
 788   4                              }
 789   3                              // =========================================== 代码结束 ======================================
 790   3              }
 791   2          }
 792   1      }
 793          void Service_T1() interrupt 3
 794          {
 795   1              TH1 = (65536 - 2000) / 256;
 796   1              TL1 = (65536 - 2000) % 256;
 797   1              
 798   1              f_2ms = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 14  

 799   1              /***************************************************
 800   1              与时间相关的变量的更新放在里面
 801   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 802   1              ***************************************************/
 803   1              // =========================================== 代码开始 ======================================
 804   1              if (++ num_2ms_ne555 >= 500)
 805   1              {
 806   2                      num_2ms_ne555 = 0;
 807   2                      freq = (TH0 << 8) | TL0;
 808   2                      TH0 = 0;
 809   2                      TL0 = 0;
 810   2              }
 811   1              
 812   1              if (++ num_2ms_led >= 50) {
 813   2                      num_2ms_led = 0;
 814   2                      is_num_2ms_led = ~is_num_2ms_led;
 815   2              }
 816   1      
 817   1              // 触发测量
 818   1              if (trigger) {
 819   2                      if (++ trigger_time_2ms >= 1500) {  // 3s结束
 820   3                              trigger = 0;
 821   3                              trigger_time_2ms = 0;
 822   3                              
 823   3                              trigger_times ++ ;
 824   3                              dis_smg_model = dis_smg_model_old;  // 返回原状态
 825   3                      }
 826   2              }
 827   1              
 828   1              // s9长按
 829   1              if (is_long_press_s9) {
 830   2                      if (++ press_num_2ms_s9 >= 1000) {
 831   3                              press_num_2ms_s9 = 0;
 832   3                              
 833   3                              trigger_times = 0;  // 触发次数
 834   3                              trigger_h_ds1302 = 0;  // 时
 835   3                              trigger_m_ds1302 = 0;  // 分
 836   3                              trigger_s_ds1302 = 0;  // 秒
 837   3                              humi_smg = 0;
 838   3                              humi_max = 0;
 839   3                              humi_ave = 0;
 840   3                              temper_smg = 0;
 841   3                              temper_max = 0;
 842   3                              temper_ave = 0;
 843   3                              
 844   3                              is_long_press_s9 = 0;
 845   3                      }
 846   2              }
 847   1              // =========================================== 代码结束 ======================================
 848   1              
 849   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 850   1      }
*** WARNING C294 IN LINE 218 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2870    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     91      23
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 11:40:48 PAGE 15  

   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
