C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "onewire.h"
   3          
   4          #define uchar unsigned char 
   5          #define uint unsigned int
   6          
   7          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   8          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,
   9                                                    0xc6,  // C 12
  10                                                    0x89,  // H
  11                                                    0x8e,  // F
  12                                                    0x8c,  // P
  13                                                    0x86,  // E
  14                                                    0x88};
  15          // xxx
  16          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  17          
  18          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  19          uchar GN;  // 按键标志位
  20          bit f_2ms;  // 2ms标志位
  21          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  22          
  23          sbit S7 = P3^0;
  24          sbit S6 = P3^1;
  25          sbit S5 = P3^2;
  26          sbit S4 = P3^3;
  27          
  28          sbit L1 = P0^0;
  29          sbit L2 = P0^1;
  30          sbit L3 = P0^2;
  31          sbit L4 = P0^3;
  32          sbit L5 = P0^4;
  33          sbit L6 = P0^5;
  34          
  35          // =========================================== 代码开始 ======================================
  36          bit f_1s, f_10ms;  // 1s标志位
  37          
  38          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  39          
  40          unsigned int s9_press_time = 0;
  41          bit s9_long;
  42          // NE555
  43          uint num_2ms_ne555=0, freq;
  44          uint num_2ms_mesure_ne555, num_s_mesure_ne555;
  45          
  46          
  47          // 温度数据
  48          uint temperature_smg;
  49          // 湿度数据
  50          uint humi_smg;
  51          uint humi;
  52          // 状态标志
  53          uchar stat_smg = 1;  // 数码管标志
  54          bit is_runing_ne555;  // ne555是否在测量
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 2   

  55          uchar stat_trigger = 0;  // 触发状态
  56          
  57          
  58          // =========================================== 代码结束 ======================================
  59          
  60          
  61          //=========================================普通延时函数(模板函数)=================================
  62          void Delay(uint t) {
  63   1              while( t -- );
  64   1              while( t -- );
  65   1      }
  66          //=======================================单个LED控制函数(模板函数)================================
  67          // ======================LED1====================
  68          void LED1_On() {
  69   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  70   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  71   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  72   1              temp_Led_P0 = P0;
  73   1              P2 &= 0x1f;
  74   1      }
  75          void LED1_Off() {
  76   1              P0 = 0xff & temp_Led_P0;
  77   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  78   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  79   1              temp_Led_P0 = P0;
  80   1              P2 &= 0x1f;
  81   1      }
  82          // ======================LED2====================
  83          void LED2_On() {
  84   1              P0 = 0xff & temp_Led_P0;
  85   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  86   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  87   1              temp_Led_P0 = P0;
  88   1              P2 &= 0x1f;
  89   1      }
  90          void LED2_Off() {
  91   1              P0 = 0xff & temp_Led_P0;
  92   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  93   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  94   1              temp_Led_P0 = P0;
  95   1              P2 &= 0x1f;
  96   1      }
  97          // ======================LED3====================
  98          void LED3_On() {
  99   1              P0 = 0xff & temp_Led_P0;
 100   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 101   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 102   1              temp_Led_P0 = P0;
 103   1              P2 &= 0x1f;
 104   1      }
 105          void LED3_Off() {
 106   1              P0 = 0xff & temp_Led_P0;
 107   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 108   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 109   1              temp_Led_P0 = P0;
 110   1              P2 &= 0x1f;
 111   1      }
 112          // ======================LED4====================
 113          void LED4_On() {
 114   1              P0 = 0xff & temp_Led_P0;
 115   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 116   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 3   

 117   1              temp_Led_P0 = P0;
 118   1              P2 &= 0x1f;
 119   1      }
 120          void LED4_Off() {
 121   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 122   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 123   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 124   1              temp_Led_P0 = P0;
 125   1              P2 &= 0x1f;
 126   1      }
 127          // ======================LED5====================
 128          void LED5_On() {
 129   1              P0 = 0xff & temp_Led_P0;
 130   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 131   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 132   1              temp_Led_P0 = P0;
 133   1              P2 &= 0x1f;
 134   1      }
 135          void LED5_Off() {
 136   1              P0 = 0xff & temp_Led_P0;
 137   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 138   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 139   1              temp_Led_P0 = P0;
 140   1              P2 &= 0x1f;
 141   1      }
 142          // ======================LED6====================
 143          void LED6_On() {
 144   1              P0 = 0xff & temp_Led_P0;
 145   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 146   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 147   1              temp_Led_P0 = P0;
 148   1              P2 &= 0x1f;
 149   1      }
 150          void LED6_Off() {
 151   1              P0 = 0xff & temp_Led_P0;
 152   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 153   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 154   1              temp_Led_P0 = P0;
 155   1              P2 &= 0x1f;
 156   1      }
 157          
 158          void LED_On(uchar n) {
 159   1              P0 = 0xff & temp_Led_P0;
 160   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 161   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 162   1              temp_Led_P0 = P0;
 163   1              P2 &= 0x1f;
 164   1      }
*** WARNING C280 IN LINE 158 OF main.c: 'n': unreferenced local variable
 165          //=========================================数码管显示==============================================
 166          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 167          {
 168   1              char i;
 169   1              P0 = 0xff;
 170   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 171   1              P0 = type2[i];
 172   1              P2 &= 0x1f;
 173   1              switch(i)//数码管位选
 174   1              {
 175   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 176   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 177   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 4   

 178   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 179   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 180   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 181   2                                                                              if(0)  // 根据需要的条件
 182   2                                                                              {
 183   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 184   3                                                                              }
 185   2                                                                              else
 186   2                                                                                      P0 = type1[n6];
 187   2                                                                                                        P2 &= 0x1f;break;
 188   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 189   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 190   2              }
 191   1              if(++i==8)
 192   1                      i = 0;
 193   1      }
 194          //============================================独立按键============================================
 195          /***************************************************
 196          写法一：
 197          有按键被按下，GN标记，后面根据需要功能进行操作
 198          ***************************************************/
 199          void Delay_Keys(uint t)
 200          {
 201   1              while(t--);
 202   1      }
 203          uchar Scan_Keys_Alone()
 204          {
 205   1              char d;
 206   1              d = (~P3) & 0x0f;
 207   1              if(d == 0) return 0;
 208   1              Delay_Keys(100);
 209   1              if(d == 0) return 0;
 210   1              Delay_Keys(100);
 211   1              return d;
 212   1      }
 213          void Change_Keys_Alone()
 214          {
 215   1              switch(Scan_Keys_Alone())
 216   1              {
 217   2                      case 8:GN = 1;break;//S4
 218   2                      case 4:GN = 2;break;//S5
 219   2                      case 2:GN = 3;break;//S6
 220   2                      case 1:GN = 4;break;//S7
 221   2                      case 0:GN = 0;break;
 222   2              }
 223   1      }
 224          
 225          /***************************************************
 226          写法二：
 227          有按键被按下，按下是一种状态，松开是另一种状态
 228          （如：按下时某个灯亮，松开时灯灭）
 229          ***************************************************/
 230          void ScanKeys_Alone() 
 231          {
 232   1              if (S7 == 0) {
 233   2                      Delay_Keys(100);
 234   2                      if (S7 == 0) {
 235   3                              // =========================================== 代码开始 ======================================
 236   3                              
 237   3                              // =========================================== 代码结束 ======================================
 238   3                              while(S7 == 0);
 239   3                              // =========================================== 代码开始 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 5   

 240   3      
 241   3                              // =========================================== 代码结束 ======================================
 242   3                      }
 243   2              }
 244   1              
 245   1              if (S6 == 0) {
 246   2                      Delay_Keys(100);
 247   2                      if (S6 == 0) {
 248   3                              // =========================================== 代码开始 ======================================
 249   3                              
 250   3                              // =========================================== 代码结束 ======================================
 251   3                              while(S6 == 0);
 252   3                              // =========================================== 代码开始 ======================================
 253   3      
 254   3                              // =========================================== 代码结束 ======================================
 255   3                      }
 256   2              }
 257   1              
 258   1              if (S5 == 0) {
 259   2                      Delay_Keys(100);
 260   2                      if (S5 == 0) {
 261   3                              // =========================================== 代码开始 ======================================
 262   3      
 263   3                              // =========================================== 代码结束 ======================================
 264   3                              while(S5 == 0);
 265   3                              // =========================================== 代码开始 ======================================
 266   3      
 267   3                              // =========================================== 代码结束 ======================================
 268   3                      }
 269   2              }
 270   1      
 271   1              if (S4 == 0) {
 272   2                      Delay_Keys(100);
 273   2                      if (S4 == 0) {
 274   3                              // =========================================== 代码开始 ======================================
 275   3      
 276   3                              // =========================================== 代码结束 ======================================
 277   3                              while(S4 == 0);
 278   3                              // =========================================== 代码开始 ======================================
 279   3      
 280   3                              // =========================================== 代码结束 ======================================
 281   3                      }
 282   2              }
 283   1      }
 284          
 285          // ================= 代码结束 =============
 286          
 287          //============================================矩阵按键============================================
 288          sfr P4 = 0xc0;
 289          sbit P44 = P4^4;
 290          sbit P42 = P4^2;
 291          
 292          uchar Scan_Keys()
 293          {
 294   1              char H,L;
 295   1              
 296   1      //      TR0 = 0;
 297   1              
 298   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 299   1              if(H == 0) return 0;
 300   1              Delay_Keys(100);
 301   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 6   

 302   1              if(H == 0) return 0;
 303   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 304   1              if(P44 == 0) L |= 0x80;
 305   1              if(P42 == 0) L |= 0x40;
 306   1              
 307   1      //      TR0 = 1;
 308   1              
 309   1              return (H+L);
 310   1      }
 311          
 312          void Change_Keys()
 313          {
 314   1              switch(Scan_Keys())
 315   1              {
 316   2                      case 0x88:GN = 4;break;  // S4
 317   2                      case 0x84:GN = 5;break;  // S5
 318   2                      case 0x82:GN = 6;break;  // S6
 319   2                      case 0x81:GN = 7;break;  // S7
 320   2                      case 0x48:GN = 8;break;  // S8
 321   2                      case 0x44:GN = 9;break;  // S9
 322   2                      case 0x42:GN = 10;break;  // S10
 323   2                      case 0x41:GN = 11;break;  // S11
 324   2                      case 0x28:GN = 12;break;  // S12
 325   2                      case 0x24:GN = 13;break;  // S13
 326   2                      case 0x22:GN = 14;break;  // S14
 327   2                      case 0x21:GN = 15;break;  // S15
 328   2                      case 0x18:GN = 16;break;  // S16
 329   2                      case 0x14:GN = 17;break;  // S17
 330   2                      case 0x12:GN = 18;break;  // S18
 331   2                      case 0x11:GN = 19;break;  // S19
 332   2                      case 0:GN = 0;break;
 333   2              }
 334   1      }
 335          
 336          //sbit P32 = P3^2;
 337          //sbit P33 = P3^3;
 338          //void key_array_init() {
 339          //      P32 = 1;
 340          //      P33 = 1;
 341          //      P42 = 0;
 342          //      P44 = 0;
 343          //}
 344          //============================================DS18B20初始化============================================
 345          void Init_18b20()
 346          {
 347   1              char i;
 348   1              init_ds18b20();
 349   1              Write_DS18B20(0xcc);
 350   1              Write_DS18B20(0x44);  // 启动温度转换
 351   1      //      Write_DS18B20(0x00);
 352   1      //      Write_DS18B20(0x00);
 353   1      //      Write_DS18B20(0x7f);
 354   1              
 355   1              for (i = 0; i < 8; i ++ ) {  // 等待第一次采集结束，不会显示85
 356   2                      Delay_Keys(60000);
 357   2              }
 358   1      }
 359          
 360          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 361                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 362                                                                           // 和一位小数可用unsigned char.
 363          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 7   

 364   1              unsigned char H,L;
 365   1              
 366   1              init_ds18b20();
 367   1              Write_DS18B20(0xcc);
 368   1              Write_DS18B20(0x44);
 369   1              init_ds18b20();
 370   1              Write_DS18B20(0xcc);
 371   1              Write_DS18B20(0xbe);
 372   1              L = Read_DS18B20();
 373   1              H = Read_DS18B20();
 374   1              
 375   1              init_ds18b20();
 376   1              Write_DS18B20(0xcc);
 377   1              Write_DS18B20(0x44);
 378   1              
 379   1              //1.保留整数--23
 380   1              //temp = (H<<4) + (L>>4);
 381   1              
 382   1              //2.保留1位小数--23.4
 383   1              return ((H<<8) + L)*5/8;
 384   1              
 385   1              //3.保留2位小数--23.45
 386   1      //      return ((H<<8)+L)*25/4;  // (50/8)
 387   1      }
 388          //============================================定时器T1初始化=======================================
 389          void Init_T1()
 390          {
 391   1              TMOD = (TMOD & 0xf0) | 0x10;//定时
 392   1              TH1 = (65536 - 2000) / 256;//2ms
 393   1              TL1 = (65536 - 2000) % 256;
 394   1              
 395   1              EA = 1;
 396   1              ET1 = 1;
 397   1              TR1 = 1;
 398   1      }
 399          //============================================定时器T0初始化=======================================
 400          void Init_T0()
 401          {
 402   1              TMOD = (TMOD & 0xf0) | 0x05;//定时
 403   1              TH0 = 0;
 404   1              TL0 = 0;
 405   1              
 406   1              TR0 = 1;
 407   1      }
 408          //==========================================系统初始化=============================================
 409          void Init_Sys()
 410          {
 411   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 412   1              P0 = 0xff;
 413   1              P2 &= 0x1f;
 414   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 415   1              P0 = 0x00;
 416   1              P2 &= 0x1f;
 417   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 418   1              P0 = 0xff;
 419   1              P2 &= 0x1f;
 420   1              P2 = (P2 & 0x1f) | 0xe0;
 421   1              P0 = 0xff;
 422   1              
 423   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 424   1      }
 425          
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 8   

 426          void LED_control() {
 427   1              // ================= 测试开始 =============
 428   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 429   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 430   1      //      P2 &= 0x1f;
 431   1              // ================= 测试结束 =============
 432   1              
 433   1              // =========================================== 代码开始 ======================================
 434   1              
 435   1              // =========================================== 代码结束 ======================================
 436   1      }
 437          
 438          //==========================================频率转湿度=============================================
 439          void Freq_to_Humi() {
 440   1              float humi = 0;
 441   1              if (freq >= 200 && freq <= 2000) {
 442   2                      humi = 0.05 * (freq - 200);
 443   2                      humi_smg = humi * 10;
 444   2                      LED5_Off();
 445   2              }
 446   1              else {
 447   2                      humi_smg = 99;
 448   2                      LED5_On();
 449   2              }
 450   1      }
 451          
 452          //==========================================数码管显示=============================================
 453          sbit P32 = P3^2;
 454          sbit P33 = P3^3;
 455          sbit P30 = P3^0;
 456          void key_array_init() {
 457   1              P30 = 1;
 458   1              P32 = 1;
 459   1              P33 = 1;
 460   1              P42 = 0;
 461   1              P44 = 0;
 462   1      }
 463          
 464          void key_array_scan() { 
 465   1              if (P32 == 0) {
 466   2                      P32 = 0;
 467   2                      P42 = 1;
 468   2                      P44 = 1;
 469   2                      if (P42 == 0) {
 470   3                              Delay_Keys(100);
 471   3                              if (P42 == 0) {  // S9
 472   4                                      // =========================================== 代码开始 ======================================
 473   4                                      LED1_On();
 474   4                                      // =========================================== 代码结束 ======================================
 475   4                                      while (P42 == 0);
 476   4                                      // =========================================== 代码开始 ======================================
 477   4                                      LED1_Off();
 478   4                                      // =========================================== 代码结束 ======================================
 479   4                              }
 480   3                      }
 481   2                      else if (P44 == 0) {
 482   3                              Delay_Keys(100);
 483   3                              if (P44 == 0) {    // S5
 484   4                                      // =========================================== 代码开始 ======================================
 485   4                                      LED1_On();
 486   4                                      
 487   4                                      if (stat_smg == 2) {  // 时间显示
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 9   

 488   5                                              stat_smg = 3;
 489   5                                      }
 490   4                                      else if (stat_smg == 3 ) {
 491   5                                              stat_smg = 4;
 492   5                                      }
 493   4                                      else if (stat_smg == 4) {
 494   5                                              stat_smg = 2;
 495   5                                      }
 496   4                                      // =========================================== 代码结束 ======================================
 497   4                                      while (P44 == 0);
 498   4                                      // =========================================== 代码开始 ======================================
 499   4                                      LED1_Off();
 500   4                                      // =========================================== 代码结束 ======================================
 501   4                              }
 502   3                      }
 503   2              }
 504   1              
 505   1              if (P33 == 0) {
 506   2                      P33 = 0;
 507   2                      P42 = 1;
 508   2                      P44 = 1;
 509   2                      if (P42 == 0) {
 510   3                              Delay_Keys(100);
 511   3                              if (P42 == 0) {  // S8
 512   4                                      // =========================================== 代码开始 ======================================
 513   4                                      LED1_On();
 514   4                                      // =========================================== 代码结束 ======================================
 515   4                                      while (P42 == 0);
 516   4                                      // =========================================== 代码开始 ======================================
 517   4                                      LED1_Off();
 518   4                                      // =========================================== 代码结束 ======================================
 519   4                              }
 520   3                      }
 521   2                      else if (P44 == 0) {
 522   3                              Delay_Keys(100);
 523   3                              if (P44 == 0) {  // S4
 524   4                                      // =========================================== 代码开始 ======================================
 525   4                                      LED1_On();
 526   4                                      
 527   4                                      if (stat_smg == 1) {  // 时间显示
 528   5                                              stat_smg = 2;
 529   5                                      }
 530   4                                      else if (stat_smg == 2 | stat_smg == 3 | stat_smg == 4) {
 531   5                                              stat_smg = 5;
 532   5                                      }
 533   4                                      else if (stat_smg == 5) {
 534   5                                              stat_smg = 1;
 535   5                                      }
 536   4                                      // =========================================== 代码结束 ======================================
 537   4                                      while(P44 == 0);
 538   4                                      // =========================================== 代码开始 ======================================
 539   4                                      LED1_Off();
 540   4                                      // =========================================== 代码结束 ======================================
 541   4                              }
 542   3                      }
 543   2              }
 544   1              
 545   1              if (P30 == 0) {
 546   2                      P30 = 0;
 547   2                      P44 = 1;
 548   2                      if (P44 == 0) {
 549   3                              Delay_Keys(100);
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 10  

 550   3                              if (P44 == 0) {  // S7
 551   4                                      // =========================================== 代码开始 ======================================
 552   4                                      LED1_On();
 553   4                                      is_runing_ne555 = 1;
 554   4                                      s9_press_time = 0;
 555   4                                      stat_trigger = 1;  // 触发测量
 556   4                                      
 557   4      //                              num_2ms_mesure_ne555 = 0;
 558   4      //                              num_s_mesure_ne555 = 0;
 559   4      //                              while(Scan_Keys());
 560   4                                      LED4_Off();
 561   4                                      // =========================================== 代码结束 ======================================
 562   4                                      while(P44 == 0);
 563   4                                      // =========================================== 代码开始 ======================================
 564   4                                      LED1_Off();
 565   4                                      // =========================================== 代码结束 ======================================
 566   4                              }
 567   3                      }
 568   2              }
 569   1              
 570   1              key_array_init();
 571   1      }
 572          
 573          void Dis_smg() {
 574   1              if (stat_smg == 1) {
 575   2                      num1 = 10;
 576   2                      num3 = num6 = 11;
 577   2              }
 578   1              else if (stat_smg == 2) {
 579   2                      num1 = 12;
 580   2              }
 581   1              else if (stat_smg == 3) {
 582   2                      num1 = 13;
 583   2              }
 584   1              else if (stat_smg == 4) {
 585   2                      num1 = 14;
 586   2              }
 587   1              else if (stat_smg == 5) {
 588   2                      num1 = 15;
 589   2              }
 590   1              else if (stat_smg == 6) {
 591   2                      
 592   2              }
 593   1              
 594   1      
 595   1      }
 596          
 597          void main()
 598          {
 599   1              Init_Sys();
 600   1              Init_T1();
 601   1              Init_T0();
 602   1              
 603   1              Init_18b20();
 604   1              
 605   1              while(1)
 606   1              {
 607   2      //              if (f_10ms == 1 && is_runing_ne555 == 0) {
 608   2      //                      f_10ms = 0;
 609   2      //                      TR0 = 0;
 610   2      //                      Change_Keys();
 611   2      //                      TR0 = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 11  

 612   2      //              }
 613   2                      
 614   2      //              LED_control();
 615   2              if(f_2ms == 1)
 616   2              {
 617   3                  f_2ms = 0;                  
 618   3                              LED_control();  // xxx  
 619   3                              Dis_smg();  // 数码管显示
 620   3                              // =======================按键========================
 621   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 622   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 623   3      //                      Change_Keys();        // 3.矩阵按键扫描
 624   3      //                      key_array_scan();     // 4.矩阵按键扫描
 625   3      //                      if (!is_runing_ne555) {
 626   3      //                              f_10ms = 0;
 627   3      //                              TR0 = 0;
 628   3      //                              Change_Keys();
 629   3      //                              TR0 = 1;
 630   3      //                      }
 631   3                              key_array_scan();
 632   3                              // =========================================== 代码开始 ======================================
 633   3                              if (stat_trigger == 1) {
 634   4                                      Freq_to_Humi();
 635   4                                      temperature_smg = Read_Temperature();
 636   4                                      
 637   4                                      stat_smg = 6;
 638   4                                      
 639   4                                      num1 = 16;
 640   4                                      num2=num3 = 10;
 641   4                                      
 642   4                                      num4 = temperature_smg / 100;
 643   4                                      num5 = temperature_smg % 100 / 10;
 644   4                                      num6 = 11;
 645   4                                      num7 = humi_smg / 100;
 646   4                                      num8 = humi_smg % 100 / 10;
 647   4                                      
 648   4                                      while (stat_trigger);
 649   4                              }
 650   3                              // =========================================== 代码结束 ======================================
 651   3              }
 652   2          }
 653   1      }
 654          void Service_T1() interrupt 3
 655          {
 656   1              TH1 = (65536 - 2000) / 256;
 657   1              TL1 = (65536 - 2000) % 256;
 658   1              
 659   1              f_2ms = 1;
 660   1              
 661   1              if (++ num_2ms == 5) {
 662   2                      num_2ms = 0;
 663   2                      f_10ms = 1;
 664   2              }
 665   1              /***************************************************
 666   1              与时间相关的变量的更新放在里面
 667   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 668   1              ***************************************************/
 669   1              // =========================================== 代码开始 ======================================
 670   1      //      if (GN == 4) {
 671   1      //              s9_press_time ++ ;
 672   1      //              if (s9_press_time >= 1000) {
 673   1      //                      s9_press_time = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 01:34:07 PAGE 12  

 674   1      ////                    s9_long = 1;
 675   1      //                      LED4_On();
 676   1      //              }
 677   1      //      }
 678   1              
 679   1              if (stat_trigger) {
 680   2                      if (++ num_2ms_mesure_ne555 >= 500) {
 681   3                              num_2ms_mesure_ne555 = 0;
 682   3                              num_s_mesure_ne555 ++ ;
 683   3                      }
 684   2                      if (num_s_mesure_ne555 >= 3) {
 685   3                              num_s_mesure_ne555 = 0;
 686   3      //                      TR0 = 0;
 687   3                              stat_trigger = 0;
 688   3                              stat_smg = 2;  // 测量完返回界面2
 689   3                      }
 690   2              }
 691   1              
 692   1              if (++ num_2ms_ne555 >= 500)
 693   1              {
 694   2                      num_2ms_ne555 = 0;
 695   2                      freq = (TH0 << 8) | TL0;
 696   2                      
 697   2                      TH0 = 0;
 698   2                      TL0 = 0;
 699   2              }
 700   1              // =========================================== 代码结束 ======================================
 701   1              
 702   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 703   1      }
*** WARNING C294 IN LINE 183 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1738    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
