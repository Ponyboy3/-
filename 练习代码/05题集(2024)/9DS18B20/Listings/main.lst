C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "onewire.h"
   3          #include "iic.h"
   4          #include "ds1302.h"
   5          
   6          #define uchar unsigned char 
   7          #define uint unsigned int
   8          
   9          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
  10          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
  11          // xxx
  12          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  13          
  14          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  15          uchar GN;  // 按键标志位
  16          bit f_2ms, f_50ms, f_200ms_temperature;  // 2ms, 50ms, 500ms标志位
  17          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  18          uint temperature;  // 温度
  19          uint num_2ms_temperature;  // 多少个2ms
  20          
  21          sbit S7 = P3^0;
  22          sbit S6 = P3^1;
  23          sbit S5 = P3^2;
  24          sbit S4 = P3^3;
  25          
  26          sbit L0 = P0^0;
  27          sbit L1 = P0^1;
  28          sbit L2 = P0^2;
  29          sbit L3 = P0^3;
  30          sbit L4 = P0^4;
  31          sbit L5 = P0^5;
  32          sbit L6 = P0^6;
  33          
  34          // =========================================== 代码开始 ======================================
  35          bit f_1s;  // 1s标志位
  36          
  37          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  38          
  39          uchar urdat;    
  40          // =========================================== 代码结束 ======================================
  41          
  42          
  43          //=========================================普通延时函数(模板函数)=================================
  44          void Delay(uint t) {
  45   1              while( t -- );
  46   1              while( t -- );
  47   1      }
  48          //=======================================单个LED控制函数(模板函数)================================
  49          // 根据项目需要删减
  50          
  51          // ======================LED0====================
  52          void LED0_On() {
  53   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  54   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 2   

  55   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  56   1              temp_Led_P0 = P0;
  57   1              P2 &= 0x1f;
  58   1      }
  59          void LED0_Off() {
  60   1              P0 = 0xff & temp_Led_P0;
  61   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  62   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  63   1              temp_Led_P0 = P0;
  64   1              P2 &= 0x1f;
  65   1      }
  66          // ======================LED1====================
  67          void LED1_On() {
  68   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  69   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  70   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  71   1              temp_Led_P0 = P0;
  72   1              P2 &= 0x1f;
  73   1      }
  74          void LED1_Off() {
  75   1              P0 = 0xff & temp_Led_P0;
  76   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  77   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  78   1              temp_Led_P0 = P0;
  79   1              P2 &= 0x1f;
  80   1      }
  81          // ======================LED2====================
  82          void LED2_On() {
  83   1              P0 = 0xff & temp_Led_P0;
  84   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  85   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  86   1              temp_Led_P0 = P0;
  87   1              P2 &= 0x1f;
  88   1      }
  89          void LED2_Off() {
  90   1              P0 = 0xff & temp_Led_P0;
  91   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  92   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  93   1              temp_Led_P0 = P0;
  94   1              P2 &= 0x1f;
  95   1      }
  96          // ======================LED3====================
  97          void LED3_On() {
  98   1              P0 = 0xff & temp_Led_P0;
  99   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 100   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 101   1              temp_Led_P0 = P0;
 102   1              P2 &= 0x1f;
 103   1      }
 104          void LED3_Off() {
 105   1              P0 = 0xff & temp_Led_P0;
 106   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 107   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 108   1              temp_Led_P0 = P0;
 109   1              P2 &= 0x1f;
 110   1      }
 111          // ======================LED4====================
 112          void LED4_On() {
 113   1              P0 = 0xff & temp_Led_P0;
 114   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 115   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 116   1              temp_Led_P0 = P0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 3   

 117   1              P2 &= 0x1f;
 118   1      }
 119          void LED4_Off() {
 120   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 121   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 122   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 123   1              temp_Led_P0 = P0;
 124   1              P2 &= 0x1f;
 125   1      }
 126          // ======================LED5====================
 127          void LED5_On() {
 128   1              P0 = 0xff & temp_Led_P0;
 129   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 130   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 131   1              temp_Led_P0 = P0;
 132   1              P2 &= 0x1f;
 133   1      }
 134          void LED5_Off() {
 135   1              P0 = 0xff & temp_Led_P0;
 136   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 137   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 138   1              temp_Led_P0 = P0;
 139   1              P2 &= 0x1f;
 140   1      }
 141          // ======================LED6====================
 142          void LED6_On() {
 143   1              P0 = 0xff & temp_Led_P0;
 144   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 145   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 146   1              temp_Led_P0 = P0;
 147   1              P2 &= 0x1f;
 148   1      }
 149          void LED6_Off() {
 150   1              P0 = 0xff & temp_Led_P0;
 151   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 152   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 153   1              temp_Led_P0 = P0;
 154   1              P2 &= 0x1f;
 155   1      }
 156          //=========================================数码管显示==============================================
 157          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 158          {
 159   1              char i;
 160   1              P0 = 0xff;
 161   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 162   1              P0 = type2[i];
 163   1              P2 &= 0x1f;
 164   1              switch(i)//数码管位选
 165   1              {
 166   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 167   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 168   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 169   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 170   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 171   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 172   2                                                                              if(1)  // 根据需要的条件
 173   2                                                                              {
 174   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 175   3                                                                              }
 176   2                                                                              else
 177   2                                                                                      P0 = type1[n6];
 178   2                                                                                                        P2 &= 0x1f;break;
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 4   

 179   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 180   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 181   2              }
 182   1              if(++i==8)
 183   1                      i = 0;
 184   1      }
 185          //============================================独立按键============================================
 186          /***************************************************
 187          写法一：
 188          有按键被按下，GN标记，后面根据需要功能进行操作
 189          ***************************************************/
 190          void Delay_Keys(uint t)
 191          {
 192   1              while(t--);
 193   1      }
 194          uchar Scan_Keys_Alone()
 195          {
 196   1              char d;
 197   1              d = (~P3) & 0x0f;
 198   1              if(d == 0) return 0;
 199   1              Delay_Keys(100);
 200   1              if(d == 0) return 0;
 201   1              Delay_Keys(100);
 202   1              return d;
 203   1      }
 204          void Change_Keys_Alone()
 205          {
 206   1              switch(Scan_Keys_Alone())
 207   1              {
 208   2                      case 8:GN = 1;break;//S4
 209   2                      case 4:GN = 2;break;//S5
 210   2                      case 2:GN = 3;break;//S6
 211   2                      case 1:GN = 4;break;//S7
 212   2                      case 0:GN = 0;break;
 213   2              }
 214   1      }
 215          
 216          /***************************************************
 217          写法二：
 218          有按键被按下，按下是一种状态，松开是另一种状态
 219          （如：按下时某个灯亮，松开时灯灭）
 220          ***************************************************/
 221          void ScanKeys_Alone() 
 222          {
 223   1              if (S7 == 0) {
 224   2                      Delay_Keys(100);
 225   2                      if (S7 == 0) {
 226   3                              // =========================================== 代码开始 ======================================
 227   3                              
 228   3                              // =========================================== 代码结束 ======================================
 229   3                              while(S7 == 0);
 230   3                              // =========================================== 代码开始 ======================================
 231   3      
 232   3                              // =========================================== 代码结束 ======================================
 233   3                      }
 234   2              }
 235   1              
 236   1              if (S6 == 0) {
 237   2                      Delay_Keys(100);
 238   2                      if (S6 == 0) {
 239   3                              // =========================================== 代码开始 ======================================
 240   3                              
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 5   

 241   3                              // =========================================== 代码结束 ======================================
 242   3                              while(S6 == 0);
 243   3                              // =========================================== 代码开始 ======================================
 244   3      
 245   3                              // =========================================== 代码结束 ======================================
 246   3                      }
 247   2              }
 248   1              
 249   1              if (S5 == 0) {
 250   2                      Delay_Keys(100);
 251   2                      if (S5 == 0) {
 252   3                              // =========================================== 代码开始 ======================================
 253   3      
 254   3                              // =========================================== 代码结束 ======================================
 255   3                              while(S5 == 0);
 256   3                              // =========================================== 代码开始 ======================================
 257   3      
 258   3                              // =========================================== 代码结束 ======================================
 259   3                      }
 260   2              }
 261   1      
 262   1              if (S4 == 0) {
 263   2                      Delay_Keys(100);
 264   2                      if (S4 == 0) {
 265   3                              // =========================================== 代码开始 ======================================
 266   3      
 267   3                              // =========================================== 代码结束 ======================================
 268   3                              while(S4 == 0);
 269   3                              // =========================================== 代码开始 ======================================
 270   3      
 271   3                              // =========================================== 代码结束 ======================================
 272   3                      }
 273   2              }
 274   1      }
 275          
 276          // ================= 代码结束 =============
 277          
 278          //============================================矩阵按键============================================
 279          sfr P4 = 0xc0;
 280          sbit P44 = P4^4;
 281          sbit P42 = P4^2;
 282          
 283          uchar Scan_Keys()
 284          {
 285   1              char H,L;
 286   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 287   1              if(H == 0) return 0;
 288   1              Delay_Keys(100);
 289   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 290   1              if(H == 0) return 0;
 291   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 292   1              if(P44 == 0) L |= 0x80;
 293   1              if(P42 == 0) L |= 0x40;
 294   1              return (H+L);
 295   1      }
 296          
 297          void Change_Keys()
 298          {
 299   1              switch(Scan_Keys())
 300   1              {
 301   2                      case 0x88:GN = 4;break;  // S4
 302   2                      case 0x84:GN = 5;break;  // S5
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 6   

 303   2                      case 0x82:GN = 6;break;  // S6
 304   2                      case 0x81:GN = 7;break;  // S7
 305   2                      case 0x48:GN = 8;break;  // S8
 306   2                      case 0x44:GN = 9;break;  // S9
 307   2                      case 0x42:GN = 10;break;  // S10
 308   2                      case 0x41:GN = 11;break;  // S11
 309   2                      case 0x28:GN = 12;break;  // S12
 310   2                      case 0x24:GN = 13;break;  // S13
 311   2                      case 0x22:GN = 14;break;  // S14
 312   2                      case 0x21:GN = 15;break;  // S15
 313   2                      case 0x18:GN = 16;break;  // S16
 314   2                      case 0x14:GN = 17;break;  // S17
 315   2                      case 0x12:GN = 18;break;  // S18
 316   2                      case 0x11:GN = 19;break;  // S19
 317   2                      case 0:GN = 0;break;
 318   2              }
 319   1      }
 320          //============================================24C02初始化============================================
 321          void Write_24C02(unsigned char addr,unsigned char dat)
 322          {
 323   1              I2CStart();
 324   1              I2CSendByte(0xa0);
 325   1              I2CWaitAck();
 326   1              I2CSendByte(addr);
 327   1              I2CWaitAck();
 328   1              I2CSendByte(dat);
 329   1              I2CWaitAck();
 330   1              I2CStop(); 
 331   1      }
 332          
 333          unsigned char Read_24C02(unsigned char addr)
 334          {
 335   1              unsigned char tmp;
 336   1              I2CStart();
 337   1              I2CSendByte(0xa0);
 338   1              I2CWaitAck();
 339   1              I2CSendByte(addr);
 340   1              I2CWaitAck();
 341   1              
 342   1              I2CStart();
 343   1              I2CSendByte(0xa1);
 344   1              I2CWaitAck();
 345   1              tmp = I2CRecByte(); 
*** WARNING C206 IN LINE 345 OF main.c: 'I2CRecByte': missing function-prototype
 346   1              I2CSendAck(1);
 347   1              I2CStop();
 348   1              
 349   1              return tmp;
 350   1      }
 351          //============================================DS18B20初始化============================================
 352          void Init_18b20()
 353          {
 354   1              init_ds18b20();
 355   1              Write_DS18B20(0xcc);
 356   1              Write_DS18B20(0x4e);
 357   1              Write_DS18B20(0x00);
 358   1              Write_DS18B20(0x00);
 359   1              Write_DS18B20(0x7f);
 360   1      }
 361          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 362                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 363                                                                           // 和一位小数可用unsigned char.
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 7   

 364          {
 365   1              unsigned char H,L;
 366   1              init_ds18b20();
 367   1              Write_DS18B20(0xcc);
 368   1              Write_DS18B20(0xbe);
 369   1              L = Read_DS18B20();
 370   1              H = Read_DS18B20();
 371   1              
 372   1              init_ds18b20();
 373   1              Write_DS18B20(0xcc);
 374   1              Write_DS18B20(0x44);
 375   1              
 376   1              //1.保留整数--23
 377   1              //temp = (H<<4) + (L>>4);
 378   1              
 379   1              //2.保留1位小数--23.4
 380   1              //temp = ((H<<8) + L)*5/8;
 381   1              
 382   1              //3.保留2位小数--23.45
 383   1              return ((H<<8)+L)*25/4;  // (50/8)
 384   1      }
 385          //============================================Ds1302初始化============================================
 386          
 387          //============================================定时器T0初始化=======================================
 388          uchar count = 0;
 389          uchar pwm_dut = 0;//占空比
 390          void Init_T0()
 391          {
 392   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 393   1              TH0 = (65536 - 2000) / 256;
 394   1              TL0 = (65536 - 2000) % 256;
 395   1              
 396   1              EA = 1;
 397   1              ET0 = 1;
 398   1              TR0 = 1;
 399   1      }
 400          //============================================定时器T1初始化=======================================
 401          //void Init_T1()
 402          //{
 403          //      TMOD = (TMOD & 0x0f) | 0x10;//定时
 404          //      TH1 = (65536 - 2000) / 256;//2ms
 405          //      TL1 = (65536 - 2000) % 256;
 406          //      
 407          //      EA = 1;
 408          //      ET1 = 1;
 409          //      TR1 = 1;
 410          //}
 411          //============================================串口初始化============================================
 412          #include "intrins.h"
 413          #include "string.h"
 414          
 415          sfr AUXR = 0x8e;  // 辅助寄存器
 416          #define BAUD         9600
 417          //#define SYSTEMCLOCK  11059200L
 418          #define SYSTEMCLOCK  12000000L
 419          uchar command = 0x00;
 420          void Init_Uart()
 421          {
 422   1              TMOD = (TMOD & 0x0f) | 0x00;
 423   1              TL1 = (65535-(SYSTEMCLOCK / 4 / BAUD));
 424   1              TH1 = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 425   1      //      ET1 = 0;                    //禁止定时器1中断
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 8   

 426   1              TR1 = 1;                    //启动定时器1
 427   1              
 428   1              SCON = 0x50;
 429   1              AUXR = 0x40;
 430   1              
 431   1              ES = 1;
 432   1              EA = 1;
 433   1              
 434   1      //      SCON = 0x50;            //8位数据,可变波特率
 435   1      //      AUXR &= 0xBF;           //定时器1时钟为Fosc/12,即12T
 436   1      //      AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 437   1      //      TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 438   1      //      TL1 = 0xE8;             //设定定时初值
 439   1      //      TH1 = 0xFF;             //设定定时初值
 440   1      //      ET1 = 0;                //禁止定时器1中断
 441   1      
 442   1      //      ES = 1;
 443   1      //      EA = 1;  
 444   1      //      TR1 = 1;                //启动定时器1
 445   1      }
 446          // 发送一个字节数据
 447          void Send_Byte(unsigned char dat)
 448          {
 449   1              SBUF = dat;
 450   1              while(TI == 0);
 451   1              TI = 0;
 452   1      }
 453          //发送一串字符串
 454          void Send_String(unsigned char* str)
 455          {
 456   1        
 457   1        while(*str != '\0')
 458   1        {
 459   2          Send_Byte(*(str++));
 460   2        }
 461   1      }
 462          //==========================================系统初始化=============================================
 463          void Init_Sys()
 464          {
 465   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 466   1              P0 = 0xff;
 467   1              P2 &= 0x1f;
 468   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 469   1              P0 = 0x00;
 470   1              P2 &= 0x1f;
 471   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 472   1              P0 = 0xff;
 473   1              P2 &= 0x1f;
 474   1              P2 = (P2 & 0x1f) | 0xe0;
 475   1              P0 = 0xff;
 476   1              
 477   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 478   1      }
 479          
 480          void LED_control() {
 481   1              // ================= 测试开始 =============
 482   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 483   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 484   1      //      P2 &= 0x1f;
 485   1              // ================= 测试结束 =============
 486   1              
 487   1              // =========================================== 代码开始 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 9   

 488   1              
 489   1              // =========================================== 代码结束 ======================================
 490   1      }
 491          
 492          void main()
 493          {
 494   1              Init_Sys();
 495   1      //      Init_T1();
 496   1              Init_T0();
 497   1              Init_18b20();
 498   1              Init_Uart();
 499   1      //      Send_Byte(0x5a);
 500   1      //      Send_Byte(0xa5);
 501   1              Send_String("I am OK\r\n");
 502   1              
 503   1              while(1)
 504   1              {
 505   2      //              LED_control();
 506   2              if(f_2ms == 1)
 507   2              {
 508   3                  f_2ms = 0;                  
 509   3                              LED_control();  // xxx  
 510   3                              // =======================按键开始========================
 511   3                              /*根据需要选择对应的按键类型*/
 512   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 513   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 514   3                              Change_Keys();        // 3.矩阵按键扫描
 515   3                              if (GN == 16) {  // S16
 516   4                                      // =========================================== 代码开始 ======================================
 517   4                                      LED1_On();
 518   4                                      // =========================================== 代码结束 ======================================
 519   4                                      while(Scan_Keys());
 520   4                                      // =========================================== 代码开始 ======================================
 521   4                                      LED1_Off();
 522   4                                      // =========================================== 代码结束 ======================================
 523   4                              }
 524   3                              /*根据需要添加对应按键*/
 525   3                              // =======================按键结束========================
 526   3                              
 527   3                              // =======================串口调试开始====================
 528   3                              if(command != 0x00)
 529   3                              {
 530   4                                      switch(command & 0xf0)
 531   4                                      {
 532   5                                              case 0xa0:
 533   5                                                      P0 = temp_Led_P0;
 534   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 535   5                                                      P0 = (P0 | 0x0f) & ((~command) | 0xf0);
 536   5                                                      temp_Led_P0 = P0;
 537   5                                                      P2 &= 0x1f;
 538   5                                                      command = 0x00;
 539   5                                              break;
 540   5                                              case 0xb0:
 541   5                                                      P0 = temp_Led_P0;
 542   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 543   5                                                      P0 = (P0 | 0xf0) & (((~command) << 4) | 0x0f);
 544   5                                                      temp_Led_P0 = P0;
 545   5                                                      P2 &= 0x1f;
 546   5                                                      command = 0x00;
 547   5                                              break;
 548   5                                              case 0xc0:
 549   5                                                      Send_String("system is running...!\r\n");
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 10  

 550   5                                                      command = 0x00;
 551   5                                              break;
 552   5                                      }
 553   4                              }
 554   3                              // =======================串口调试结束====================              
 555   3                              
 556   3                              // =========================================== 代码开始 ======================================
 557   3                              // =======================温度读取开始========================
 558   3                              if (f_200ms_temperature) {
 559   4                                      f_200ms_temperature = 0;
 560   4                                      temperature = Read_Temperature();
 561   4                              }
 562   3                              num1=10;num2=10;num3=10;num4=10;
 563   3                              num5=temperature/1000;num6=temperature/100%10;
 564   3                              num7=temperature/10%10;num8=temperature%10;
 565   3                              // =======================温度读取结束========================
 566   3                              
 567   3                              // =========================================== 代码结束 ======================================
 568   3              }
 569   2          }
 570   1      }
 571          
 572          void Service_T0() interrupt 1
 573          {
 574   1              TH0 = (65536 - 2000) / 256;
 575   1              TL0 = (65536 - 2000) % 256;
 576   1              
 577   1              f_2ms = 1;
 578   1              
 579   1              /***************************************************
 580   1              与时间相关的变量的更新放在里面
 581   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 582   1              ***************************************************/
 583   1              // =========================================== 代码开始 ======================================
 584   1              num_2ms ++ ;
 585   1              num_2ms_temperature ++ ;
 586   1              if (num_2ms_temperature == 100) {
 587   2                      f_200ms_temperature = 1;
 588   2                      num_2ms_temperature = 0;
 589   2              }
 590   1      //      
 591   1      //      if (num_2ms == 500) {
 592   1      //              f_1s = 1;
 593   1      //              num_2ms = 0;
 594   1      //      }
 595   1      //      if (f_1s == 1) {
 596   1      //              f_1s = 0;
 597   1      //              num_s ++ ;
 598   1      //              if (num_s == 9) 
 599   1      //              num_s = 0;
 600   1      //      }
 601   1      //      num1 = 2;num2 = 0; num3 = 2; num4 = 4;
 602   1      //      num5=num6=11;
 603   1      //      num7=num_s / 10, num8=num_s % 10;
 604   1              
 605   1      
 606   1              // =========================================== 代码结束 ======================================
 607   1              
 608   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 609   1      }
 610          
 611          void ServiceUart() interrupt 4
C51 COMPILER V9.60.7.0   MAIN                                                              04/06/2024 23:05:10 PAGE 11  

 612          {
 613   1              if(RI == 1)
 614   1              {
 615   2                      RI = 0;//人工清零
 616   2                      urdat = SBUF;
 617   2                      command = SBUF;
 618   2      //              Send_Byte(urdat + 1);
 619   2      //              send_byte(0x5a);
 620   2      //              send_byte(0xa5);
 621   2              }
 622   1      }
*** WARNING C294 IN LINE 177 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1521    ----
   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
