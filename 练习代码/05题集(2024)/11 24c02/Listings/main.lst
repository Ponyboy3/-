C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "onewire.h"
   3          #include "iic.h"
   4          #include "ds1302.h"
   5          #include "intrins.h"
   6          
   7          #define uchar unsigned char 
   8          #define uint unsigned int
   9          
  10          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
  11          unsigned char code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
  12          // 数码管位
  13          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  14          
  15          unsigned char num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2
             -）
  16          unsigned char GN;  // 按键标志位
  17          bit f_2ms, f_50ms, f_200ms_temperature;  // 2ms, 50ms, 500ms标志位
  18          unsigned char temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  19          unsigned int temperature;  // 温度
  20          unsigned int num_2ms_temperature;  // 多少个2ms
  21          unsigned char ds1302_h, ds1302_m, ds1302_s;  // 
  22          unsigned char dat1 = 0x16,dat2 = 0x55,dat3 = 0x50;  // （16进制）ds1302写数据
  23          unsigned char dat[8];
  24          int set_ds1302_h = 23,set_ds1302_m = 59,set_ds1302_s = 45;  // 默认（24c02写数据）时间设置
  25          uchar set_ds1302_key_modele;  // 时间设置的按键模式
  26          bit f_set_time, f_key_long, is_key_set_time;
  27          uchar t_key;  // 按键按住时间
  28          
  29          unsigned char dis_model = 0;  // 0:显示温度（DS18B20）， 1:显示时钟
  30          
  31          uint distance;
  32          
  33          sbit S7 = P3^0;
  34          sbit S6 = P3^1;
  35          sbit S5 = P3^2;
  36          sbit S4 = P3^3;
  37          
  38          sbit L0 = P0^0;
  39          sbit L1 = P0^1;
  40          sbit L2 = P0^2;
  41          sbit L3 = P0^3;
  42          sbit L4 = P0^4;
  43          sbit L5 = P0^5;
  44          sbit L6 = P0^6;
  45          
  46          // =========================================== 代码开始 ======================================
  47          bit f_1s;  // 1s标志位
  48          
  49          unsigned int num_2ms = 0, num_s = 0, num_s_key = 0;  // 多少个2ms, 1s, 按键按下时间
  50          
  51          bit f_time = 1;  // 定时器0秒钟是否暂停
  52          unsigned char urdat;  // 串口接收数据
  53          
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 2   

  54          unsigned int num_On_Off;  // 开关次数
  55          
  56          // =========================================== 代码结束 ======================================
  57          
  58          
  59          //=========================================普通延时函数(模板函数)=================================
  60          void Delay(uint t) {
  61   1              while( t -- );
  62   1              while( t -- );
  63   1      }
  64          //=======================================单个LED控制函数(模板函数)================================
  65          // 根据项目需要删减
  66          
  67          // ======================LED0====================
  68          void LED0_On() {
  69   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  70   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  71   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  72   1              temp_Led_P0 = P0;
  73   1              P2 &= 0x1f;
  74   1      }
  75          void LED0_Off() {
  76   1              P0 = 0xff & temp_Led_P0;
  77   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  78   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  79   1              temp_Led_P0 = P0;
  80   1              P2 &= 0x1f;
  81   1      }
  82          // ======================LED1====================
  83          void LED1_On() {
  84   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  85   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  86   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  87   1              temp_Led_P0 = P0;
  88   1              P2 &= 0x1f;
  89   1      }
  90          void LED1_Off() {
  91   1              P0 = 0xff & temp_Led_P0;
  92   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  93   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  94   1              temp_Led_P0 = P0;
  95   1              P2 &= 0x1f;
  96   1      }
  97          // ======================LED2====================
  98          void LED2_On() {
  99   1              P0 = 0xff & temp_Led_P0;
 100   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 101   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
 102   1              temp_Led_P0 = P0;
 103   1              P2 &= 0x1f;
 104   1      }
 105          void LED2_Off() {
 106   1              P0 = 0xff & temp_Led_P0;
 107   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 108   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
 109   1              temp_Led_P0 = P0;
 110   1              P2 &= 0x1f;
 111   1      }
 112          // ======================LED3====================
 113          void LED3_On() {
 114   1              P0 = 0xff & temp_Led_P0;
 115   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 3   

 116   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 117   1              temp_Led_P0 = P0;
 118   1              P2 &= 0x1f;
 119   1      }
 120          void LED3_Off() {
 121   1              P0 = 0xff & temp_Led_P0;
 122   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 123   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 124   1              temp_Led_P0 = P0;
 125   1              P2 &= 0x1f;
 126   1      }
 127          // ======================LED4====================
 128          void LED4_On() {
 129   1              P0 = 0xff & temp_Led_P0;
 130   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 131   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 132   1              temp_Led_P0 = P0;
 133   1              P2 &= 0x1f;
 134   1      }
 135          void LED4_Off() {
 136   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 137   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 138   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 139   1              temp_Led_P0 = P0;
 140   1              P2 &= 0x1f;
 141   1      }
 142          // ======================LED5====================
 143          void LED5_On() {
 144   1              P0 = 0xff & temp_Led_P0;
 145   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 146   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 147   1              temp_Led_P0 = P0;
 148   1              P2 &= 0x1f;
 149   1      }
 150          void LED5_Off() {
 151   1              P0 = 0xff & temp_Led_P0;
 152   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 153   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 154   1              temp_Led_P0 = P0;
 155   1              P2 &= 0x1f;
 156   1      }
 157          // ======================LED6====================
 158          void LED6_On() {
 159   1              P0 = 0xff & temp_Led_P0;
 160   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 161   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 162   1              temp_Led_P0 = P0;
 163   1              P2 &= 0x1f;
 164   1      }
 165          void LED6_Off() {
 166   1              P0 = 0xff & temp_Led_P0;
 167   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 168   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 169   1              temp_Led_P0 = P0;
 170   1              P2 &= 0x1f;
 171   1      }
 172          //=========================================数码管显示==============================================
 173          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 174          {
 175   1              char i;
 176   1              P0 = 0xff;
 177   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 4   

 178   1              P0 = type2[i];
 179   1              P2 &= 0x1f;
 180   1              switch(i)//数码管位选
 181   1              {
 182   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 183   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 184   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 185   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 186   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 187   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 188   2                                                                              if(dis_model == 1)  // 根据需要的条件
 189   2                                                                              {
 190   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 191   3                                                                              }
 192   2                                                                              else
 193   2                                                                                      P0 = type1[n6];
 194   2                                                                                                        P2 &= 0x1f;break;
 195   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 196   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 197   2              }
 198   1              if(++i==8)
 199   1                      i = 0;
 200   1      }
 201          //============================================独立按键============================================
 202          /***************************************************
 203          写法一：
 204          有按键被按下，GN标记，后面根据需要功能进行操作
 205          ***************************************************/
 206          void Delay_Keys(uint t)
 207          {
 208   1              while(t--);
 209   1      }
 210          uchar Scan_Keys_Alone()
 211          {
 212   1              char d;
 213   1              d = (~P3) & 0x0f;
 214   1              if(d == 0) return 0;
 215   1              Delay_Keys(100);
 216   1              if(d == 0) return 0;
 217   1              Delay_Keys(100);
 218   1              return d;
 219   1      }
 220          void Change_Keys_Alone()
 221          {
 222   1              switch(Scan_Keys_Alone())
 223   1              {
 224   2                      case 8:GN = 1;break;//S4
 225   2                      case 4:GN = 2;break;//S5
 226   2                      case 2:GN = 3;break;//S6
 227   2                      case 1:GN = 4;break;//S7
 228   2                      case 0:GN = 0;break;
 229   2              }
 230   1      }
 231          
 232          /***************************************************
 233          写法二：
 234          有按键被按下，按下是一种状态，松开是另一种状态
 235          （如：按下时某个灯亮，松开时灯灭）
 236          ***************************************************/
 237          //void ScanKeys_Alone() 
 238          //{
 239          //      if (S7 == 0) {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 5   

 240          //              Delay_Keys(100);
 241          //              if (S7 == 0) {
 242          //                      // =========================================== 代码开始 ======================================
 243          //                      
 244          //                      // =========================================== 代码结束 ======================================
 245          //                      while(S7 == 0);
 246          //                      // =========================================== 代码开始 ======================================
 247          
 248          //                      // =========================================== 代码结束 ======================================
 249          //              }
 250          //      }
 251          //      
 252          //      if (S6 == 0) {
 253          //              Delay_Keys(100);
 254          //              if (S6 == 0) {
 255          //                      // =========================================== 代码开始 ======================================
 256          //                      
 257          //                      // =========================================== 代码结束 ======================================
 258          //                      while(S6 == 0);
 259          //                      // =========================================== 代码开始 ======================================
 260          
 261          //                      // =========================================== 代码结束 ======================================
 262          //              }
 263          //      }
 264          //      
 265          //      if (S5 == 0) {
 266          //              Delay_Keys(100);
 267          //              if (S5 == 0) {
 268          //                      // =========================================== 代码开始 ======================================
 269          
 270          //                      // =========================================== 代码结束 ======================================
 271          //                      while(S5 == 0);
 272          //                      // =========================================== 代码开始 ======================================
 273          
 274          //                      // =========================================== 代码结束 ======================================
 275          //              }
 276          //      }
 277          
 278          //      if (S4 == 0) {
 279          //              Delay_Keys(100);
 280          //              if (S4 == 0) {
 281          //                      // =========================================== 代码开始 ======================================
 282          
 283          //                      // =========================================== 代码结束 ======================================
 284          //                      while(S4 == 0);
 285          //                      // =========================================== 代码开始 ======================================
 286          
 287          //                      // =========================================== 代码结束 ======================================
 288          //              }
 289          //      }
 290          //}
 291          
 292          // ================= 代码结束 =============
 293          
 294          //============================================矩阵按键============================================
 295          sfr P4 = 0xc0;
 296          sbit P44 = P4^4;
 297          sbit P42 = P4^2;
 298          
 299          uchar Scan_Keys()
 300          {
 301   1              char H,L;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 6   

 302   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 303   1              if(H == 0) return 0;
 304   1              Delay_Keys(100);
 305   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 306   1              if(H == 0) return 0;
 307   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 308   1              if(P44 == 0) L |= 0x80;
 309   1              if(P42 == 0) L |= 0x40;
 310   1              return (H+L);
 311   1      }
 312          
 313          void Change_Keys()
 314          {
 315   1              switch(Scan_Keys())
 316   1              {
 317   2                      case 0x88:GN = 4;break;  // S4
 318   2                      case 0x84:GN = 5;break;  // S5
 319   2                      case 0x82:GN = 6;break;  // S6
 320   2                      case 0x81:GN = 7;break;  // S7
 321   2                      case 0x48:GN = 8;break;  // S8
 322   2                      case 0x44:GN = 9;break;  // S9
 323   2                      case 0x42:GN = 10;break;  // S10
 324   2                      case 0x41:GN = 11;break;  // S11
 325   2                      case 0x28:GN = 12;break;  // S12
 326   2                      case 0x24:GN = 13;break;  // S13
 327   2                      case 0x22:GN = 14;break;  // S14
 328   2                      case 0x21:GN = 15;break;  // S15
 329   2                      case 0x18:GN = 16;break;  // S16
 330   2                      case 0x14:GN = 17;break;  // S17
 331   2                      case 0x12:GN = 18;break;  // S18
 332   2                      case 0x11:GN = 19;break;  // S19
 333   2                      case 0:GN = 0;break;
 334   2              }
 335   1      }
 336          //============================================24C02初始化============================================
 337          void Write_24C02_Byte(unsigned char addr,unsigned char dat)
 338          {
 339   1              IIC_Start();
 340   1              IIC_SendByte(0xa0);
 341   1              IIC_WaitAck();
 342   1              IIC_SendByte(addr);
 343   1              IIC_WaitAck();
 344   1              IIC_SendByte(dat);
 345   1              IIC_WaitAck();
 346   1              IIC_Stop(); 
 347   1      }
 348          
 349          unsigned char Read_24C02_Byte(unsigned char addr)
 350          {
 351   1              unsigned char tmp;
 352   1              IIC_Start();
 353   1              IIC_SendByte(0xa0);
 354   1              IIC_WaitAck();
 355   1              IIC_SendByte(addr);
 356   1              IIC_WaitAck();
 357   1              
 358   1              IIC_Start();
 359   1              IIC_SendByte(0xa1);
 360   1              IIC_WaitAck();
 361   1              tmp = IIC_RecByte(); 
 362   1              IIC_SendAck(1);
 363   1              IIC_Stop();
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 7   

 364   1              
 365   1              return tmp;
 366   1      }
 367          
 368          void Write_24C02_Page(unsigned char addr, unsigned char *dat, unsigned char len)
 369          {
 370   1              unsigned char i;
 371   1              IIC_Start();
 372   1              IIC_SendByte(0xa0);
 373   1              IIC_WaitAck();
 374   1              IIC_SendByte(addr);
 375   1              IIC_WaitAck();
 376   1              
 377   1              for (i = 0; i < len; i ++ ) {
 378   2                      IIC_SendByte(dat[i]);
 379   2                      IIC_WaitAck();
 380   2              }
 381   1              IIC_Stop(); 
 382   1      }
 383          
 384          void Read_24C02_Page(unsigned char addr, unsigned char *dat, unsigned char len)
 385          {
 386   1              unsigned char i;
 387   1              IIC_Start();
 388   1              IIC_SendByte(0xa0);
 389   1              IIC_WaitAck();
 390   1              IIC_SendByte(addr);
 391   1              IIC_WaitAck();
 392   1              
 393   1              IIC_Start();
 394   1              IIC_SendByte(0xa1);
 395   1              IIC_WaitAck();
 396   1              for (i = 0; i < len - 1; i ++ ) {
 397   2                      dat[i] = IIC_RecByte();
 398   2                      IIC_SendAck(0);
 399   2              }
 400   1              dat[len - 1] = IIC_RecByte();
 401   1              IIC_SendAck(1);
 402   1              IIC_Stop();
 403   1      }
 404          //============================================DS18B20初始化============================================
 405          void Init_18b20()
 406          {
 407   1              init_ds18b20();
 408   1              Write_DS18B20(0xcc);
 409   1              Write_DS18B20(0x4e);
 410   1              Write_DS18B20(0x00);
 411   1              Write_DS18B20(0x00);
 412   1              Write_DS18B20(0x7f);
 413   1      }
 414          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 415                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 416                                                                           // 和一位小数可用unsigned char.
 417          {
 418   1              unsigned char H,L;
 419   1              init_ds18b20();
 420   1              Write_DS18B20(0xcc);
 421   1              Write_DS18B20(0xbe);
 422   1              L = Read_DS18B20();
 423   1              H = Read_DS18B20();
 424   1              
 425   1              init_ds18b20();
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 8   

 426   1              Write_DS18B20(0xcc);
 427   1              Write_DS18B20(0x44);
 428   1              
 429   1              //1.保留整数--23
 430   1              //temp = (H<<4) + (L>>4);
 431   1              
 432   1              //2.保留1位小数--23.4
 433   1              //temp = ((H<<8) + L)*5/8;
 434   1              
 435   1              //3.保留2位小数--23.45
 436   1              return ((H<<8)+L)*25/4;  // (50/8)
 437   1      }
 438          //============================================Ds1302初始化============================================
 439          void My_Write_Ds1302()
 440          {
 441   1              Write_Ds1302_Byte(0x8e,0x00);
 442   1              Write_Ds1302_Byte(0x84,dat1);//时
 443   1              Write_Ds1302_Byte(0x82,dat2);//分
 444   1              Write_Ds1302_Byte(0x80,dat3);//秒
 445   1      }
 446          void My_Read_Ds1302()
 447          {
 448   1              ds1302_h = Read_Ds1302_Byte(0x85);//时
 449   1              ds1302_h = (ds1302_h >> 4) * 10 + (ds1302_h & 0x0f);
 450   1              ds1302_m = Read_Ds1302_Byte(0x83);//分
 451   1              ds1302_m = (ds1302_m >> 4) * 10 + (ds1302_m & 0x0f);
 452   1              ds1302_s = Read_Ds1302_Byte(0x81);//秒
 453   1              ds1302_s = (ds1302_s >> 4) * 10 + (ds1302_s & 0x0f);
 454   1      }
 455          //============================================定时器T0初始化=======================================
 456          uchar count = 0;
 457          uchar pwm_dut = 0;//占空比
 458          void Init_T0()
 459          {
 460   1              TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 461   1              TH0 = (65536 - 2000) / 256;
 462   1              TL0 = (65536 - 2000) % 256;
 463   1              
 464   1              EA = 1;
 465   1              ET0 = 1;
 466   1              TR0 = 1;
 467   1      }
 468          //============================================定时器T1初始化=======================================
 469          void Init_T1()
 470          {
 471   1              TMOD = (TMOD & 0x0f) | 0x10;//定时
 472   1              TH1 = (65536 - 12) / 256;
 473   1              TL1 = (65536 - 12) % 256;
 474   1              
 475   1      //      EA = 1;
 476   1      //      ET1 = 1;
 477   1      //      TR1 = 1;
 478   1      }
 479          //============================================超声波测距=======================================
 480          sbit TX = P1 ^ 0;
 481          sbit RX = P1 ^ 1;
 482          
 483          //======发射超声波信号====
 484          void send_Wave()
 485          {
 486   1              unsigned char i = 8;
 487   1              // 12MHZ的12分频，间隔定时12us;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 9   

 488   1              TR1 = 0;
 489   1              TH1 = 0xff;
 490   1              TL1 = 0xf4;
 491   1              TF1 = 0;
 492   1              TR1 = 1;
 493   1              // 发射8个40khz的超声波信号
 494   1              while (i -- ) {
 495   2                      TX = 0;
 496   2                      while (!TF1);
 497   2                      TF1 = 0;
 498   2                      TX = 1;
 499   2                      while (!TF1);
 500   2                      TF1 = 0;
 501   2              }
 502   1              
 503   1      //      uchar temp = 16;
 504   1      //      TX = 0;
 505   1      //      TR1 = 1;
 506   1      //      // 引脚发送40Khz方波信号
 507   1      //      while (temp--) // 每隔12us发8个方波
 508   1      //      {
 509   1      //              while (!TF1)
 510   1      //                      ;
 511   1      //              TX ^= 1; // if(TX==1) { Delay20us();}//可以不用
 512   1      //              TH1 = (65536 - 12) / 256;
 513   1      //              TL1 = (65536 - 12) % 256;
 514   1      //              TF1 = 0;
 515   1      //      }
 516   1      }
 517          
 518          void Get_Distance() {
 519   1              // 先发射8个40khz的超声波信号
 520   1              send_Wave();
 521   1              
 522   1              TR1 = 0;
 523   1              TL1 = 0x00;
 524   1              TH1 = 0xe0;
 525   1              TF1 = 0;
 526   1              TR1 = 1;
 527   1              while (RX && !TF1);
 528   1              TR1 = 0;
 529   1              
 530   1              if (TF1 == 1)
 531   1              {
 532   2                      TF1 = 0;
 533   2                      distance = 999;
 534   2              }
 535   1              // 超声波速度约344m/s
 536   1              // 距离 L = （344m/s*t）/2=172m/s*t
 537   1              // t取微秒，即：L = 0.0172cm/us*t
 538   1              else
 539   1                      distance = (((TH1 & 0x1f) << 8) | TL1) * 0.0172;
 540   1      }
 541          
 542          uchar Get_Distance_2()
 543          {
 544   1              uchar temp = 16;
 545   1              TX = 0;
 546   1              TR1 = 1;
 547   1              // 引脚发送40Khz方波信号
 548   1              while (temp--) // 每隔12us发8个方波
 549   1              {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 10  

 550   2                      while (!TF1)
 551   2                              ;
 552   2                      TX ^= 1; // if(TX==1) { Delay20us();}//可以不用
 553   2                      TH1 = (65536 - 12) / 256;
 554   2                      TL1 = (65536 - 12) % 256;
 555   2                      TF1 = 0;
 556   2              }
 557   1              //      while(temp--)
 558   1              //      {
 559   1              //              while(!TF0);
 560   1              //              TX ^= 1;//TX = ~TX;
 561   1              //              TH0=(65536-12)/256;
 562   1              //              TL0=(65536-12)%256;
 563   1              //              TF0 = 0;//TF0必须要先赋值(益处中断，自动置1)在清零
 564   1              //      }
 565   1              TR1 = 0;
 566   1              TL1 = 0;
 567   1              TH1 = 0;
 568   1              TR1 = 1;
 569   1              while (RX && !TF1)
 570   1                      ;
 571   1              TR1 = 0;
 572   1      
 573   1              if (TF1 == 1)
 574   1              {
 575   2                      TF1 = 0;
 576   2                      return 999;
 577   2              }
 578   1              else
 579   1                      return ((TH1 << 8) + TL1) * 0.017;
 580   1      }
 581          //============================================串口初始化============================================
 582          #include "intrins.h"
 583          #include "string.h"
 584          
 585          sfr AUXR = 0x8e;  // 辅助寄存器
 586          sfr T2H=0xd6;  // 定时器2高8位
 587          sfr T2L=0xd7;  // 定时器2低8位
 588          #define BAUD         9600
 589          //#define SYSTEMCLOCK  11059200L
 590          #define SYSTEMCLOCK  12000000L
 591          uchar command = 0x00;
 592          void Init_Uart()
 593          {
 594   1              // ===================T1实现===================
 595   1      //      TMOD = (TMOD & 0x0f) | 0x00;
 596   1      //      
 597   1      //      TL1 = (65535-(SYSTEMCLOCK / 4 / BAUD));
 598   1      //      TH1 = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 599   1      //      
 600   1      ////    ET1 = 0;                    //禁止定时器1中断
 601   1      //      TR1 = 1;                    //启动定时器1
 602   1      //      
 603   1      //      SCON = 0x50;
 604   1      //      AUXR = 0x40;
 605   1              // ===================T1实现===================
 606   1              
 607   1              // ===================T2实现===================
 608   1              SCON = 0x50;  // 8位数据,可变波特率
 609   1          AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
 610   1          AUXR |= 0x04; // 定时器时钟1T模式
 611   1              
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 11  

 612   1              T2L = (65535-(SYSTEMCLOCK / 4 / BAUD));
 613   1              T2H = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 614   1              
 615   1      //      ET1 = 0;                    //禁止定时器1中断
 616   1      //      TR1 = 1;                    //启动定时器1
 617   1      //      SCON = 0x50;
 618   1      //      AUXR = 0x40;
 619   1              
 620   1              AUXR |= 0x10; // 定时器2开始计时
 621   1              // ===================T2实现===================
 622   1              
 623   1              ES = 1;
 624   1              EA = 1;
 625   1              
 626   1      //      SCON = 0x50;            //8位数据,可变波特率
 627   1      //      AUXR &= 0xBF;           //定时器1时钟为Fosc/12,即12T
 628   1      //      AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 629   1      //      TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 630   1      //      TL1 = 0xE8;             //设定定时初值
 631   1      //      TH1 = 0xFF;             //设定定时初值
 632   1      //      ET1 = 0;                //禁止定时器1中断
 633   1      
 634   1      //      ES = 1;
 635   1      //      EA = 1;  
 636   1      //      TR1 = 1;                //启动定时器1
 637   1      }
 638          // 发送一个字节数据
 639          void Send_Byte(unsigned char dat)
 640          {
 641   1              SBUF = dat;
 642   1              while(TI == 0);
 643   1              TI = 0;
 644   1      }
 645          //发送一串字符串
 646          void Send_String(unsigned char* str)
 647          {
 648   1        
 649   1        while(*str != '\0')
 650   1        {
 651   2          Send_Byte(*(str++));
 652   2        }
 653   1      }
 654          //==========================================系统初始化=============================================
 655          void Init_Sys()
 656          {
 657   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 658   1              P0 = 0xff;
 659   1              P2 &= 0x1f;
 660   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 661   1              P0 = 0x00;
 662   1              P2 &= 0x1f;
 663   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 664   1              P0 = 0xff;
 665   1              P2 &= 0x1f;
 666   1              P2 = (P2 & 0x1f) | 0xe0;
 667   1              P0 = 0xff;
 668   1              
 669   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 670   1      }
 671          
 672          void LED_control() {
 673   1              // ================= 测试开始 =============
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 12  

 674   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 675   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 676   1      //      P2 &= 0x1f;
 677   1              // ================= 测试结束 =============
 678   1              
 679   1              // =========================================== 代码开始 ======================================
 680   1              
 681   1              // =========================================== 代码结束 ======================================
 682   1      }
 683          
 684          void main()
 685          {
 686   1              Init_Sys();
 687   1              
 688   1              num_On_Off = Read_24C02_Byte(0x00);
 689   1              
 690   1              Init_T1();
 691   1      //      TMOD = (TMOD & 0x0f) | 0x00;//定时
 692   1              Init_T0();
 693   1              Init_18b20();
 694   1      //      My_Write_Ds1302();
 695   1      
 696   1      //      num_On_Off = Read_24C02_Byte(0x00);
 697   1      //      num_On_Off ++ ;
 698   1      //      Write_24C02_Byte(0x00, num_On_Off);
 699   1      
 700   1              Read_24C02_Page(0x01, dat, 3);
 701   1              
 702   1              
 703   1      //      dat2 = (dat[2] / 10) << 4 | (dat[2] % 10);
 704   1              dat1 = dat[0] /10*16 + dat[0] % 10;
 705   1              dat2 = dat[1] /10*16 + dat[1] % 10;
 706   1              dat3 = dat[2] /10*16 + dat[2] % 10;
 707   1              
 708   1              My_Write_Ds1302();
 709   1              
 710   1              Init_Uart();
 711   1      //      Send_Byte(dat[2] /10*16 + dat[2] % 10);
 712   1      //      Send_Byte(0xA0);
 713   1              Send_String("I am OK\r\n");
 714   1              
 715   1              while(1)
 716   1              {
 717   2      //              LED_control();
 718   2              if(f_2ms == 1)
 719   2              {
 720   3                  f_2ms = 0;                  
 721   3                              LED_control();  // xxx
 722   3      //                      Write_24C02_Byte(0x02,ds1302_s);        
 723   3      
 724   3                              distance = Get_Distance_2();  // 超声波测距             
 725   3                              // =======================按键开始========================
 726   3                              /*根据需要选择对应的按键类型*/
 727   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 728   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 729   3                              Change_Keys();        // 3.矩阵按键扫描
 730   3                              if (GN == 16) {  // S16
 731   4                                      // =========================================== 代码开始 ======================================
 732   4                                      LED1_On();
 733   4                                      // =========================================== 代码结束 ======================================
 734   4                                      while(Scan_Keys());
 735   4                                      // =========================================== 代码开始 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 13  

 736   4                                      LED1_Off();
 737   4                                      dis_model ++ ;
 738   4                                      if (dis_model > 4) dis_model = 0;
 739   4                                      // =========================================== 代码结束 ======================================
 740   4                              }
 741   3                              
 742   3                              if (GN == 12) {  // S12
 743   4                                      // =========================================== 代码开始 ======================================
 744   4                                      LED2_On();
 745   4                                      // =========================================== 代码结束 ======================================
 746   4                                      while(Scan_Keys());
 747   4                                      // =========================================== 代码开始 ======================================
 748   4                                      LED2_Off();
 749   4                                      f_time = ~f_time;
 750   4                                      // =========================================== 代码结束 ======================================
 751   4                              }
 752   3                              
 753   3                              if (GN == 8) {  // S8
 754   4                                      // =========================================== 代码开始 ======================================
 755   4                                      LED5_On();
 756   4                                      // =========================================== 代码结束 ======================================
 757   4                                      while(Scan_Keys());
 758   4                                      // =========================================== 代码开始 ======================================
 759   4                                      LED5_Off();
 760   4                                      
 761   4                                      // 时间加
 762   4                                      if (set_ds1302_key_modele == 1) {  // 小时设置
 763   5                                              set_ds1302_h ++ ;
 764   5                                              if (set_ds1302_h > 23) set_ds1302_h = 0;
 765   5                                      }
 766   4                                      else if (set_ds1302_key_modele == 2) {  // 分钟设置
 767   5                                              set_ds1302_m ++ ;
 768   5                                              if (set_ds1302_m > 59) set_ds1302_m = 0;
 769   5                                      }
 770   4                                      else if (set_ds1302_key_modele == 3) {  // 秒设置
 771   5                                              set_ds1302_s ++ ;
 772   5                                              if (set_ds1302_s > 59) set_ds1302_s = 0;
 773   5                                      }
 774   4                                      
 775   4                                      // =========================================== 代码结束 ======================================
 776   4                              }
 777   3                              
 778   3                              if (GN == 9) {  // S9
 779   4                                      // =========================================== 代码开始 ======================================
 780   4                                      LED5_On();
 781   4                                      // =========================================== 代码结束 ======================================
 782   4                                      while(Scan_Keys());
 783   4                                      // =========================================== 代码开始 ======================================
 784   4                                      LED5_Off();
 785   4                                      
 786   4                                      // 时间减
 787   4                                      if (set_ds1302_key_modele == 1) {  // 小时设置
 788   5                                              set_ds1302_h -- ;
 789   5                                              if (set_ds1302_h < 0) set_ds1302_h = 23;
 790   5                                      }
 791   4                                      else if (set_ds1302_key_modele == 2) {  // 分钟设置
 792   5                                              set_ds1302_m -- ;
 793   5                                              if (set_ds1302_m < 0) set_ds1302_m = 59;
 794   5                                      }
 795   4                                      else if (set_ds1302_key_modele == 3) {  // 秒设置
 796   5                                              set_ds1302_s -- ;
 797   5                                              if (set_ds1302_s < 0) set_ds1302_s = 59;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 14  

 798   5                                      }
 799   4                                      // =========================================== 代码结束 ======================================
 800   4                              }
 801   3      
 802   3                              if (GN == 4) {  // S4
 803   4                                      // =========================================== 代码开始 ======================================
 804   4                                      LED3_On();
 805   4                                      is_key_set_time = 1;  // 按键按下未松开
 806   4                                      
 807   4                                      
 808   4                                      // =========================================== 代码结束 ======================================
 809   4                                      while(Scan_Keys());
 810   4                                      // =========================================== 代码开始 ======================================
 811   4                                      LED3_Off();
 812   4                                      LED4_Off();
 813   4                                      is_key_set_time = 0;  // 按键按下松开
 814   4                                      num_s_key = 0;
 815   4                                      
 816   4                                      if (f_key_long) {  // 长按转换模式
 817   5                                              set_ds1302_key_modele ++ ;
 818   5                                              f_key_long = 0;
 819   5                                      }
 820   4                                      
 821   4                                      
 822   4      //                              if (set_ds1302_key_modele == 1) {  // 小时设置
 823   4      //                                      set_ds1302_h = 23;
 824   4      //                              }
 825   4      //                              else if (set_ds1302_key_modele == 2) {  // 分钟设置
 826   4      //                                      set_ds1302_m = 29;
 827   4      //                              }
 828   4      //                              else if (set_ds1302_key_modele == 3) {  // 秒设置
 829   4      //                                      set_ds1302_s = 45;
 830   4      //                              }
 831   4                                      if (set_ds1302_key_modele == 4) {  // 确认
 832   5                                              if (dis_model == 2) {
 833   6                                                      dat[0] = set_ds1302_h;
 834   6                                                      dat[1] = set_ds1302_m;
 835   6                                                      dat[2] = set_ds1302_s;
 836   6                                                      Write_24C02_Page(0x01, dat, 3);
 837   6                                                      
 838   6                                                      dat1 = dat[0] /10*16 + dat[0] % 10;
 839   6                                                      dat2 = dat[1] /10*16 + dat[1] % 10;
 840   6                                                      dat3 = dat[2] /10*16 + dat[2] % 10;
 841   6      
 842   6                                                      My_Write_Ds1302();
 843   6                                              }
 844   5                                              set_ds1302_key_modele = 0;
 845   5                                      }
 846   4                                      // =========================================== 代码结束 ======================================
 847   4                              }
 848   3                              /*根据需要添加对应按键*/
 849   3                              // =======================按键结束========================
 850   3                              
 851   3                              // =======================串口调试开始====================
 852   3                              if(command != 0x00)
 853   3                              {
 854   4                                      switch(command & 0xf0)
 855   4                                      {
 856   5                                              case 0xa0:
 857   5                                                      P0 = temp_Led_P0;
 858   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 859   5                                                      P0 = (P0 | 0x0f) & ((~command) | 0xf0);
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 15  

 860   5                                                      temp_Led_P0 = P0;
 861   5                                                      P2 &= 0x1f;
 862   5                                                      command = 0x00;
 863   5                                              break;
 864   5                                              case 0xb0:
 865   5                                                      P0 = temp_Led_P0;
 866   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 867   5                                                      P0 = (P0 | 0xf0) & (((~command) << 4) | 0x0f);
 868   5                                                      temp_Led_P0 = P0;
 869   5                                                      P2 &= 0x1f;
 870   5                                                      command = 0x00;
 871   5                                              break;
 872   5                                              case 0xc0:
 873   5                                                      Send_String("system is running...!\r\n");
 874   5                                                      command = 0x00;
 875   5                                              break;
 876   5                                      }
 877   4                              }
 878   3                              // =======================串口调试结束====================              
 879   3                              
 880   3                              // =========================================== 代码开始 ======================================                  
 881   3                              // =======================1.温度读取开始========================
 882   3                              if (f_200ms_temperature) {
 883   4                                      f_200ms_temperature = 0;
 884   4                                      temperature = Read_Temperature();
 885   4                                      My_Read_Ds1302();
 886   4                              }
 887   3      //                      num1=10;num2=10;num3=10;num4=10;
 888   3      //                      num5=temperature/1000;num6=temperature/100%10;
 889   3      //                      num7=temperature/10%10;num8=temperature%10;
 890   3                              // =======================1.温度读取结束========================
 891   3                              
 892   3                              dat[0] = ds1302_h;
 893   3                              dat[1] = ds1302_m;
 894   3                              dat[2] = ds1302_s;
 895   3                              Write_24C02_Page(0x01, dat, 3);
 896   3                              
 897   3                              if (dis_model == 0) {  // 时间显示
 898   4                                      num1=ds1302_h/10;num2=ds1302_h%10;num3=11;
 899   4                                      num4=ds1302_m/10;num5=ds1302_m%10;num6=11;
 900   4                                      num7=ds1302_s/10;num8=ds1302_s%10;
 901   4                              }
 902   3                              else if (dis_model == 1) {  // 温度显示
 903   4                                      num1=dis_model;num2=10;num3=10;num4=10;
 904   4                                      num5=temperature/1000;num6=temperature/100%10;
 905   4                                      num7=temperature/10%10;num8=temperature%10;
 906   4                              }
 907   3                              else if (dis_model == 2) {  // 时间设置
 908   4      //                              num_On_Off = Read_24C02_Byte(0x00);
 909   4      //                              num_On_Off ++ ;
 910   4      //                              Write_24C02_Byte(0x00, num_On_Off);
 911   4                                      f_set_time = 1;  // 时间设置标志
 912   4                                      num1 = set_ds1302_h / 10; num2 = set_ds1302_h % 10; num3 = 11; 
 913   4                                      num4 = set_ds1302_m / 10; num5 = set_ds1302_m % 10; num6 = 11;
 914   4                                      num7 = set_ds1302_s / 10, num8 = set_ds1302_s % 10;
 915   4      
 916   4                              }
 917   3                              else if (dis_model == 3) {
 918   4                                      num1 = dis_model;num2 = 10; num3 = 10; num4 = 10;
 919   4                                      num5= 10;
 920   4                                      num6=distance / 100; num7=distance % 100 / 10; num8=distance % 10;
 921   4                              }
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 16  

 922   3                              else if (dis_model ==4) {
 923   4                                      num1=dis_model;num2=dat[0]%10;num3=11;
 924   4                                      num4=dat[1]/10;num5=dat[1]%10;num6=11;
 925   4                                      num7=dat[2]/10;num8=dat[2]%10;
 926   4                              }
 927   3                              // =========================================== 代码结束 ======================================
 928   3              }
 929   2          }
 930   1      }
 931          
 932          void Service_T0() interrupt 1
 933          {
 934   1              TH0 = (65536 - 2000) / 256;
 935   1              TL0 = (65536 - 2000) % 256;
 936   1              
 937   1              f_2ms = 1;
 938   1              
 939   1              /***************************************************
 940   1              与时间相关的变量的更新放在里面
 941   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 942   1              ***************************************************/
 943   1              // =========================================== 代码开始 ======================================
 944   1              num_2ms ++ ;
 945   1              num_2ms_temperature ++ ;
 946   1              if (num_2ms_temperature == 100) {
 947   2                      f_200ms_temperature = 1;
 948   2                      num_2ms_temperature = 0;
 949   2              }
 950   1              
 951   1              if (num_2ms == 500) {
 952   2                      f_1s = 1;
 953   2                      num_2ms = 0;
 954   2              }
 955   1              
 956   1              if (f_1s == 1) {
 957   2                      f_1s = 0;
 958   2                      
 959   2                      if (f_time) num_s ++ ;
 960   2                      
 961   2                      if (is_key_set_time && dis_model == 2) {
 962   3                              num_s_key ++ ;
 963   3      //                      t_key = 0;
 964   3                              if (num_s_key == 3) {
 965   4                                      LED4_On();
 966   4                                      f_key_long = 1;
 967   4                              }
 968   3                      }                       
 969   2                              
 970   2                      
 971   2                      if (num_s == 9) 
 972   2                              num_s = 0;
 973   2              }
 974   1              // =========================================== 代码结束 ======================================
 975   1              
 976   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 977   1      }
 978          
 979          void ServiceUart() interrupt 4
 980          {
 981   1              if(RI == 1)
 982   1              {
 983   2                      RI = 0;//人工清零
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 00:20:33 PAGE 17  

 984   2                      urdat = SBUF;
 985   2                      command = SBUF;
 986   2      //              Send_Byte(urdat + 1);
 987   2      //              send_byte(0x5a);
 988   2      //              send_byte(0xa5);
 989   2              }
 990   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2784    ----
   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
