C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          #define uchar unsigned char 
   4          #define uint unsigned int
   5          
   6          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   7          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
   8          // xxx
   9          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  10          
  11          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  12          uchar GN;  // 按键标志位
  13          bit f_2ms;  // 2ms标志位
  14          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  15          
  16          sbit S7 = P3^0;
  17          sbit S6 = P3^1;
  18          sbit S5 = P3^2;
  19          sbit S4 = P3^3;
  20          
  21          sbit L1 = P0^0;
  22          sbit L2 = P0^1;
  23          sbit L3 = P0^2;
  24          sbit L4 = P0^3;
  25          sbit L5 = P0^4;
  26          sbit L6 = P0^5;
  27          
  28          // =========================================== 代码开始 ======================================
  29          bit f_1s;  // 1s标志位
  30          bit is_s7, is_s6;
  31          
  32          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  33          // =========================================== 代码结束 ======================================
  34          
  35          
  36          //=========================================普通延时函数(模板函数)=================================
  37          void Delay(uint t) {
  38   1              while( t -- );
  39   1              while( t -- );
  40   1      }
  41          //=======================================单个LED控制函数(模板函数)================================
  42          // ======================LED1====================
  43          void LED1_On() {
  44   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  45   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  46   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  47   1              temp_Led_P0 = P0;
  48   1              P2 &= 0x1f;
  49   1      }
  50          void LED1_Off() {
  51   1              P0 = 0xff & temp_Led_P0;
  52   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  53   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  54   1              temp_Led_P0 = P0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 2   

  55   1              P2 &= 0x1f;
  56   1      }
  57          // ======================LED2====================
  58          void LED2_On() {
  59   1              P0 = 0xff & temp_Led_P0;
  60   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  61   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  62   1              temp_Led_P0 = P0;
  63   1              P2 &= 0x1f;
  64   1      }
  65          void LED2_Off() {
  66   1              P0 = 0xff & temp_Led_P0;
  67   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  68   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  69   1              temp_Led_P0 = P0;
  70   1              P2 &= 0x1f;
  71   1      }
  72          // ======================LED3====================
  73          void LED3_On() {
  74   1              P0 = 0xff & temp_Led_P0;
  75   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  76   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
  77   1              temp_Led_P0 = P0;
  78   1              P2 &= 0x1f;
  79   1      }
  80          void LED3_Off() {
  81   1              P0 = 0xff & temp_Led_P0;
  82   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  83   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
  84   1              temp_Led_P0 = P0;
  85   1              P2 &= 0x1f;
  86   1      }
  87          // ======================LED4====================
  88          void LED4_On() {
  89   1              P0 = 0xff & temp_Led_P0;
  90   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  91   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
  92   1              temp_Led_P0 = P0;
  93   1              P2 &= 0x1f;
  94   1      }
  95          void LED4_Off() {
  96   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
  97   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  98   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
  99   1              temp_Led_P0 = P0;
 100   1              P2 &= 0x1f;
 101   1      }
 102          // ======================LED5====================
 103          void LED5_On() {
 104   1              P0 = 0xff & temp_Led_P0;
 105   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 106   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 107   1              temp_Led_P0 = P0;
 108   1              P2 &= 0x1f;
 109   1      }
 110          void LED5_Off() {
 111   1              P0 = 0xff & temp_Led_P0;
 112   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 113   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 114   1              temp_Led_P0 = P0;
 115   1              P2 &= 0x1f;
 116   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 3   

 117          // ======================LED6====================
 118          void LED6_On() {
 119   1              P0 = 0xff & temp_Led_P0;
 120   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 121   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 122   1              temp_Led_P0 = P0;
 123   1              P2 &= 0x1f;
 124   1      }
 125          void LED6_Off() {
 126   1              P0 = 0xff & temp_Led_P0;
 127   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 128   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 129   1              temp_Led_P0 = P0;
 130   1              P2 &= 0x1f;
 131   1      }
 132          
 133          void LED_On(uchar n) {
 134   1              P0 = 0xff & temp_Led_P0;
 135   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 136   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 137   1              temp_Led_P0 = P0;
 138   1              P2 &= 0x1f;
 139   1      }
*** WARNING C280 IN LINE 133 OF main.c: 'n': unreferenced local variable
 140          //=========================================数码管显示==============================================
 141          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 142          {
 143   1              char i;
 144   1              P0 = 0xff;
 145   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 146   1              P0 = type2[i];
 147   1              P2 &= 0x1f;
 148   1              switch(i)//数码管位选
 149   1              {
 150   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 151   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 152   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 153   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 154   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 155   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 156   2                                                                              if(0)  // 根据需要的条件
 157   2                                                                              {
 158   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 159   3                                                                              }
 160   2                                                                              else
 161   2                                                                                      P0 = type1[n6];
 162   2                                                                                                        P2 &= 0x1f;break;
 163   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 164   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 165   2              }
 166   1              if(++i==8)
 167   1                      i = 0;
 168   1      }
 169          //============================================独立按键============================================
 170          /***************************************************
 171          写法一：
 172          有按键被按下，GN标记，后面根据需要功能进行操作
 173          ***************************************************/
 174          void Delay_Keys(uint t)
 175          {
 176   1              while(t--);
 177   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 4   

 178          uchar Scan_Keys()
 179          {
 180   1              char d;
 181   1              d = (~P3) & 0x0f;
 182   1              if(d == 0) return 0;
 183   1              Delay_Keys(100);
 184   1              if(d == 0) return 0;
 185   1              Delay_Keys(100);
 186   1              return d;
 187   1      }
 188          void Change_Keys()
 189          {
 190   1              switch(Scan_Keys())
 191   1              {
 192   2                      case 8:GN = 1;break;//S4
 193   2                      case 4:GN = 2;break;//S5
 194   2                      case 2:GN = 3;break;//S6
 195   2                      case 1:GN = 4;break;//S7
 196   2                      case 0:GN = 0;break;
 197   2              }
 198   1      }
 199          
 200          /***************************************************
 201          写法二：
 202          有按键被按下，按下是一种状态，松开是另一种状态
 203          （如：按下时某个灯亮，松开时灯灭）
 204          ***************************************************/
 205          void ScanKeys_Alone() 
 206          {
 207   1              if (S7 == 0) {
 208   2                      Delay_Keys(100);
 209   2                      if (S7 == 0) {
 210   3                              // =========================================== 代码开始 ======================================
 211   3      //                      LED1_On();
 212   3                              
 213   3                              // =========================================== 代码结束 ======================================
 214   3                              while(S7 == 0);
 215   3                              // =========================================== 代码开始 ======================================
 216   3      //                      LED1_Off();
 217   3                              if (is_s6 == 0 && is_s7 == 1) {
 218   4                                      is_s7 = 0;
 219   4                              }
 220   3                              else if (is_s6 == 0 && is_s7 == 0) {
 221   4                                      is_s7 = 1;
 222   4                                      LED1_Off();
 223   4                              }
 224   3                              if (is_s6 == 0 && is_s7 == 1)
 225   3                                      LED1_On();
 226   3                              if (is_s6 == 0 && is_s7 == 0)
 227   3                                      LED1_Off();
 228   3                              // =========================================== 代码结束 ======================================
 229   3                      }
 230   2              }
 231   1              
 232   1              if (S6 == 0) {
 233   2                      Delay_Keys(100);
 234   2                      if (S6 == 0) {
 235   3                              // =========================================== 代码开始 ======================================
 236   3      //                      LED2_On();
 237   3                              
 238   3                              // =========================================== 代码结束 ======================================
 239   3                              while(S6 == 0);
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 5   

 240   3                              // =========================================== 代码开始 ======================================
 241   3      //                      LED2_Off();
 242   3                              if (is_s7 == 0 && is_s6 == 1) {
 243   4                                      is_s6 = 0;
 244   4                              }
 245   3                              else if (is_s7 == 0 && is_s6 == 0) {
 246   4                                      is_s6 = 1;
 247   4                              }
 248   3                              
 249   3                              if (is_s7 == 0 && is_s6 == 1)
 250   3                                      LED2_On();
 251   3                              if (is_s7 == 0 && is_s6 == 0)
 252   3                                      LED2_Off();
 253   3                              // =========================================== 代码结束 ======================================
 254   3                      }
 255   2              }
 256   1              
 257   1              if (S5 == 0) {
 258   2                      Delay_Keys(100);
 259   2                      if (S5 == 0) {
 260   3                              // =========================================== 代码开始 ======================================
 261   3      //                      LED3_On();
 262   3                              if (is_s7) {
 263   4                                      LED3_On();
 264   4                              }
 265   3                              if (is_s6) {
 266   4                                      LED5_On();
 267   4                              }
 268   3                              // =========================================== 代码结束 ======================================
 269   3                              while(S5 == 0);
 270   3                              // =========================================== 代码开始 ======================================
 271   3      //                      LED3_Off();
 272   3                              if (is_s7) {
 273   4                                      LED3_Off();
 274   4                              }
 275   3                              if (is_s6) {
 276   4                                      LED5_Off();
 277   4                              }
 278   3                              // =========================================== 代码结束 ======================================
 279   3                      }
 280   2              }
 281   1              
 282   1              if (S4 == 0) {
 283   2                      Delay_Keys(100);
 284   2                      if (S4 == 0) {
 285   3                              // =========================================== 代码开始 ======================================
 286   3      //                      LED4_On();
 287   3                              if (is_s7) {
 288   4                                      LED4_On();
 289   4                              }
 290   3                              if (is_s6) {
 291   4                                      LED6_On();
 292   4                              }
 293   3                              // =========================================== 代码结束 ======================================
 294   3                              while(S4 == 0);
 295   3                              // =========================================== 代码开始 ======================================
 296   3      //                      LED4_Off();
 297   3                              if (is_s7) {
 298   4                                      LED4_Off();
 299   4                              }
 300   3                              if (is_s6) {
 301   4                                      LED6_Off();
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 6   

 302   4                              }
 303   3                              // =========================================== 代码结束 ======================================
 304   3                      }
 305   2              }
 306   1      }
 307          
 308          // ================= 代码结束 =============
 309          
 310          //============================================矩阵按键============================================
 311          //sfr P4 = 0xc0;
 312          //sbit P44 = P4^4;
 313          //sbit P42 = P4^2;
 314          
 315          //uchar Scan_Keys()
 316          //{
 317          //      unsigned char H,L;
 318          //      P3 = P3 & 0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 319          //      if(H == 0) return 0;
 320          //      Delay_Keys(100);
 321          //      P3 = P3 & 0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 322          //      if(H == 0) return 0;
 323          //      P3 = P3 & 0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 324          ////            if(P44 == 0) L |= 0x80;
 325          ////            if(P42 == 0) L |= 0x40;
 326          //      return H+L;
 327          //}
 328          
 329          //void Change_Keys()
 330          //{
 331          //      switch(Scan_Keys())
 332          //      {
 333          //              case 0x88:GN = 4;break;//S4
 334          //              case 0x84:GN = 5;break;//S5
 335          //              case 0x82:GN = 6;break;//S6
 336          //              case 0x81:GN = 7;break;//S7
 337          //              case 0x48:GN = 8;break;
 338          //              case 0x44:GN = 9;break;
 339          //              case 0x42:GN = 10;break;
 340          //              case 0x41:GN = 11;break;
 341          //              case 0x28:GN = 12;break;
 342          //              case 0x24:GN = 13;break;
 343          //              case 0x22:GN = 14;break;
 344          //              case 0x21:GN = 15;break;
 345          //              case 0x18:GN = 16;break;
 346          //              case 0x14:GN = 17;break;
 347          //              case 0x12:GN = 18;break;
 348          //              case 0x11:GN = 19;break;
 349          //              case 0:GN = 0;break;
 350          //      }
 351          //}
 352          //============================================定时器T1初始化=======================================
 353          void Init_T1()
 354          {
 355   1              TMOD = (TMOD & 0xf0) | 0x10;//定时
 356   1              TH1 = (65536 - 2000) / 256;//2ms
 357   1              TL1 = (65536 - 2000) % 256;
 358   1              
 359   1              EA = 1;
 360   1              ET1 = 1;
 361   1              TR1 = 1;
 362   1      }
 363          //==========================================系统初始化=============================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 7   

 364          void Init_Sys()
 365          {
 366   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 367   1              P0 = 0xff;
 368   1              P2 &= 0x1f;
 369   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 370   1              P0 = 0x00;
 371   1              P2 &= 0x1f;
 372   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 373   1              P0 = 0xff;
 374   1              P2 &= 0x1f;
 375   1              P2 = (P2 & 0x1f) | 0xe0;
 376   1              P0 = 0xff;
 377   1              
 378   1      }
 379          
 380          void LED_control() {
 381   1              // ================= 测试开始 =============
 382   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 383   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 384   1      //      P2 &= 0x1f;
 385   1      
 386   1      //      uchar i;
 387   1      //      // 8个LED闪3次
 388   1      //      for (i = 0; i < 3; i ++ ) {
 389   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 390   1      //              P0 = 0x00;
 391   1      //              P2 &= 0x1f;
 392   1      //              Delay(60000);
 393   1      //              
 394   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 395   1      //              P0 = 0xff;
 396   1      //              P2 &= 0x1f;
 397   1      //              Delay(60000);
 398   1      //      }
 399   1      //      
 400   1      //      // 8个LED依次点亮0 -> 8
 401   1      //      for (i = 0; i < 8; i ++ ) {
 402   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 403   1      //              P0 = ~(0x01 << i);
 404   1      //              P2 &= 0x1f;
 405   1      //              Delay(60000);
 406   1      //      }
 407   1      //      
 408   1      //      // 8个LED依次点亮8 -> 0
 409   1      //      for (i = 0; i < 8; i ++ ) {
 410   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 411   1      //              P0 = ~(0x80 >> i);
 412   1      //              P2 &= 0x1f;
 413   1      //              Delay(60000);
 414   1      //      }
 415   1      //      
 416   1      //      // 8个LED依次点亮0 -> 8
 417   1      //      for (i = 0; i <= 8; i ++ ) {
 418   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 419   1      //              P0 = 0xff << i;
 420   1      //              P2 &= 0x1f;
 421   1      //              Delay(60000);
 422   1      //      }
 423   1      //      
 424   1      //      P2 = (P2 & 0x1f) | 0xa0;  // 寄存器控制开启
 425   1      //      P0 = 0x10;
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 8   

 426   1      //      P2 &= 0x1f;
 427   1      //      Delay(60000);
 428   1      //      Delay(60000);
 429   1      //      P2 = (P2 & 0x1f) | 0xa0;  // 寄存器控制开启
 430   1      //      P0 = 0x00;
 431   1      //      P2 &= 0x1f;
 432   1      //      
 433   1      //      // 8个LED依次点亮8 -> 0
 434   1      //      for (i = 0; i <= 8; i ++ ) {
 435   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 436   1      //              P0 = ~(0xff >> i);
 437   1      //              P2 &= 0x1f;
 438   1      //              Delay(60000);
 439   1      //      }
 440   1      //      
 441   1      //      P2 = (P2 & 0x1f) | 0xa0;  // 寄存器控制开启
 442   1      //      P0 = 0x40;
 443   1      //      P2 &= 0x1f;
 444   1      //      Delay(60000);
 445   1      //      Delay(60000);
 446   1      //      P2 = (P2 & 0x1f) | 0xa0;  // 寄存器控制开启
 447   1      //      P0 = 0x00;
 448   1      //      P2 &= 0x1f;
 449   1              
 450   1      //      uchar i;
 451   1      //      for (i = 0; i <= 14; i ++ )
 452   1      //      {
 453   1      //              num1=num2=num3=num4=num5=num6=num7=num8=i;
 454   1      //              Delay(60000);
 455   1      //      }
 456   1      
 457   1      //      if (GN == 1) {
 458   1      //              P0 = 0xff;
 459   1      //              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 460   1      //              led1 = ~led1;  // 要将P0放在这两句代码之间，避免错乱
 461   1      //              P2 &= 0x1f;
 462   1      //      }
 463   1              // ================= 测试结束 =============
 464   1              
 465   1              // =========================================== 代码开始 ======================================
 466   1      //      P0 = 0x22;
 467   1              
 468   1              // =========================================== 代码结束 ======================================
 469   1      }
 470          
 471          void main()
 472          {
 473   1              Init_Sys();
 474   1              Init_T1();
 475   1      //      Init_T0();
 476   1              
 477   1              while(1)
 478   1              {
 479   2      //              LED_control();
 480   2              if(f_2ms == 1)
 481   2              {
 482   3                  f_2ms = 0;                  
 483   3                              LED_control();  // xxx
 484   3      //                      Change_Keys();  // 按键扫描
 485   3                              ScanKeys_Alone();  // 独立按键扫描
 486   3                              // =========================================== 代码开始 ======================================
 487   3                              
C51 COMPILER V9.60.7.0   MAIN                                                              04/05/2024 17:02:09 PAGE 9   

 488   3                              // =========================================== 代码结束 ======================================
 489   3              }
 490   2          }
 491   1      }
 492          void Service_T1() interrupt 3
 493          {
 494   1              TH1 = (65536 - 2000) / 256;
 495   1              TL1 = (65536 - 2000) % 256;
 496   1              
 497   1              f_2ms = 1;
 498   1              
 499   1              /***************************************************
 500   1              与时间相关的变量的更新放在里面
 501   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 502   1              ***************************************************/
 503   1              // =========================================== 代码开始 ======================================
 504   1              num_2ms ++ ;
 505   1              if (num_2ms == 500) {
 506   2                      f_1s = 1;
 507   2                      num_2ms = 0;
 508   2              }
 509   1              if (f_1s == 1) {
 510   2                      f_1s = 0;
 511   2                      num_s ++ ;
 512   2                      if (num_s == 9) 
 513   2                      num_s = 0;
 514   2              }
 515   1              num1 = 2;num2 = 0; num3 = 2; num4 = 4;
 516   1              num5=num6=11;
 517   1              num7=num8=num_s;
 518   1              // =========================================== 代码结束 ======================================
 519   1              
 520   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 521   1      }
*** WARNING C294 IN LINE 158 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    974    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
