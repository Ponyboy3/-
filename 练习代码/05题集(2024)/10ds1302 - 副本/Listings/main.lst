C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          #include "onewire.h"
   3          #include "iic.h"
   4          #include "ds1302.h"
   5          
   6          #define uchar unsigned char 
   7          #define uint unsigned int
   8          
   9          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
  10          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
  11          // xxx
  12          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  13          
  14          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  15          uchar GN;  // 按键标志位
  16          bit f_2ms, f_50ms, f_200ms_temperature;  // 2ms, 50ms, 500ms标志位
  17          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  18          uint temperature;  // 温度
  19          uint num_2ms_temperature;  // 多少个2ms
  20          uchar ds1302_h, ds1302_m, ds1302_s;  // 
  21          
  22          uchar dis_model = 0;  // 0:显示温度（DS18B20）， 1:显示时钟
  23          
  24          sbit S7 = P3^0;
  25          sbit S6 = P3^1;
  26          sbit S5 = P3^2;
  27          sbit S4 = P3^3;
  28          
  29          sbit L0 = P0^0;
  30          sbit L1 = P0^1;
  31          sbit L2 = P0^2;
  32          sbit L3 = P0^3;
  33          sbit L4 = P0^4;
  34          sbit L5 = P0^5;
  35          sbit L6 = P0^6;
  36          
  37          // =========================================== 代码开始 ======================================
  38          bit f_1s;  // 1s标志位
  39          
  40          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  41          
  42          uchar urdat;    
  43          
  44          bit f;
  45          uint temp_f,temp_t;
  46          uint t_2ms;
  47          // =========================================== 代码结束 ======================================
  48          
  49          
  50          //=========================================普通延时函数(模板函数)=================================
  51          void Delay(uint t) {
  52   1              while( t -- );
  53   1              while( t -- );
  54   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 2   

  55          //=======================================单个LED控制函数(模板函数)================================
  56          // 根据项目需要删减
  57          
  58          // ======================LED0====================
  59          void LED0_On() {
  60   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  61   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  62   1              L0 = 0;  // 要将P0放在这两句代码之间，避免错乱
  63   1              temp_Led_P0 = P0;
  64   1              P2 &= 0x1f;
  65   1      }
  66          void LED0_Off() {
  67   1              P0 = 0xff & temp_Led_P0;
  68   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  69   1              L0 = 1;  // 要将P0放在这两句代码之间，避免错乱
  70   1              temp_Led_P0 = P0;
  71   1              P2 &= 0x1f;
  72   1      }
  73          // ======================LED1====================
  74          void LED1_On() {
  75   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  76   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  77   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  78   1              temp_Led_P0 = P0;
  79   1              P2 &= 0x1f;
  80   1      }
  81          void LED1_Off() {
  82   1              P0 = 0xff & temp_Led_P0;
  83   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  84   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  85   1              temp_Led_P0 = P0;
  86   1              P2 &= 0x1f;
  87   1      }
  88          // ======================LED2====================
  89          void LED2_On() {
  90   1              P0 = 0xff & temp_Led_P0;
  91   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  92   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  93   1              temp_Led_P0 = P0;
  94   1              P2 &= 0x1f;
  95   1      }
  96          void LED2_Off() {
  97   1              P0 = 0xff & temp_Led_P0;
  98   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  99   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
 100   1              temp_Led_P0 = P0;
 101   1              P2 &= 0x1f;
 102   1      }
 103          // ======================LED3====================
 104          void LED3_On() {
 105   1              P0 = 0xff & temp_Led_P0;
 106   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 107   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
 108   1              temp_Led_P0 = P0;
 109   1              P2 &= 0x1f;
 110   1      }
 111          void LED3_Off() {
 112   1              P0 = 0xff & temp_Led_P0;
 113   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 114   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
 115   1              temp_Led_P0 = P0;
 116   1              P2 &= 0x1f;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 3   

 117   1      }
 118          //// ======================LED4====================
 119          //void LED4_On() {
 120          //      P0 = 0xff & temp_Led_P0;
 121          //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 122          //      L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
 123          //      temp_Led_P0 = P0;
 124          //      P2 &= 0x1f;
 125          //}
 126          //void LED4_Off() {
 127          //      P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 128          //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 129          //      L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 130          //      temp_Led_P0 = P0;
 131          //      P2 &= 0x1f;
 132          //}
 133          //// ======================LED5====================
 134          //void LED5_On() {
 135          //      P0 = 0xff & temp_Led_P0;
 136          //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 137          //      L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 138          //      temp_Led_P0 = P0;
 139          //      P2 &= 0x1f;
 140          //}
 141          //void LED5_Off() {
 142          //      P0 = 0xff & temp_Led_P0;
 143          //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 144          //      L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 145          //      temp_Led_P0 = P0;
 146          //      P2 &= 0x1f;
 147          //}
 148          //// ======================LED6====================
 149          //void LED6_On() {
 150          //      P0 = 0xff & temp_Led_P0;
 151          //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 152          //      L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 153          //      temp_Led_P0 = P0;
 154          //      P2 &= 0x1f;
 155          //}
 156          //void LED6_Off() {
 157          //      P0 = 0xff & temp_Led_P0;
 158          //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 159          //      L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 160          //      temp_Led_P0 = P0;
 161          //      P2 &= 0x1f;
 162          //}
 163          //=========================================数码管显示==============================================
 164          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 165          {
 166   1              char i;
 167   1              P0 = 0xff;
 168   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 169   1              P0 = type2[i];
 170   1              P2 &= 0x1f;
 171   1              switch(i)//数码管位选
 172   1              {
 173   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 174   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 175   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 176   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 177   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 178   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 4   

 179   2                                                                              if(dis_model == 1)  // 根据需要的条件
 180   2                                                                              {
 181   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 182   3                                                                              }
 183   2                                                                              else
 184   2                                                                                      P0 = type1[n6];
 185   2                                                                                                        P2 &= 0x1f;break;
 186   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 187   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 188   2              }
 189   1              if(++i==8)
 190   1                      i = 0;
 191   1      }
 192          //============================================独立按键============================================
 193          /***************************************************
 194          写法一：
 195          有按键被按下，GN标记，后面根据需要功能进行操作
 196          ***************************************************/
 197          void Delay_Keys(uint t)
 198          {
 199   1              while(t--);
 200   1      }
 201          uchar Scan_Keys_Alone()
 202          {
 203   1              char d;
 204   1              d = (~P3) & 0x0f;
 205   1              if(d == 0) return 0;
 206   1              Delay_Keys(100);
 207   1              if(d == 0) return 0;
 208   1              Delay_Keys(100);
 209   1              return d;
 210   1      }
 211          void Change_Keys_Alone()
 212          {
 213   1              switch(Scan_Keys_Alone())
 214   1              {
 215   2                      case 8:GN = 1;break;//S4
 216   2                      case 4:GN = 2;break;//S5
 217   2                      case 2:GN = 3;break;//S6
 218   2                      case 1:GN = 4;break;//S7
 219   2                      case 0:GN = 0;break;
 220   2              }
 221   1      }
 222          
 223          /***************************************************
 224          写法二：
 225          有按键被按下，按下是一种状态，松开是另一种状态
 226          （如：按下时某个灯亮，松开时灯灭）
 227          ***************************************************/
 228          //void ScanKeys_Alone() 
 229          //{
 230          //      if (S7 == 0) {
 231          //              Delay_Keys(100);
 232          //              if (S7 == 0) {
 233          //                      // =========================================== 代码开始 ======================================
 234          //                      
 235          //                      // =========================================== 代码结束 ======================================
 236          //                      while(S7 == 0);
 237          //                      // =========================================== 代码开始 ======================================
 238          
 239          //                      // =========================================== 代码结束 ======================================
 240          //              }
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 5   

 241          //      }
 242          //      
 243          //      if (S6 == 0) {
 244          //              Delay_Keys(100);
 245          //              if (S6 == 0) {
 246          //                      // =========================================== 代码开始 ======================================
 247          //                      
 248          //                      // =========================================== 代码结束 ======================================
 249          //                      while(S6 == 0);
 250          //                      // =========================================== 代码开始 ======================================
 251          
 252          //                      // =========================================== 代码结束 ======================================
 253          //              }
 254          //      }
 255          //      
 256          //      if (S5 == 0) {
 257          //              Delay_Keys(100);
 258          //              if (S5 == 0) {
 259          //                      // =========================================== 代码开始 ======================================
 260          
 261          //                      // =========================================== 代码结束 ======================================
 262          //                      while(S5 == 0);
 263          //                      // =========================================== 代码开始 ======================================
 264          
 265          //                      // =========================================== 代码结束 ======================================
 266          //              }
 267          //      }
 268          
 269          //      if (S4 == 0) {
 270          //              Delay_Keys(100);
 271          //              if (S4 == 0) {
 272          //                      // =========================================== 代码开始 ======================================
 273          
 274          //                      // =========================================== 代码结束 ======================================
 275          //                      while(S4 == 0);
 276          //                      // =========================================== 代码开始 ======================================
 277          
 278          //                      // =========================================== 代码结束 ======================================
 279          //              }
 280          //      }
 281          //}
 282          
 283          // ================= 代码结束 =============
 284          
 285          //============================================矩阵按键============================================
 286          sfr P4 = 0xc0;
 287          sbit P44 = P4^4;
 288          sbit P42 = P4^2;
 289          
 290          uchar Scan_Keys()
 291          {
 292   1              char H,L;
 293   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 294   1              if(H == 0) return 0;
 295   1              Delay_Keys(100);
 296   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 297   1              if(H == 0) return 0;
 298   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 299   1              if(P44 == 0) L |= 0x80;
 300   1              if(P42 == 0) L |= 0x40;
 301   1              return (H+L);
 302   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 6   

 303          
 304          void Change_Keys()
 305          {
 306   1              switch(Scan_Keys())
 307   1              {
 308   2                      case 0x88:GN = 4;break;  // S4
 309   2                      case 0x84:GN = 5;break;  // S5
 310   2                      case 0x82:GN = 6;break;  // S6
 311   2                      case 0x81:GN = 7;break;  // S7
 312   2                      case 0x48:GN = 8;break;  // S8
 313   2                      case 0x44:GN = 9;break;  // S9
 314   2                      case 0x42:GN = 10;break;  // S10
 315   2                      case 0x41:GN = 11;break;  // S11
 316   2                      case 0x28:GN = 12;break;  // S12
 317   2                      case 0x24:GN = 13;break;  // S13
 318   2                      case 0x22:GN = 14;break;  // S14
 319   2                      case 0x21:GN = 15;break;  // S15
 320   2                      case 0x18:GN = 16;break;  // S16
 321   2                      case 0x14:GN = 17;break;  // S17
 322   2                      case 0x12:GN = 18;break;  // S18
 323   2                      case 0x11:GN = 19;break;  // S19
 324   2                      case 0:GN = 0;break;
 325   2              }
 326   1      }
 327          //============================================24C02初始化============================================
 328          void Write_24C02(unsigned char addr,unsigned char dat)
 329          {
 330   1              I2CStart();
 331   1              I2CSendByte(0xa0);
 332   1              I2CWaitAck();
 333   1              I2CSendByte(addr);
 334   1              I2CWaitAck();
 335   1              I2CSendByte(dat);
 336   1              I2CWaitAck();
 337   1              I2CStop(); 
 338   1      }
 339          
 340          unsigned char Read_24C02(unsigned char addr)
 341          {
 342   1              unsigned char tmp;
 343   1              I2CStart();
 344   1              I2CSendByte(0xa0);
 345   1              I2CWaitAck();
 346   1              I2CSendByte(addr);
 347   1              I2CWaitAck();
 348   1              
 349   1              I2CStart();
 350   1              I2CSendByte(0xa1);
 351   1              I2CWaitAck();
 352   1              tmp = I2CRecByte(); 
*** WARNING C206 IN LINE 352 OF main.c: 'I2CRecByte': missing function-prototype
 353   1              I2CSendAck(1);
 354   1              I2CStop();
 355   1              
 356   1              return tmp;
 357   1      }
 358          //============================================DS18B20初始化============================================
 359          void Init_18b20()
 360          {
 361   1              init_ds18b20();
 362   1              Write_DS18B20(0xcc);
 363   1              Write_DS18B20(0x4e);
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 7   

 364   1              Write_DS18B20(0x00);
 365   1              Write_DS18B20(0x00);
 366   1              Write_DS18B20(0x7f);
 367   1      }
 368          unsigned int Read_Temperature(void)  // 当需要保留2为小数时，才需要用到unsigned int,
 369                                                                                   // 这里介绍3种类型，所以用unsigned int，保留整数
 370                                                                           // 和一位小数可用unsigned char.
 371          {
 372   1              unsigned char H,L;
 373   1              init_ds18b20();
 374   1              Write_DS18B20(0xcc);
 375   1              Write_DS18B20(0xbe);
 376   1              L = Read_DS18B20();
 377   1              H = Read_DS18B20();
 378   1              
 379   1              init_ds18b20();
 380   1              Write_DS18B20(0xcc);
 381   1              Write_DS18B20(0x44);
 382   1              
 383   1              //1.保留整数--23
 384   1              //temp = (H<<4) + (L>>4);
 385   1              
 386   1              //2.保留1位小数--23.4
 387   1              //temp = ((H<<8) + L)*5/8;
 388   1              
 389   1              //3.保留2位小数--23.45
 390   1              return ((H<<8)+L)*25/4;  // (50/8)
 391   1      }
 392          //============================================Ds1302初始化============================================
 393          void My_Write_Ds1302()
 394          {
 395   1              Write_Ds1302_Byte(0x8e,0x00);
 396   1              Write_Ds1302_Byte(0x84,0x23);//时
 397   1              Write_Ds1302_Byte(0x82,0x59);//分
 398   1              Write_Ds1302_Byte(0x80,0x45);//秒
 399   1      }
 400          void My_Read_Ds1302()
 401          {
 402   1              ds1302_h = Read_Ds1302_Byte(0x85);//时
 403   1              ds1302_h = (ds1302_h >> 4) * 10 + (ds1302_h & 0x0f);
 404   1              ds1302_m = Read_Ds1302_Byte(0x83);//分
 405   1              ds1302_m = (ds1302_m >> 4) * 10 + (ds1302_m & 0x0f);
 406   1              ds1302_s = Read_Ds1302_Byte(0x81);//秒
 407   1              ds1302_s = (ds1302_s >> 4) * 10 + (ds1302_s & 0x0f);
 408   1      }
 409          //============================================定时器T0初始化=======================================
 410          uchar count = 0;
 411          uchar pwm_dut = 0;//占空比
 412          void Init_T0()
 413          {
 414   1      //      TMOD = (TMOD & 0xf0) | 0x01;  // 定时
 415   1      //      TH0 = (65536 - 2000) / 256;
 416   1      //      TL0 = (65536 - 2000) % 256;
 417   1      //      
 418   1      //      EA = 1;
 419   1      //      ET0 = 1;
 420   1      //      TR0 = 1;
 421   1              TMOD = (TMOD & 0xf0) | 0x05;
 422   1              TH0 = 0;
 423   1              TL0 = 0;
 424   1      }
 425          //============================================定时器T1初始化=======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 8   

 426          void Init_T1()
 427          {
 428   1              TMOD = (TMOD & 0x0f) | 0x10;//定时
 429   1              TH1 = (65536 - 2000) / 256;//2ms
 430   1              TL1 = (65536 - 2000) % 256;
 431   1              
 432   1              EA = 1;
 433   1              ET1 = 1;
 434   1              TR1 = 1;
 435   1      }
 436          //============================================串口初始化============================================
 437          #include "intrins.h"
 438          #include "string.h"
 439          
 440          sfr AUXR = 0x8e;  // 辅助寄存器
 441          sfr T2H=0xd6;  // 定时器2高8位
 442          sfr T2L=0xd7;  // 定时器2低8位
 443          #define BAUD         9600
 444          //#define SYSTEMCLOCK  11059200L
 445          #define SYSTEMCLOCK  12000000L
 446          uchar command = 0x00;
 447          void Init_Uart()
 448          {
 449   1      //      TMOD = (TMOD & 0x0f) | 0x00;
 450   1      //      TL1 = (65535-(SYSTEMCLOCK / 4 / BAUD));
 451   1      //      TH1 = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 452   1      ////    ET1 = 0;                    //禁止定时器1中断
 453   1      //      TR1 = 1;                    //启动定时器1
 454   1      //      
 455   1      //      SCON = 0x50;
 456   1      //      AUXR = 0x40;
 457   1              
 458   1              // ===================T2实现===================
 459   1              SCON = 0x50;  // 8位数据,可变波特率
 460   1          AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
 461   1          AUXR |= 0x04; // 定时器时钟1T模式
 462   1              
 463   1              T2L = (65535-(SYSTEMCLOCK / 4 / BAUD));
 464   1              T2H = (65535-(SYSTEMCLOCK / 4 / BAUD)) >> 8l;
 465   1              
 466   1      //      ET1 = 0;                    //禁止定时器1中断
 467   1      //      TR1 = 1;                    //启动定时器1
 468   1      //      SCON = 0x50;
 469   1      //      AUXR = 0x40;
 470   1              
 471   1              AUXR |= 0x10; // 定时器2开始计时
 472   1              // ===================T2实现===================
 473   1              
 474   1              ES = 1;
 475   1              EA = 1;
 476   1              
 477   1      }
 478          // 发送一个字节数据
 479          void Send_Byte(unsigned char dat)
 480          {
 481   1              SBUF = dat;
 482   1              while(TI == 0);
 483   1              TI = 0;
 484   1      }
 485          //发送一串字符串
 486          void Send_String(unsigned char* str)
 487          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 9   

 488   1        
 489   1        while(*str != '\0')
 490   1        {
 491   2          Send_Byte(*(str++));
 492   2        }
 493   1      }
 494          //==========================================系统初始化=============================================
 495          void Init_Sys()
 496          {
 497   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 498   1              P0 = 0xff;
 499   1              P2 &= 0x1f;
 500   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 501   1              P0 = 0x00;
 502   1              P2 &= 0x1f;
 503   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 504   1              P0 = 0xff;
 505   1              P2 &= 0x1f;
 506   1              P2 = (P2 & 0x1f) | 0xe0;
 507   1              P0 = 0xff;
 508   1              
 509   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 510   1      }
 511          
 512          void LED_control() {
 513   1              // ================= 测试开始 =============
 514   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 515   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 516   1      //      P2 &= 0x1f;
 517   1              // ================= 测试结束 =============
 518   1              
 519   1              // =========================================== 代码开始 ======================================
 520   1              
 521   1              // =========================================== 代码结束 ======================================
 522   1      }
 523          
 524          void main()
 525          {
 526   1              Init_Sys();
 527   1              Init_T1();
 528   1              Init_T0();
 529   1              Init_18b20();
 530   1              My_Write_Ds1302();
 531   1              Init_Uart();
 532   1      //      Send_String("I am OK\r\n");
 533   1              
 534   1              while(1)
 535   1              {
 536   2      //              LED_control();
 537   2              if(f_2ms == 1)
 538   2              {
 539   3                  f_2ms = 0;                  
 540   3                              LED_control();  // xxx  
 541   3                              // =======================按键开始========================
 542   3                              /*根据需要选择对应的按键类型*/
 543   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 544   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 545   3                              Change_Keys();        // 3.矩阵按键扫描
 546   3                              if (GN == 13) {  // S16
 547   4                                      // =========================================== 代码开始 ======================================
 548   4                                      LED1_On();
 549   4                                      // =========================================== 代码结束 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 10  

 550   4                                      while(Scan_Keys());
 551   4                                      // =========================================== 代码开始 ======================================
 552   4                                      LED1_Off();
 553   4                                      dis_model ++ ;
 554   4                                      if (dis_model > 3) dis_model = 0;
 555   4                                      // =========================================== 代码结束 ======================================
 556   4                              }
 557   3                              /*根据需要添加对应按键*/
 558   3                              // =======================按键结束========================
 559   3                              
 560   3                              // =======================串口调试开始====================
 561   3                              if(command != 0x00)
 562   3                              {
 563   4                                      switch(command & 0xf0)
 564   4                                      {
 565   5                                              case 0xa0:
 566   5                                                      P0 = temp_Led_P0;
 567   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 568   5                                                      P0 = (P0 | 0x0f) & ((~command) | 0xf0);
 569   5                                                      temp_Led_P0 = P0;
 570   5                                                      P2 &= 0x1f;
 571   5                                                      command = 0x00;
 572   5                                              break;
 573   5                                              case 0xb0:
 574   5                                                      P0 = temp_Led_P0;
 575   5                                                      P2 = (P2 & 0x1f) | 0x80;  // LED
 576   5                                                      P0 = (P0 | 0xf0) & (((~command) << 4) | 0x0f);
 577   5                                                      temp_Led_P0 = P0;
 578   5                                                      P2 &= 0x1f;
 579   5                                                      command = 0x00;
 580   5                                              break;
 581   5                                              case 0xc0:
 582   5                                                      Send_String("system is running...!\r\n");
 583   5                                                      command = 0x00;
 584   5                                              break;
 585   5                                      }
 586   4                              }
 587   3                              // =======================串口调试结束====================              
 588   3                              
 589   3                              // =========================================== 代码开始 ======================================                  
 590   3                              // =======================1.温度读取开始========================
 591   3                              if (f_200ms_temperature) {
 592   4                                      f_200ms_temperature = 0;
 593   4                                      temperature = Read_Temperature();
 594   4                                      My_Read_Ds1302();
 595   4                              }
 596   3      //                      num1=10;num2=10;num3=10;num4=10;
 597   3      //                      num5=temperature/1000;num6=temperature/100%10;
 598   3      //                      num7=temperature/10%10;num8=temperature%10;
 599   3                              // =======================1.温度读取结束========================
 600   3                              
 601   3                              if (dis_model == 0) {  // 时间显示
 602   4                                      num1=ds1302_h/10;num2=ds1302_h%10;num3=11;
 603   4                                      num4=ds1302_m/10;num5=ds1302_m%10;num6=11;
 604   4                                      num7=ds1302_s/10;num8=ds1302_s%10;
 605   4                              }
 606   3                              else if (dis_model == 1) {  // 温度显示
 607   4                                      num1=dis_model;num2=10;num3=10;num4=10;
 608   4                                      num5=temperature/1000;num6=temperature/100%10;
 609   4                                      num7=temperature/10%10;num8=temperature%10;
 610   4                              }
 611   3                              else if (dis_model == 2) {
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 11  

 612   4                                      num1 = dis_model;
 613   4                                      num2 = 0; num3 = 2; num4 = 4;
 614   4                                      num5=num6=11;
 615   4                                      num7=num_s / 10, num8=num_s % 10;
 616   4                              }
 617   3                              else if (dis_model == 3) {
 618   4                                      num1 = dis_model;
 619   4      //                              num2 = 0; num3 = 2; 
 620   4      //                              num4 = 4;
 621   4      //                              num5=num6=11;
 622   4      //                              num7=num_s / 10, num8=num_s % 10;
 623   4                                      
 624   4                                      num4=temp_f/10000;num5=temp_f/1000%10;num6=temp_f/100%10;num7=temp_f/10%10;num8=temp_f%10;
 625   4                              }
 626   3                              // =========================================== 代码结束 ======================================
 627   3              }
 628   2          }
 629   1      }
 630          
 631          void Service_T1() interrupt 3
 632          {
 633   1              TH1 = (65536 - 2000) / 256;
 634   1              TL1 = (65536 - 2000) % 256;
 635   1              
 636   1              f_2ms = 1;
 637   1              
 638   1              /***************************************************
 639   1              与时间相关的变量的更新放在里面
 640   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 641   1              ***************************************************/
 642   1              // =========================================== 代码开始 ======================================
 643   1              num_2ms ++ ;
 644   1              num_2ms_temperature ++ ;
 645   1              if (num_2ms_temperature == 100) {
 646   2                      f_200ms_temperature = 1;
 647   2                      num_2ms_temperature = 0;
 648   2              }
 649   1              
 650   1              if (num_2ms == 500) {
 651   2                      f_1s = 1;
 652   2                      num_2ms = 0;
 653   2              }
 654   1              if (f_1s == 1) {
 655   2                      f_1s = 0;
 656   2                      num_s ++ ;
 657   2                      if (num_s == 9) 
 658   2                      num_s = 0;
 659   2              }
 660   1      //      num1 = 2;num2 = 0; num3 = 2; num4 = 4;
 661   1      //      num5=num6=11;
 662   1      //      num7=num_s / 10, num8=num_s % 10;
 663   1              // =========================================== 代码结束 ======================================
 664   1              
 665   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 666   1              
 667   1              if(++t_2ms == 250)
 668   1              {
 669   2                      t_2ms = 0;
 670   2                      f=~f;
 671   2                      if(f == 0)
 672   2                      {
 673   3                              TH0 = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2024 22:58:42 PAGE 12  

 674   3                              TL0 = 0;
 675   3                              TR0 = 1;
 676   3                      }
 677   2                      else
 678   2                      {
 679   3                              TR0 = 0;
 680   3                              temp_f=((TH0<<8)+TL0)*2;
 681   3                      }
 682   2              }
 683   1      }
 684          
 685          void ServiceUart() interrupt 4
 686          {
 687   1              if(RI == 1)
 688   1              {
 689   2                      RI = 0;//人工清零
 690   2                      urdat = SBUF;
 691   2                      command = SBUF;
 692   2      //              Send_Byte(urdat + 1);
 693   2      //              send_byte(0x5a);
 694   2      //              send_byte(0xa5);
 695   2              }
 696   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1808    ----
   CONSTANT SIZE    =     47    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
