C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "reg52.h"
   2          
   3          #define uchar unsigned char 
   4          #define uint unsigned int
   5          
   6          // 数码管显示数据， 一般前10个为0-9， 可更具需要往里面添加
   7          uchar code type1[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0x8e,0xc8,0xc1};
   8          // xxx
   9          uchar code type2[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  10          
  11          uchar num1,num2,num3,num4,num5,num6,num7,num8;  // 数码管每一位（例如 num1 = 2, 第一个数码管显示 2）
  12          uchar GN;  // 按键标志位
  13          bit f_2ms;  // 2ms标志位
  14          uchar temp_Led_P0 = 0xff;  // 用来存上一次LED状态
  15          
  16          sbit S7 = P3^0;
  17          sbit S6 = P3^1;
  18          sbit S5 = P3^2;
  19          sbit S4 = P3^3;
  20          
  21          sbit L1 = P0^0;
  22          sbit L2 = P0^1;
  23          sbit L3 = P0^2;
  24          sbit L4 = P0^3;
  25          sbit L5 = P0^4;
  26          sbit L6 = P0^5;
  27          sbit L7 = P0^6;
  28          
  29          bit f_1s, f_10ms;  // 1s标志位
  30          
  31          uint num_2ms = 0, num_s = 0;  // 多少个2ms, 1s
  32          
  33          uint num_2ms_ne555=0, freq;
  34          // =========================================== 代码开始 ======================================
  35          
  36          
  37          // =========================================== 代码结束 ======================================
  38          
  39          
  40          //=========================================普通延时函数(模板函数)=================================
  41          void Delay(uint t) {
  42   1              while( t -- );
  43   1              while( t -- );
  44   1      }
  45          //=======================================单个LED控制函数(模板函数)================================
  46          // ======================LED1====================
  47          void LED1_On() {
  48   1              P0 = 0xff & temp_Led_P0;  // 清除其他地方对P0的值（特别是数码管一直在刷新），并且结合LED前一次的状态
  49   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  50   1              L1 = 0;  // 要将P0放在这两句代码之间，避免错乱
  51   1              temp_Led_P0 = P0;
  52   1              P2 &= 0x1f;
  53   1      }
  54          void LED1_Off() {
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 2   

  55   1              P0 = 0xff & temp_Led_P0;
  56   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  57   1              L1 = 1;  // 要将P0放在这两句代码之间，避免错乱
  58   1              temp_Led_P0 = P0;
  59   1              P2 &= 0x1f;
  60   1      }
  61          // ======================LED2====================
  62          void LED2_On() {
  63   1              P0 = 0xff & temp_Led_P0;
  64   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  65   1              L2 = 0;  // 要将P0放在这两句代码之间，避免错乱
  66   1              temp_Led_P0 = P0;
  67   1              P2 &= 0x1f;
  68   1      }
  69          void LED2_Off() {
  70   1              P0 = 0xff & temp_Led_P0;
  71   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  72   1              L2 = 1;  // 要将P0放在这两句代码之间，避免错乱
  73   1              temp_Led_P0 = P0;
  74   1              P2 &= 0x1f;
  75   1      }
  76          // ======================LED3====================
  77          void LED3_On() {
  78   1              P0 = 0xff & temp_Led_P0;
  79   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  80   1              L3 = 0;  // 要将P0放在这两句代码之间，避免错乱
  81   1              temp_Led_P0 = P0;
  82   1              P2 &= 0x1f;
  83   1      }
  84          void LED3_Off() {
  85   1              P0 = 0xff & temp_Led_P0;
  86   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  87   1              L3 = 1;  // 要将P0放在这两句代码之间，避免错乱
  88   1              temp_Led_P0 = P0;
  89   1              P2 &= 0x1f;
  90   1      }
  91          // ======================LED4====================
  92          void LED4_On() {
  93   1              P0 = 0xff & temp_Led_P0;
  94   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
  95   1              L4 = 0;  // 要将P0放在这两句代码之间，避免错乱
  96   1              temp_Led_P0 = P0;
  97   1              P2 &= 0x1f;
  98   1      }
  99          void LED4_Off() {
 100   1              P0 = 0xff & temp_Led_P0 & temp_Led_P0;
 101   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 102   1              L4 = 1;  // 要将P0放在这两句代码之间，避免错乱
 103   1              temp_Led_P0 = P0;
 104   1              P2 &= 0x1f;
 105   1      }
 106          // ======================LED5====================
 107          void LED5_On() {
 108   1              P0 = 0xff & temp_Led_P0;
 109   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 110   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 111   1              temp_Led_P0 = P0;
 112   1              P2 &= 0x1f;
 113   1      }
 114          void LED5_Off() {
 115   1              P0 = 0xff & temp_Led_P0;
 116   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 3   

 117   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 118   1              temp_Led_P0 = P0;
 119   1              P2 &= 0x1f;
 120   1      }
 121          // ======================LED6====================
 122          void LED6_On() {
 123   1              P0 = 0xff & temp_Led_P0;
 124   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 125   1              L6 = 0;  // 要将P0放在这两句代码之间，避免错乱
 126   1              temp_Led_P0 = P0;
 127   1              P2 &= 0x1f;
 128   1      }
 129          void LED6_Off() {
 130   1              P0 = 0xff & temp_Led_P0;
 131   1              P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 132   1              L6 = 1;  // 要将P0放在这两句代码之间，避免错乱
 133   1              temp_Led_P0 = P0;
 134   1              P2 &= 0x1f;
 135   1      }
 136          // ======================继电器===================
 137          void Relay_On() {
 138   1              P0 = 0x00;
 139   1              P2 = (P2 & 0x1f) | 0xa0;  // 继电器控制开启
 140   1              L5 = 1;  // 要将P0放在这两句代码之间，避免错乱
 141   1              P2 &= 0x1f;
 142   1      }
 143          void Relay_Off() {
 144   1              P0 = 0x00;
 145   1              P2 = (P2 & 0x1f) | 0xa0;  // 继电器控制关闭
 146   1              L5 = 0;  // 要将P0放在这两句代码之间，避免错乱
 147   1              P2 &= 0x1f;
 148   1      }
 149          // ======================继电器===================
 150          void Buzzer_On() {
 151   1              P0 = 0x00;
 152   1              P2 = (P2 & 0x1f) | 0xa0;  // 继电器控制开启
 153   1              L7 = 1;  // 要将P0放在这两句代码之间，避免错乱
 154   1              P2 &= 0x1f;
 155   1      }
 156          void Buzzer_Off() {
 157   1              P0 = 0x00;
 158   1              P2 = (P2 & 0x1f) | 0xa0;  // 继电器控制关闭
 159   1              L7 = 0;  // 要将P0放在这两句代码之间，避免错乱
 160   1              P2 &= 0x1f;
 161   1      }
 162          //=========================================数码管显示==============================================
 163          void Display_SMG(uchar n1,uchar n2,uchar n3,uchar n4,uchar n5,uchar n6,uchar n7,uchar n8)
 164          {
 165   1              char i;
 166   1              P0 = 0xff;
 167   1              P2 = (P2 & 0x1f) | 0xc0;//数码管位选
 168   1              P0 = type2[i];
 169   1              P2 &= 0x1f;
 170   1              switch(i)//数码管位选
 171   1              {
 172   2                      case 0:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n1];P2 &= 0x1f;break;
 173   2                      case 1:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n2];P2 &= 0x1f;break;
 174   2                      case 2:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n3];P2 &= 0x1f;break;
 175   2                      case 3:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n4];P2 &= 0x1f;break;
 176   2                      case 4:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n5];P2 &= 0x1f;break;
 177   2                      case 5:P2 = (P2 & 0x1f) | 0xe0;
 178   2                                                                              if(0)  // 根据需要的条件
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 4   

 179   2                                                                              {
 180   3                                                                                      P0 = type1[n6]&0x7f;  // 加入小数点
 181   3                                                                              }
 182   2                                                                              else
 183   2                                                                                      P0 = type1[n6];
 184   2                                                                                                        P2 &= 0x1f;break;
 185   2                      case 6:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n7];P2 &= 0x1f;break;
 186   2                      case 7:P2 = (P2 & 0x1f) | 0xe0;P0 = type1[n8];P2 &= 0x1f;break;
 187   2              }
 188   1              if(++i==8)
 189   1                      i = 0;
 190   1      }
 191          //============================================独立按键============================================
 192          /***************************************************
 193          写法一：
 194          有按键被按下，GN标记，后面根据需要功能进行操作
 195          ***************************************************/
 196          void Delay_Keys(uint t)
 197          {
 198   1              while(t--);
 199   1      }
 200          uchar Scan_Keys_Alone()
 201          {
 202   1              char d;
 203   1              d = (~P3) & 0x0f;
 204   1              if(d == 0) return 0;
 205   1              Delay_Keys(100);
 206   1              if(d == 0) return 0;
 207   1              Delay_Keys(100);
 208   1              return d;
 209   1      }
 210          void Change_Keys_Alone()
 211          {
 212   1              switch(Scan_Keys_Alone())
 213   1              {
 214   2                      case 8:GN = 1;break;//S4
 215   2                      case 4:GN = 2;break;//S5
 216   2                      case 2:GN = 3;break;//S6
 217   2                      case 1:GN = 4;break;//S7
 218   2                      case 0:GN = 0;break;
 219   2              }
 220   1      }
 221          
 222          /***************************************************
 223          写法二：
 224          有按键被按下，按下是一种状态，松开是另一种状态
 225          （如：按下时某个灯亮，松开时灯灭）
 226          ***************************************************/
 227          void ScanKeys_Alone() 
 228          {
 229   1              if (S7 == 0) {
 230   2                      Delay_Keys(100);
 231   2                      if (S7 == 0) {
 232   3                              // =========================================== 代码开始 ======================================
 233   3                              
 234   3                              // =========================================== 代码结束 ======================================
 235   3                              while(S7 == 0);
 236   3                              // =========================================== 代码开始 ======================================
 237   3      
 238   3                              // =========================================== 代码结束 ======================================
 239   3                      }
 240   2              }
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 5   

 241   1              
 242   1              if (S6 == 0) {
 243   2                      Delay_Keys(100);
 244   2                      if (S6 == 0) {
 245   3                              // =========================================== 代码开始 ======================================
 246   3                              
 247   3                              // =========================================== 代码结束 ======================================
 248   3                              while(S6 == 0);
 249   3                              // =========================================== 代码开始 ======================================
 250   3      
 251   3                              // =========================================== 代码结束 ======================================
 252   3                      }
 253   2              }
 254   1              
 255   1              if (S5 == 0) {
 256   2                      Delay_Keys(100);
 257   2                      if (S5 == 0) {
 258   3                              // =========================================== 代码开始 ======================================
 259   3      
 260   3                              // =========================================== 代码结束 ======================================
 261   3                              while(S5 == 0);
 262   3                              // =========================================== 代码开始 ======================================
 263   3      
 264   3                              // =========================================== 代码结束 ======================================
 265   3                      }
 266   2              }
 267   1      
 268   1              if (S4 == 0) {
 269   2                      Delay_Keys(100);
 270   2                      if (S4 == 0) {
 271   3                              // =========================================== 代码开始 ======================================
 272   3      
 273   3                              // =========================================== 代码结束 ======================================
 274   3                              while(S4 == 0);
 275   3                              // =========================================== 代码开始 ======================================
 276   3      
 277   3                              // =========================================== 代码结束 ======================================
 278   3                      }
 279   2              }
 280   1      }
 281          
 282          // ================= 代码结束 =============
 283          
 284          //============================================矩阵按键============================================
 285          sfr P4 = 0xc0;
 286          sbit P44 = P4^4;
 287          sbit P42 = P4^2;
 288          
 289          uchar Scan_Keys()
 290          {
 291   1              char H,L;
 292   1              
 293   1      //      TR0 = 0;
 294   1              
 295   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 296   1              if(H == 0) return 0;
 297   1              Delay_Keys(100);
 298   1              P3 =  0xcf;P44 = 0;P42 = 0;H = (~P3) & 0x0f;
 299   1              if(H == 0) return 0;
 300   1              P3 =  0xf0;P44 = 1;P42 = 1;L = (~P3) & 0x30;
 301   1              if(P44 == 0) L |= 0x80;
 302   1              if(P42 == 0) L |= 0x40;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 6   

 303   1              
 304   1      //      TR0 = 1;
 305   1              
 306   1              return (H+L);
 307   1      }
 308          
 309          void Change_Keys()
 310          {
 311   1              switch(Scan_Keys())
 312   1              {
 313   2                      case 0x88:GN = 4;break;  // S4
 314   2                      case 0x84:GN = 5;break;  // S5
 315   2                      case 0x82:GN = 6;break;  // S6
 316   2                      case 0x81:GN = 7;break;  // S7
 317   2                      case 0x48:GN = 8;break;  // S8
 318   2                      case 0x44:GN = 9;break;  // S9
 319   2                      case 0x42:GN = 10;break;  // S10
 320   2                      case 0x41:GN = 11;break;  // S11
 321   2                      case 0x28:GN = 12;break;  // S12
 322   2                      case 0x24:GN = 13;break;  // S13
 323   2                      case 0x22:GN = 14;break;  // S14
 324   2                      case 0x21:GN = 15;break;  // S15
 325   2                      case 0x18:GN = 16;break;  // S16
 326   2                      case 0x14:GN = 17;break;  // S17
 327   2                      case 0x12:GN = 18;break;  // S18
 328   2                      case 0x11:GN = 19;break;  // S19
 329   2                      case 0:GN = 0;break;
 330   2              }
 331   1      }
 332          
 333          sbit P32 = P3^2;
 334          sbit P33 = P3^3;
 335          void key_array_init() {
 336   1              P32 = 1;
 337   1              P33 = 1;
 338   1              P42 = 0;
 339   1              P44 = 0;
 340   1      }
 341          
 342          void key_array_scan() {
 343   1              if (P32 == 0) {
 344   2                      P32 = 0;
 345   2                      P42 = 1;
 346   2                      P44 = 1;
 347   2                      if (P42 == 0) {
 348   3                              Delay_Keys(100);
 349   3                              if (P42 == 0) {  // S9
 350   4                                      // =========================================== 代码开始 ======================================
 351   4                                      
 352   4                                      // =========================================== 代码结束 ======================================
 353   4                                      while (P42 == 0);
 354   4                                      // =========================================== 代码开始 ======================================
 355   4                                      num1 = 9;
 356   4                                      // =========================================== 代码结束 ======================================
 357   4                              }
 358   3                      }
 359   2                      else if (P44 == 0) {
 360   3                              Delay_Keys(100);
 361   3                              if (P44 == 0) {  // S5
 362   4                                      // =========================================== 代码开始 ======================================
 363   4                                      
 364   4                                      // =========================================== 代码结束 ======================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 7   

 365   4                                      while (P44 == 0);
 366   4                                      // =========================================== 代码开始 ======================================
 367   4                                      num1 = 5;
 368   4                                      // =========================================== 代码结束 ======================================
 369   4                              }
 370   3                      }
 371   2              }
 372   1              
 373   1              if (P33 == 0) {
 374   2                      P33 = 0;
 375   2                      P42 = 1;
 376   2                      P44 = 1;
 377   2                      if (P42 == 0) {
 378   3                              Delay_Keys(100);
 379   3                              if (P42 == 0) {  // S8
 380   4                                      // =========================================== 代码开始 ======================================
 381   4      
 382   4                                      // =========================================== 代码结束 ======================================
 383   4                                      while (P42 == 0);
 384   4                                      // =========================================== 代码开始 ======================================
 385   4                                      num1 = 8;
 386   4                                      // =========================================== 代码结束 ======================================
 387   4                              }
 388   3                      }
 389   2                      else if (P44 == 0) {
 390   3                              Delay_Keys(100);
 391   3                              if (P44 == 0) {  // S4
 392   4                                      // =========================================== 代码开始 ======================================
 393   4                                      
 394   4                                      // =========================================== 代码结束 ======================================
 395   4                                      while(P44 == 0);
 396   4                                      // =========================================== 代码开始 ======================================
 397   4                                      num1 = 4;
 398   4                                      // =========================================== 代码结束 ======================================
 399   4                              }
 400   3                      }
 401   2              }
 402   1              
 403   1              key_array_init();
 404   1      }
 405          
 406          //============================================定时器T1初始化=======================================
 407          void Init_T1()
 408          {
 409   1              TMOD = (TMOD & 0xf0) | 0x10;//定时
 410   1              TH1 = (65536 - 2000) / 256;//2ms
 411   1              TL1 = (65536 - 2000) % 256;
 412   1              
 413   1              EA = 1;
 414   1              ET1 = 1;
 415   1              TR1 = 1;
 416   1      }
 417          //============================================定时器T0初始化=======================================
 418          void Init_T0()
 419          {
 420   1              TMOD = (TMOD & 0xf0) | 0x05;//定时
 421   1              TH0 = 0;
 422   1              TL0 = 0;
 423   1              
 424   1              TR0 = 1;
 425   1      }
 426          //==========================================系统初始化=============================================
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 8   

 427          void Init_Sys()
 428          {
 429   1              P2 = (P2 & 0x1f) | 0x80;  // LED
 430   1              P0 = 0xff;
 431   1              P2 &= 0x1f;
 432   1              P2 = (P2 & 0x1f) | 0xa0;  // 蜂鸣器，寄存器
 433   1              P0 = 0x00;
 434   1              P2 &= 0x1f;
 435   1              P2 = (P2 & 0x1f) | 0xc0;  // 数码管
 436   1              P0 = 0xff;
 437   1              P2 &= 0x1f;
 438   1              P2 = (P2 & 0x1f) | 0xe0;
 439   1              P0 = 0xff;
 440   1              
 441   1              num1=num2=num3=num4=num5=num6=num7=num8=10;
 442   1      }
 443          
 444          void LED_control() {
 445   1              // ================= 测试开始 =============
 446   1      //      P2 = (P2 & 0x1f) | 0x80;  // LED控制开启
 447   1      //      P0 = 0x7f;  // 要将P0放在这两句代码之间，避免错乱
 448   1      //      P2 &= 0x1f;
 449   1              // ================= 测试结束 =============
 450   1              
 451   1              // =========================================== 代码开始 ======================================
 452   1              
 453   1              // =========================================== 代码结束 ======================================
 454   1      }
 455          
 456          void main()
 457          {
 458   1              Init_Sys();
 459   1              Init_T1();
 460   1              Init_T0();
 461   1              
 462   1              while(1)
 463   1              {
 464   2      //              LED_control();
 465   2              if(f_2ms == 1)
 466   2              {
 467   3                  f_2ms = 0;                  
 468   3                              LED_control();  // xxx
 469   3                              // =======================按键========================
 470   3      //                      Change_Keys_Alone();  // 1.独立按键扫描(1)
 471   3      //                      ScanKeys_Alone();     // 2.独立按键扫描(2)
 472   3                              Change_Keys();        // 3.矩阵按键扫描
 473   3      //                      key_array_scan();     // 4.矩阵按键扫描(Ne555专用)
 474   3                              if (GN == 4) {
 475   4                                      Relay_On();
 476   4                                      while(Scan_Keys());
 477   4                                      Relay_Off();
 478   4                              }
 479   3                              if (GN == 5) {
 480   4                                      Buzzer_On();
 481   4                                      while(Scan_Keys());
 482   4                                      Buzzer_Off();
 483   4                              }
 484   3                              // =========================================== 代码开始 ======================================
 485   3      //                      num3 = freq / 10000;
 486   3      //                      num4 = freq % 10000 / 1000;
 487   3      //                      num5 = freq % 1000 / 100;
 488   3      //                      num6 = freq % 100 / 10;
C51 COMPILER V9.60.7.0   MAIN                                                              04/12/2024 21:03:19 PAGE 9   

 489   3      //                      num7 = freq % 10;
 490   3                              // =========================================== 代码结束 ======================================
 491   3              }
 492   2          }
 493   1      }
 494          void Service_T1() interrupt 3
 495          {
 496   1              TH1 = (65536 - 2000) / 256;
 497   1              TL1 = (65536 - 2000) % 256;
 498   1              
 499   1              f_2ms = 1;
 500   1              
 501   1              if (++ num_2ms == 5) {
 502   2                      num_2ms = 0;
 503   2                      f_10ms = 1;
 504   2              }
 505   1              /***************************************************
 506   1              与时间相关的变量的更新放在里面
 507   1              注意：不要把消耗过长时间的代码（如for循环等）放在这里，容易造成错乱
 508   1              ***************************************************/
 509   1              // =========================================== 代码开始 ======================================
 510   1              if (++ num_2ms_ne555 >= 500)
 511   1              {
 512   2                      num_2ms_ne555 = 0;
 513   2                      freq = (TH0 << 8) | TL0;
 514   2                      TH0 = 0;
 515   2                      TL0 = 0;
 516   2              }
 517   1              // =========================================== 代码结束 ======================================
 518   1              
 519   1              Display_SMG(num1,num2,num3,num4,num5,num6,num7,num8);//2ms刷新数码管
 520   1      }
*** WARNING C294 IN LINE 180 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1250    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
